{"ast":null,"code":"import { struct, u16, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionKeysError, TokenInvalidInstructionProgramError, TokenInvalidInstructionTypeError, TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { COptionPublicKeyLayout } from '../../serialization.js';\nexport var TransferFeeInstruction;\n(function (TransferFeeInstruction) {\n  TransferFeeInstruction[TransferFeeInstruction[\"InitializeTransferFeeConfig\"] = 0] = \"InitializeTransferFeeConfig\";\n  TransferFeeInstruction[TransferFeeInstruction[\"TransferCheckedWithFee\"] = 1] = \"TransferCheckedWithFee\";\n  TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromMint\"] = 2] = \"WithdrawWithheldTokensFromMint\";\n  TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromAccounts\"] = 3] = \"WithdrawWithheldTokensFromAccounts\";\n  TransferFeeInstruction[TransferFeeInstruction[\"HarvestWithheldTokensToMint\"] = 4] = \"HarvestWithheldTokensToMint\";\n  TransferFeeInstruction[TransferFeeInstruction[\"SetTransferFee\"] = 5] = \"SetTransferFee\";\n})(TransferFeeInstruction || (TransferFeeInstruction = {}));\n/** TODO: docs */\nexport const initializeTransferFeeConfigInstructionData = struct([u8('instruction'), u8('transferFeeInstruction'), new COptionPublicKeyLayout('transferFeeConfigAuthority'), new COptionPublicKeyLayout('withdrawWithheldAuthority'), u16('transferFeeBasisPoints'), u64('maximumFee')]);\n/**\r\n * Construct an InitializeTransferFeeConfig instruction\r\n *\r\n * @param mint            Token mint account\r\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\r\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\r\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\r\n * @param maximumFee        Maximum fee assessed on transfers\r\n * @param programId       SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\nexport function createInitializeTransferFeeConfigInstruction(mint, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee, programId = TOKEN_2022_PROGRAM_ID) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const keys = [{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }];\n  const data = Buffer.alloc(initializeTransferFeeConfigInstructionData.span);\n  initializeTransferFeeConfigInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\n    transferFeeConfigAuthority: transferFeeConfigAuthority,\n    withdrawWithheldAuthority: withdrawWithheldAuthority,\n    transferFeeBasisPoints: transferFeeBasisPoints,\n    maximumFee: maximumFee\n  }, data);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\r\n * Decode an InitializeTransferFeeConfig instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\nexport function decodeInitializeTransferFeeConfigInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== initializeTransferFeeConfigInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint\n    },\n    data\n  } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint\n    },\n    data\n  };\n}\n/**\r\n * Decode an InitializeTransferFeeConfig instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\nexport function decodeInitializeTransferFeeConfigInstructionUnchecked({\n  programId,\n  keys: [mint],\n  data\n}) {\n  const {\n    instruction,\n    transferFeeInstruction,\n    transferFeeConfigAuthority,\n    withdrawWithheldAuthority,\n    transferFeeBasisPoints,\n    maximumFee\n  } = initializeTransferFeeConfigInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      mint\n    },\n    data: {\n      instruction,\n      transferFeeInstruction,\n      transferFeeConfigAuthority,\n      withdrawWithheldAuthority,\n      transferFeeBasisPoints,\n      maximumFee\n    }\n  };\n}\nexport const transferCheckedWithFeeInstructionData = struct([u8('instruction'), u8('transferFeeInstruction'), u64('amount'), u8('decimals'), u64('fee')]);\n/**\r\n * Construct an TransferCheckedWithFee instruction\r\n *\r\n * @param source          The source account\r\n * @param mint            The token mint\r\n * @param destination     The destination account\r\n * @param authority       The source account's owner/delegate\r\n * @param signers         The signer account(s)\r\n * @param amount          The amount of tokens to transfer\r\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\r\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\r\n * @param programId       SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\nexport function createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);\n  transferCheckedWithFeeInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\n    amount,\n    decimals,\n    fee\n  }, data);\n  const keys = addSigners([{\n    pubkey: source,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: mint,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  }], authority, multiSigners);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\r\n * Decode a TransferCheckedWithFee instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\nexport function decodeTransferCheckedWithFeeInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== transferCheckedWithFeeInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      source,\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data\n  } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      source,\n      mint,\n      destination,\n      authority,\n      signers: signers ? signers : null\n    },\n    data\n  };\n}\n/**\r\n * Decode a TransferCheckedWithFees instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\nexport function decodeTransferCheckedWithFeeInstructionUnchecked({\n  programId,\n  keys: [source, mint, destination, authority, ...signers],\n  data\n}) {\n  const {\n    instruction,\n    transferFeeInstruction,\n    amount,\n    decimals,\n    fee\n  } = transferCheckedWithFeeInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      source,\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data: {\n      instruction,\n      transferFeeInstruction,\n      amount,\n      decimals,\n      fee\n    }\n  };\n}\nexport const withdrawWithheldTokensFromMintInstructionData = struct([u8('instruction'), u8('transferFeeInstruction')]);\n/**\r\n * Construct a WithdrawWithheldTokensFromMint instruction\r\n *\r\n * @param mint              The token mint\r\n * @param destination       The destination account\r\n * @param authority         The source account's owner/delegate\r\n * @param signers           The signer account(s)\r\n * @param programID         SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\nexport function createWithdrawWithheldTokensFromMintInstruction(mint, destination, authority, signers = [], programId = TOKEN_2022_PROGRAM_ID) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);\n  withdrawWithheldTokensFromMintInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint\n  }, data);\n  const keys = addSigners([{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  }], authority, signers);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\r\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\nexport function decodeWithdrawWithheldTokensFromMintInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data\n  } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers: signers ? signers : null\n    },\n    data\n  };\n}\n/**\r\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\nexport function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({\n  programId,\n  keys: [mint, destination, authority, ...signers],\n  data\n}) {\n  const {\n    instruction,\n    transferFeeInstruction\n  } = withdrawWithheldTokensFromMintInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers\n    },\n    data: {\n      instruction,\n      transferFeeInstruction\n    }\n  };\n}\nexport const withdrawWithheldTokensFromAccountsInstructionData = struct([u8('instruction'), u8('transferFeeInstruction'), u8('numTokenAccounts')]);\n/**\r\n * Construct a WithdrawWithheldTokensFromAccounts instruction\r\n *\r\n * @param mint              The token mint\r\n * @param destination       The destination account\r\n * @param authority         The source account's owner/delegate\r\n * @param signers           The signer account(s)\r\n * @param sources           The source accounts to withdraw from\r\n * @param programID         SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\nexport function createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authority, signers, sources, programId = TOKEN_2022_PROGRAM_ID) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);\n  withdrawWithheldTokensFromAccountsInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\n    numTokenAccounts: sources.length\n  }, data);\n  const keys = addSigners([{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  }], authority, signers);\n  for (const source of sources) {\n    keys.push({\n      pubkey: source,\n      isSigner: false,\n      isWritable: true\n    });\n  }\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\r\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers,\n      sources\n    },\n    data\n  } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers: signers ? signers : null,\n      sources: sources ? sources : null\n    },\n    data\n  };\n}\n/**\r\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({\n  programId,\n  keys,\n  data\n}) {\n  const {\n    instruction,\n    transferFeeInstruction,\n    numTokenAccounts\n  } = withdrawWithheldTokensFromAccountsInstructionData.decode(data);\n  const [mint, destination, authority, signers, sources] = [keys[0], keys[1], keys[2], keys.slice(3, 3 + numTokenAccounts), keys.slice(-1 * numTokenAccounts)];\n  return {\n    programId,\n    keys: {\n      mint,\n      destination,\n      authority,\n      signers,\n      sources\n    },\n    data: {\n      instruction,\n      transferFeeInstruction,\n      numTokenAccounts\n    }\n  };\n}\nexport const harvestWithheldTokensToMintInstructionData = struct([u8('instruction'), u8('transferFeeInstruction')]);\n/**\r\n * Construct a HarvestWithheldTokensToMint instruction\r\n *\r\n * @param mint              The token mint\r\n * @param sources           The source accounts to withdraw from\r\n * @param programID         SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\nexport function createHarvestWithheldTokensToMintInstruction(mint, sources, programId = TOKEN_2022_PROGRAM_ID) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);\n  harvestWithheldTokensToMintInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint\n  }, data);\n  const keys = [];\n  keys.push({\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  });\n  for (const source of sources) {\n    keys.push({\n      pubkey: source,\n      isSigner: false,\n      isWritable: true\n    });\n  }\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\r\n * Decode a HarvestWithheldTokensToMint instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\nexport function decodeHarvestWithheldTokensToMintInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint,\n      sources\n    },\n    data\n  } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint,\n      sources\n    },\n    data\n  };\n}\n/**\r\n * Decode a HarvestWithheldTokensToMint instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\nexport function decodeHarvestWithheldTokensToMintInstructionUnchecked({\n  programId,\n  keys: [mint, ...sources],\n  data\n}) {\n  const {\n    instruction,\n    transferFeeInstruction\n  } = harvestWithheldTokensToMintInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      mint,\n      sources\n    },\n    data: {\n      instruction,\n      transferFeeInstruction\n    }\n  };\n}\nexport const setTransferFeeInstructionData = struct([u8('instruction'), u8('transferFeeInstruction'), u16('transferFeeBasisPoints'), u64('maximumFee')]);\n/**\r\n * Construct a SetTransferFeeInstruction instruction\r\n *\r\n * @param mint                      The token mint\r\n * @param authority                 The authority of the transfer fee\r\n * @param signers                   The signer account(s)\r\n * @param transferFeeBasisPoints    Amount of transfer collected as fees, expressed as basis points of the transfer amount\r\n * @param maximumFee                Maximum fee assessed on transfers\r\n * @param programID                 SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\nexport function createSetTransferFeeInstruction(mint, authority, signers, transferFeeBasisPoints, maximumFee, programId = TOKEN_2022_PROGRAM_ID) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const data = Buffer.alloc(setTransferFeeInstructionData.span);\n  setTransferFeeInstructionData.encode({\n    instruction: TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.SetTransferFee,\n    transferFeeBasisPoints: transferFeeBasisPoints,\n    maximumFee: maximumFee\n  }, data);\n  const keys = addSigners([{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }], authority, signers);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\r\n * Decode an SetTransferFee instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\nexport function decodeSetTransferFeeInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== setTransferFeeInstructionData.span) throw new TokenInvalidInstructionDataError();\n  const {\n    keys: {\n      mint,\n      authority,\n      signers\n    },\n    data\n  } = decodeSetTransferFeeInstructionUnchecked(instruction);\n  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.SetTransferFee) throw new TokenInvalidInstructionTypeError();\n  if (!mint) throw new TokenInvalidInstructionKeysError();\n  return {\n    programId,\n    keys: {\n      mint,\n      authority,\n      signers: signers ? signers : null\n    },\n    data\n  };\n}\n/**\r\n * Decode a SetTransferFee instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\nexport function decodeSetTransferFeeInstructionUnchecked({\n  programId,\n  keys: [mint, authority, ...signers],\n  data\n}) {\n  const {\n    instruction,\n    transferFeeInstruction,\n    transferFeeBasisPoints,\n    maximumFee\n  } = setTransferFeeInstructionData.decode(data);\n  return {\n    programId,\n    keys: {\n      mint,\n      authority,\n      signers\n    },\n    data: {\n      instruction,\n      transferFeeInstruction,\n      transferFeeBasisPoints,\n      maximumFee\n    }\n  };\n}","map":{"version":3,"names":["struct","u16","u8","u64","TransactionInstruction","programSupportsExtensions","TOKEN_2022_PROGRAM_ID","TokenInvalidInstructionDataError","TokenInvalidInstructionKeysError","TokenInvalidInstructionProgramError","TokenInvalidInstructionTypeError","TokenUnsupportedInstructionError","addSigners","TokenInstruction","COptionPublicKeyLayout","TransferFeeInstruction","initializeTransferFeeConfigInstructionData","createInitializeTransferFeeConfigInstruction","mint","transferFeeConfigAuthority","withdrawWithheldAuthority","transferFeeBasisPoints","maximumFee","programId","keys","pubkey","isSigner","isWritable","data","Buffer","alloc","span","encode","instruction","TransferFeeExtension","transferFeeInstruction","InitializeTransferFeeConfig","decodeInitializeTransferFeeConfigInstruction","equals","length","decodeInitializeTransferFeeConfigInstructionUnchecked","decode","transferCheckedWithFeeInstructionData","createTransferCheckedWithFeeInstruction","source","destination","authority","amount","decimals","fee","multiSigners","TransferCheckedWithFee","decodeTransferCheckedWithFeeInstruction","signers","decodeTransferCheckedWithFeeInstructionUnchecked","withdrawWithheldTokensFromMintInstructionData","createWithdrawWithheldTokensFromMintInstruction","WithdrawWithheldTokensFromMint","decodeWithdrawWithheldTokensFromMintInstruction","decodeWithdrawWithheldTokensFromMintInstructionUnchecked","withdrawWithheldTokensFromAccountsInstructionData","createWithdrawWithheldTokensFromAccountsInstruction","sources","WithdrawWithheldTokensFromAccounts","numTokenAccounts","push","decodeWithdrawWithheldTokensFromAccountsInstruction","decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked","slice","harvestWithheldTokensToMintInstructionData","createHarvestWithheldTokensToMintInstruction","HarvestWithheldTokensToMint","decodeHarvestWithheldTokensToMintInstruction","decodeHarvestWithheldTokensToMintInstructionUnchecked","setTransferFeeInstructionData","createSetTransferFeeInstruction","SetTransferFee","decodeSetTransferFeeInstruction","decodeSetTransferFeeInstructionUnchecked"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token\\src\\extensions\\transferFee\\instructions.ts"],"sourcesContent":["import { struct, u16, u8 } from '@solana/buffer-layout';\r\nimport { u64 } from '@solana/buffer-layout-utils';\r\nimport type { AccountMeta, Signer, PublicKey } from '@solana/web3.js';\r\nimport { TransactionInstruction } from '@solana/web3.js';\r\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\r\nimport {\r\n    TokenInvalidInstructionDataError,\r\n    TokenInvalidInstructionKeysError,\r\n    TokenInvalidInstructionProgramError,\r\n    TokenInvalidInstructionTypeError,\r\n    TokenUnsupportedInstructionError,\r\n} from '../../errors.js';\r\nimport { addSigners } from '../../instructions/internal.js';\r\nimport { TokenInstruction } from '../../instructions/types.js';\r\nimport { COptionPublicKeyLayout } from '../../serialization.js';\r\n\r\nexport enum TransferFeeInstruction {\r\n    InitializeTransferFeeConfig = 0,\r\n    TransferCheckedWithFee = 1,\r\n    WithdrawWithheldTokensFromMint = 2,\r\n    WithdrawWithheldTokensFromAccounts = 3,\r\n    HarvestWithheldTokensToMint = 4,\r\n    SetTransferFee = 5,\r\n}\r\n\r\n// InitializeTransferFeeConfig\r\n\r\n/** TODO: docs */\r\nexport interface InitializeTransferFeeConfigInstructionData {\r\n    instruction: TokenInstruction.TransferFeeExtension;\r\n    transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\r\n    transferFeeConfigAuthority: PublicKey | null;\r\n    withdrawWithheldAuthority: PublicKey | null;\r\n    transferFeeBasisPoints: number;\r\n    maximumFee: bigint;\r\n}\r\n\r\n/** TODO: docs */\r\nexport const initializeTransferFeeConfigInstructionData = struct<InitializeTransferFeeConfigInstructionData>([\r\n    u8('instruction'),\r\n    u8('transferFeeInstruction'),\r\n    new COptionPublicKeyLayout('transferFeeConfigAuthority'),\r\n    new COptionPublicKeyLayout('withdrawWithheldAuthority'),\r\n    u16('transferFeeBasisPoints'),\r\n    u64('maximumFee'),\r\n]);\r\n\r\n/**\r\n * Construct an InitializeTransferFeeConfig instruction\r\n *\r\n * @param mint            Token mint account\r\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\r\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\r\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\r\n * @param maximumFee        Maximum fee assessed on transfers\r\n * @param programId       SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\r\nexport function createInitializeTransferFeeConfigInstruction(\r\n    mint: PublicKey,\r\n    transferFeeConfigAuthority: PublicKey | null,\r\n    withdrawWithheldAuthority: PublicKey | null,\r\n    transferFeeBasisPoints: number,\r\n    maximumFee: bigint,\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): TransactionInstruction {\r\n    if (!programSupportsExtensions(programId)) {\r\n        throw new TokenUnsupportedInstructionError();\r\n    }\r\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\r\n\r\n    const data = Buffer.alloc(initializeTransferFeeConfigInstructionData.span);\r\n    initializeTransferFeeConfigInstructionData.encode(\r\n        {\r\n            instruction: TokenInstruction.TransferFeeExtension,\r\n            transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\r\n            transferFeeConfigAuthority: transferFeeConfigAuthority,\r\n            withdrawWithheldAuthority: withdrawWithheldAuthority,\r\n            transferFeeBasisPoints: transferFeeBasisPoints,\r\n            maximumFee: maximumFee,\r\n        },\r\n        data,\r\n    );\r\n\r\n    return new TransactionInstruction({ keys, programId, data });\r\n}\r\n\r\n/** A decoded, valid InitializeTransferFeeConfig instruction */\r\nexport interface DecodedInitializeTransferFeeConfigInstruction {\r\n    programId: PublicKey;\r\n    keys: {\r\n        mint: AccountMeta;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\r\n        transferFeeConfigAuthority: PublicKey | null;\r\n        withdrawWithheldAuthority: PublicKey | null;\r\n        transferFeeBasisPoints: number;\r\n        maximumFee: bigint;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode an InitializeTransferFeeConfig instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\r\nexport function decodeInitializeTransferFeeConfigInstruction(\r\n    instruction: TransactionInstruction,\r\n    programId: PublicKey,\r\n): DecodedInitializeTransferFeeConfigInstruction {\r\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\r\n    if (instruction.data.length !== initializeTransferFeeConfigInstructionData.span)\r\n        throw new TokenInvalidInstructionDataError();\r\n\r\n    const {\r\n        keys: { mint },\r\n        data,\r\n    } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);\r\n    if (\r\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\r\n        data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig\r\n    )\r\n        throw new TokenInvalidInstructionTypeError();\r\n    if (!mint) throw new TokenInvalidInstructionKeysError();\r\n\r\n    return {\r\n        programId,\r\n        keys: {\r\n            mint,\r\n        },\r\n        data,\r\n    };\r\n}\r\n\r\n/** A decoded, non-validated InitializeTransferFeeConfig instruction */\r\nexport interface DecodedInitializeTransferFeeConfigInstructionUnchecked {\r\n    programId: PublicKey;\r\n    keys: {\r\n        mint: AccountMeta | undefined;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\r\n        transferFeeConfigAuthority: PublicKey | null;\r\n        withdrawWithheldAuthority: PublicKey | null;\r\n        transferFeeBasisPoints: number;\r\n        maximumFee: bigint;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode an InitializeTransferFeeConfig instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\r\nexport function decodeInitializeTransferFeeConfigInstructionUnchecked({\r\n    programId,\r\n    keys: [mint],\r\n    data,\r\n}: TransactionInstruction): DecodedInitializeTransferFeeConfigInstructionUnchecked {\r\n    const {\r\n        instruction,\r\n        transferFeeInstruction,\r\n        transferFeeConfigAuthority,\r\n        withdrawWithheldAuthority,\r\n        transferFeeBasisPoints,\r\n        maximumFee,\r\n    } = initializeTransferFeeConfigInstructionData.decode(data);\r\n\r\n    return {\r\n        programId,\r\n        keys: {\r\n            mint,\r\n        },\r\n        data: {\r\n            instruction,\r\n            transferFeeInstruction,\r\n            transferFeeConfigAuthority,\r\n            withdrawWithheldAuthority,\r\n            transferFeeBasisPoints,\r\n            maximumFee,\r\n        },\r\n    };\r\n}\r\n\r\n// TransferCheckedWithFee\r\nexport interface TransferCheckedWithFeeInstructionData {\r\n    instruction: TokenInstruction.TransferFeeExtension;\r\n    transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\r\n    amount: bigint;\r\n    decimals: number;\r\n    fee: bigint;\r\n}\r\n\r\nexport const transferCheckedWithFeeInstructionData = struct<TransferCheckedWithFeeInstructionData>([\r\n    u8('instruction'),\r\n    u8('transferFeeInstruction'),\r\n    u64('amount'),\r\n    u8('decimals'),\r\n    u64('fee'),\r\n]);\r\n\r\n/**\r\n * Construct an TransferCheckedWithFee instruction\r\n *\r\n * @param source          The source account\r\n * @param mint            The token mint\r\n * @param destination     The destination account\r\n * @param authority       The source account's owner/delegate\r\n * @param signers         The signer account(s)\r\n * @param amount          The amount of tokens to transfer\r\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\r\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\r\n * @param programId       SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\r\nexport function createTransferCheckedWithFeeInstruction(\r\n    source: PublicKey,\r\n    mint: PublicKey,\r\n    destination: PublicKey,\r\n    authority: PublicKey,\r\n    amount: bigint,\r\n    decimals: number,\r\n    fee: bigint,\r\n    multiSigners: (Signer | PublicKey)[] = [],\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): TransactionInstruction {\r\n    if (!programSupportsExtensions(programId)) {\r\n        throw new TokenUnsupportedInstructionError();\r\n    }\r\n    const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);\r\n    transferCheckedWithFeeInstructionData.encode(\r\n        {\r\n            instruction: TokenInstruction.TransferFeeExtension,\r\n            transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\r\n            amount,\r\n            decimals,\r\n            fee,\r\n        },\r\n        data,\r\n    );\r\n    const keys = addSigners(\r\n        [\r\n            { pubkey: source, isSigner: false, isWritable: true },\r\n            { pubkey: mint, isSigner: false, isWritable: false },\r\n            { pubkey: destination, isSigner: false, isWritable: true },\r\n        ],\r\n        authority,\r\n        multiSigners,\r\n    );\r\n    return new TransactionInstruction({ keys, programId, data });\r\n}\r\n\r\n/** A decoded, valid TransferCheckedWithFee instruction */\r\nexport interface DecodedTransferCheckedWithFeeInstruction {\r\n    programId: PublicKey;\r\n    keys: {\r\n        source: AccountMeta;\r\n        mint: AccountMeta;\r\n        destination: AccountMeta;\r\n        authority: AccountMeta;\r\n        signers: AccountMeta[] | null;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\r\n        amount: bigint;\r\n        decimals: number;\r\n        fee: bigint;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode a TransferCheckedWithFee instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\r\nexport function decodeTransferCheckedWithFeeInstruction(\r\n    instruction: TransactionInstruction,\r\n    programId: PublicKey,\r\n): DecodedTransferCheckedWithFeeInstruction {\r\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\r\n    if (instruction.data.length !== transferCheckedWithFeeInstructionData.span)\r\n        throw new TokenInvalidInstructionDataError();\r\n\r\n    const {\r\n        keys: { source, mint, destination, authority, signers },\r\n        data,\r\n    } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);\r\n    if (\r\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\r\n        data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee\r\n    )\r\n        throw new TokenInvalidInstructionTypeError();\r\n    if (!mint) throw new TokenInvalidInstructionKeysError();\r\n\r\n    return {\r\n        programId,\r\n        keys: {\r\n            source,\r\n            mint,\r\n            destination,\r\n            authority,\r\n            signers: signers ? signers : null,\r\n        },\r\n        data,\r\n    };\r\n}\r\n\r\n/** A decoded, non-validated TransferCheckedWithFees instruction */\r\nexport interface DecodedTransferCheckedWithFeeInstructionUnchecked {\r\n    programId: PublicKey;\r\n    keys: {\r\n        source: AccountMeta;\r\n        mint: AccountMeta;\r\n        destination: AccountMeta;\r\n        authority: AccountMeta;\r\n        signers: AccountMeta[] | undefined;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\r\n        amount: bigint;\r\n        decimals: number;\r\n        fee: bigint;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode a TransferCheckedWithFees instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\r\nexport function decodeTransferCheckedWithFeeInstructionUnchecked({\r\n    programId,\r\n    keys: [source, mint, destination, authority, ...signers],\r\n    data,\r\n}: TransactionInstruction): DecodedTransferCheckedWithFeeInstructionUnchecked {\r\n    const { instruction, transferFeeInstruction, amount, decimals, fee } =\r\n        transferCheckedWithFeeInstructionData.decode(data);\r\n\r\n    return {\r\n        programId,\r\n        keys: {\r\n            source,\r\n            mint,\r\n            destination,\r\n            authority,\r\n            signers,\r\n        },\r\n        data: {\r\n            instruction,\r\n            transferFeeInstruction,\r\n            amount,\r\n            decimals,\r\n            fee,\r\n        },\r\n    };\r\n}\r\n\r\n// WithdrawWithheldTokensFromMint\r\nexport interface WithdrawWithheldTokensFromMintInstructionData {\r\n    instruction: TokenInstruction.TransferFeeExtension;\r\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\r\n}\r\n\r\nexport const withdrawWithheldTokensFromMintInstructionData = struct<WithdrawWithheldTokensFromMintInstructionData>([\r\n    u8('instruction'),\r\n    u8('transferFeeInstruction'),\r\n]);\r\n\r\n/**\r\n * Construct a WithdrawWithheldTokensFromMint instruction\r\n *\r\n * @param mint              The token mint\r\n * @param destination       The destination account\r\n * @param authority         The source account's owner/delegate\r\n * @param signers           The signer account(s)\r\n * @param programID         SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\r\nexport function createWithdrawWithheldTokensFromMintInstruction(\r\n    mint: PublicKey,\r\n    destination: PublicKey,\r\n    authority: PublicKey,\r\n    signers: (Signer | PublicKey)[] = [],\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): TransactionInstruction {\r\n    if (!programSupportsExtensions(programId)) {\r\n        throw new TokenUnsupportedInstructionError();\r\n    }\r\n    const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);\r\n    withdrawWithheldTokensFromMintInstructionData.encode(\r\n        {\r\n            instruction: TokenInstruction.TransferFeeExtension,\r\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint,\r\n        },\r\n        data,\r\n    );\r\n    const keys = addSigners(\r\n        [\r\n            { pubkey: mint, isSigner: false, isWritable: true },\r\n            { pubkey: destination, isSigner: false, isWritable: true },\r\n        ],\r\n        authority,\r\n        signers,\r\n    );\r\n    return new TransactionInstruction({ keys, programId, data });\r\n}\r\n\r\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\r\nexport interface DecodedWithdrawWithheldTokensFromMintInstruction {\r\n    programId: PublicKey;\r\n    keys: {\r\n        mint: AccountMeta;\r\n        destination: AccountMeta;\r\n        authority: AccountMeta;\r\n        signers: AccountMeta[] | null;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\r\nexport function decodeWithdrawWithheldTokensFromMintInstruction(\r\n    instruction: TransactionInstruction,\r\n    programId: PublicKey,\r\n): DecodedWithdrawWithheldTokensFromMintInstruction {\r\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\r\n    if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span)\r\n        throw new TokenInvalidInstructionDataError();\r\n\r\n    const {\r\n        keys: { mint, destination, authority, signers },\r\n        data,\r\n    } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);\r\n    if (\r\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\r\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint\r\n    )\r\n        throw new TokenInvalidInstructionTypeError();\r\n    if (!mint) throw new TokenInvalidInstructionKeysError();\r\n\r\n    return {\r\n        programId,\r\n        keys: {\r\n            mint,\r\n            destination,\r\n            authority,\r\n            signers: signers ? signers : null,\r\n        },\r\n        data,\r\n    };\r\n}\r\n\r\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\r\nexport interface DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\r\n    programId: PublicKey;\r\n    keys: {\r\n        mint: AccountMeta;\r\n        destination: AccountMeta;\r\n        authority: AccountMeta;\r\n        signers: AccountMeta[] | null;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\r\nexport function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({\r\n    programId,\r\n    keys: [mint, destination, authority, ...signers],\r\n    data,\r\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\r\n    const { instruction, transferFeeInstruction } = withdrawWithheldTokensFromMintInstructionData.decode(data);\r\n\r\n    return {\r\n        programId,\r\n        keys: {\r\n            mint,\r\n            destination,\r\n            authority,\r\n            signers,\r\n        },\r\n        data: {\r\n            instruction,\r\n            transferFeeInstruction,\r\n        },\r\n    };\r\n}\r\n\r\n// WithdrawWithheldTokensFromAccounts\r\nexport interface WithdrawWithheldTokensFromAccountsInstructionData {\r\n    instruction: TokenInstruction.TransferFeeExtension;\r\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\r\n    numTokenAccounts: number;\r\n}\r\n\r\nexport const withdrawWithheldTokensFromAccountsInstructionData =\r\n    struct<WithdrawWithheldTokensFromAccountsInstructionData>([\r\n        u8('instruction'),\r\n        u8('transferFeeInstruction'),\r\n        u8('numTokenAccounts'),\r\n    ]);\r\n\r\n/**\r\n * Construct a WithdrawWithheldTokensFromAccounts instruction\r\n *\r\n * @param mint              The token mint\r\n * @param destination       The destination account\r\n * @param authority         The source account's owner/delegate\r\n * @param signers           The signer account(s)\r\n * @param sources           The source accounts to withdraw from\r\n * @param programID         SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\r\nexport function createWithdrawWithheldTokensFromAccountsInstruction(\r\n    mint: PublicKey,\r\n    destination: PublicKey,\r\n    authority: PublicKey,\r\n    signers: (Signer | PublicKey)[],\r\n    sources: PublicKey[],\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): TransactionInstruction {\r\n    if (!programSupportsExtensions(programId)) {\r\n        throw new TokenUnsupportedInstructionError();\r\n    }\r\n    const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);\r\n    withdrawWithheldTokensFromAccountsInstructionData.encode(\r\n        {\r\n            instruction: TokenInstruction.TransferFeeExtension,\r\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\r\n            numTokenAccounts: sources.length,\r\n        },\r\n        data,\r\n    );\r\n    const keys = addSigners(\r\n        [\r\n            { pubkey: mint, isSigner: false, isWritable: true },\r\n            { pubkey: destination, isSigner: false, isWritable: true },\r\n        ],\r\n        authority,\r\n        signers,\r\n    );\r\n    for (const source of sources) {\r\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\r\n    }\r\n    return new TransactionInstruction({ keys, programId, data });\r\n}\r\n\r\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\r\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstruction {\r\n    programId: PublicKey;\r\n    keys: {\r\n        mint: AccountMeta;\r\n        destination: AccountMeta;\r\n        authority: AccountMeta;\r\n        signers: AccountMeta[] | null;\r\n        sources: AccountMeta[] | null;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\r\n        numTokenAccounts: number;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\r\nexport function decodeWithdrawWithheldTokensFromAccountsInstruction(\r\n    instruction: TransactionInstruction,\r\n    programId: PublicKey,\r\n): DecodedWithdrawWithheldTokensFromAccountsInstruction {\r\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\r\n    if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span)\r\n        throw new TokenInvalidInstructionDataError();\r\n\r\n    const {\r\n        keys: { mint, destination, authority, signers, sources },\r\n        data,\r\n    } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);\r\n    if (\r\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\r\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts\r\n    )\r\n        throw new TokenInvalidInstructionTypeError();\r\n    if (!mint) throw new TokenInvalidInstructionKeysError();\r\n\r\n    return {\r\n        programId,\r\n        keys: {\r\n            mint,\r\n            destination,\r\n            authority,\r\n            signers: signers ? signers : null,\r\n            sources: sources ? sources : null,\r\n        },\r\n        data,\r\n    };\r\n}\r\n\r\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\r\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\r\n    programId: PublicKey;\r\n    keys: {\r\n        mint: AccountMeta;\r\n        destination: AccountMeta;\r\n        authority: AccountMeta;\r\n        signers: AccountMeta[] | null;\r\n        sources: AccountMeta[] | null;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\r\n        numTokenAccounts: number;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\r\nexport function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({\r\n    programId,\r\n    keys,\r\n    data,\r\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\r\n    const { instruction, transferFeeInstruction, numTokenAccounts } =\r\n        withdrawWithheldTokensFromAccountsInstructionData.decode(data);\r\n    const [mint, destination, authority, signers, sources] = [\r\n        keys[0],\r\n        keys[1],\r\n        keys[2],\r\n        keys.slice(3, 3 + numTokenAccounts),\r\n        keys.slice(-1 * numTokenAccounts),\r\n    ];\r\n    return {\r\n        programId,\r\n        keys: {\r\n            mint,\r\n            destination,\r\n            authority,\r\n            signers,\r\n            sources,\r\n        },\r\n        data: {\r\n            instruction,\r\n            transferFeeInstruction,\r\n            numTokenAccounts,\r\n        },\r\n    };\r\n}\r\n\r\n// HarvestWithheldTokensToMint\r\n\r\nexport interface HarvestWithheldTokensToMintInstructionData {\r\n    instruction: TokenInstruction.TransferFeeExtension;\r\n    transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\r\n}\r\n\r\nexport const harvestWithheldTokensToMintInstructionData = struct<HarvestWithheldTokensToMintInstructionData>([\r\n    u8('instruction'),\r\n    u8('transferFeeInstruction'),\r\n]);\r\n\r\n/**\r\n * Construct a HarvestWithheldTokensToMint instruction\r\n *\r\n * @param mint              The token mint\r\n * @param sources           The source accounts to withdraw from\r\n * @param programID         SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\r\nexport function createHarvestWithheldTokensToMintInstruction(\r\n    mint: PublicKey,\r\n    sources: PublicKey[],\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): TransactionInstruction {\r\n    if (!programSupportsExtensions(programId)) {\r\n        throw new TokenUnsupportedInstructionError();\r\n    }\r\n    const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);\r\n    harvestWithheldTokensToMintInstructionData.encode(\r\n        {\r\n            instruction: TokenInstruction.TransferFeeExtension,\r\n            transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint,\r\n        },\r\n        data,\r\n    );\r\n    const keys: AccountMeta[] = [];\r\n    keys.push({ pubkey: mint, isSigner: false, isWritable: true });\r\n    for (const source of sources) {\r\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\r\n    }\r\n    return new TransactionInstruction({ keys, programId, data });\r\n}\r\n\r\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\r\nexport interface DecodedHarvestWithheldTokensToMintInstruction {\r\n    programId: PublicKey;\r\n    keys: {\r\n        mint: AccountMeta;\r\n        sources: AccountMeta[] | null;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode a HarvestWithheldTokensToMint instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\r\nexport function decodeHarvestWithheldTokensToMintInstruction(\r\n    instruction: TransactionInstruction,\r\n    programId: PublicKey,\r\n): DecodedHarvestWithheldTokensToMintInstruction {\r\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\r\n    if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span)\r\n        throw new TokenInvalidInstructionDataError();\r\n\r\n    const {\r\n        keys: { mint, sources },\r\n        data,\r\n    } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);\r\n    if (\r\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\r\n        data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint\r\n    )\r\n        throw new TokenInvalidInstructionTypeError();\r\n    if (!mint) throw new TokenInvalidInstructionKeysError();\r\n\r\n    return {\r\n        programId,\r\n        keys: {\r\n            mint,\r\n            sources,\r\n        },\r\n        data,\r\n    };\r\n}\r\n\r\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\r\nexport interface DecodedHarvestWithheldTokensToMintInstructionUnchecked {\r\n    programId: PublicKey;\r\n    keys: {\r\n        mint: AccountMeta;\r\n        sources: AccountMeta[] | null;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode a HarvestWithheldTokensToMint instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\r\nexport function decodeHarvestWithheldTokensToMintInstructionUnchecked({\r\n    programId,\r\n    keys: [mint, ...sources],\r\n    data,\r\n}: TransactionInstruction): DecodedHarvestWithheldTokensToMintInstructionUnchecked {\r\n    const { instruction, transferFeeInstruction } = harvestWithheldTokensToMintInstructionData.decode(data);\r\n    return {\r\n        programId,\r\n        keys: {\r\n            mint,\r\n            sources,\r\n        },\r\n        data: {\r\n            instruction,\r\n            transferFeeInstruction,\r\n        },\r\n    };\r\n}\r\n\r\n// SetTransferFee\r\n\r\nexport interface SetTransferFeeInstructionData {\r\n    instruction: TokenInstruction.TransferFeeExtension;\r\n    transferFeeInstruction: TransferFeeInstruction.SetTransferFee;\r\n    transferFeeBasisPoints: number;\r\n    maximumFee: bigint;\r\n}\r\n\r\nexport const setTransferFeeInstructionData = struct<SetTransferFeeInstructionData>([\r\n    u8('instruction'),\r\n    u8('transferFeeInstruction'),\r\n    u16('transferFeeBasisPoints'),\r\n    u64('maximumFee'),\r\n]);\r\n\r\n/**\r\n * Construct a SetTransferFeeInstruction instruction\r\n *\r\n * @param mint                      The token mint\r\n * @param authority                 The authority of the transfer fee\r\n * @param signers                   The signer account(s)\r\n * @param transferFeeBasisPoints    Amount of transfer collected as fees, expressed as basis points of the transfer amount\r\n * @param maximumFee                Maximum fee assessed on transfers\r\n * @param programID                 SPL Token program account\r\n *\r\n * @return Instruction to add to a transaction\r\n */\r\nexport function createSetTransferFeeInstruction(\r\n    mint: PublicKey,\r\n    authority: PublicKey,\r\n    signers: (Signer | PublicKey)[],\r\n    transferFeeBasisPoints: number,\r\n    maximumFee: bigint,\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): TransactionInstruction {\r\n    if (!programSupportsExtensions(programId)) {\r\n        throw new TokenUnsupportedInstructionError();\r\n    }\r\n\r\n    const data = Buffer.alloc(setTransferFeeInstructionData.span);\r\n    setTransferFeeInstructionData.encode(\r\n        {\r\n            instruction: TokenInstruction.TransferFeeExtension,\r\n            transferFeeInstruction: TransferFeeInstruction.SetTransferFee,\r\n            transferFeeBasisPoints: transferFeeBasisPoints,\r\n            maximumFee: maximumFee,\r\n        },\r\n        data,\r\n    );\r\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, signers);\r\n\r\n    return new TransactionInstruction({ keys, programId, data });\r\n}\r\n\r\n/** A decoded, valid SetTransferFee instruction */\r\nexport interface DecodedSetTransferFeeInstruction {\r\n    programId: PublicKey;\r\n    keys: {\r\n        mint: AccountMeta;\r\n        authority: AccountMeta;\r\n        signers: AccountMeta[] | null;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.SetTransferFee;\r\n        transferFeeBasisPoints: number;\r\n        maximumFee: bigint;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode an SetTransferFee instruction and validate it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n * @param programId   SPL Token program account\r\n *\r\n * @return Decoded, valid instruction\r\n */\r\nexport function decodeSetTransferFeeInstruction(\r\n    instruction: TransactionInstruction,\r\n    programId: PublicKey,\r\n): DecodedSetTransferFeeInstruction {\r\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\r\n    if (instruction.data.length !== setTransferFeeInstructionData.span) throw new TokenInvalidInstructionDataError();\r\n\r\n    const {\r\n        keys: { mint, authority, signers },\r\n        data,\r\n    } = decodeSetTransferFeeInstructionUnchecked(instruction);\r\n    if (\r\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\r\n        data.transferFeeInstruction !== TransferFeeInstruction.SetTransferFee\r\n    )\r\n        throw new TokenInvalidInstructionTypeError();\r\n    if (!mint) throw new TokenInvalidInstructionKeysError();\r\n\r\n    return {\r\n        programId,\r\n        keys: {\r\n            mint,\r\n            authority,\r\n            signers: signers ? signers : null,\r\n        },\r\n        data,\r\n    };\r\n}\r\n\r\n/** A decoded, valid SetTransferFee instruction */\r\nexport interface DecodedSetTransferFeeInstructionUnchecked {\r\n    programId: PublicKey;\r\n    keys: {\r\n        mint: AccountMeta;\r\n        authority: AccountMeta;\r\n        signers: AccountMeta[] | undefined;\r\n    };\r\n    data: {\r\n        instruction: TokenInstruction.TransferFeeExtension;\r\n        transferFeeInstruction: TransferFeeInstruction.SetTransferFee;\r\n        transferFeeBasisPoints: number;\r\n        maximumFee: bigint;\r\n    };\r\n}\r\n\r\n/**\r\n * Decode a SetTransferFee instruction without validating it\r\n *\r\n * @param instruction Transaction instruction to decode\r\n *\r\n * @return Decoded, non-validated instruction\r\n */\r\nexport function decodeSetTransferFeeInstructionUnchecked({\r\n    programId,\r\n    keys: [mint, authority, ...signers],\r\n    data,\r\n}: TransactionInstruction): DecodedSetTransferFeeInstructionUnchecked {\r\n    const { instruction, transferFeeInstruction, transferFeeBasisPoints, maximumFee } =\r\n        setTransferFeeInstructionData.decode(data);\r\n\r\n    return {\r\n        programId,\r\n        keys: {\r\n            mint,\r\n            authority,\r\n            signers,\r\n        },\r\n        data: {\r\n            instruction,\r\n            transferFeeInstruction,\r\n            transferFeeBasisPoints,\r\n            maximumFee,\r\n        },\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}