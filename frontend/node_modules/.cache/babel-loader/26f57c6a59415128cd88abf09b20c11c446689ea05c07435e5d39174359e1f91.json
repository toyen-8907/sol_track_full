{"ast":null,"code":"import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidMintError, TokenInvalidOwnerError } from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n  const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);\n  // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n  // Sadly we can't do this atomically.\n  let account;\n  try {\n    account = await getAccount(connection, associatedToken, commitment, programId);\n  } catch (error) {\n    // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n    // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n    // TokenInvalidAccountOwnerError in this code path.\n    if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n      // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n      try {\n        const transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));\n        await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n      } catch (error) {\n        // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n        // instruction error if the associated account exists already.\n      }\n      // Now this should always succeed\n      account = await getAccount(connection, associatedToken, commitment, programId);\n    } else {\n      throw error;\n    }\n  }\n  if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n  if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n  return account;\n}","map":{"version":3,"names":["sendAndConfirmTransaction","Transaction","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidMintError","TokenInvalidOwnerError","createAssociatedTokenAccountInstruction","getAccount","getAssociatedTokenAddressSync","getOrCreateAssociatedTokenAccount","connection","payer","mint","owner","allowOwnerOffCurve","commitment","confirmOptions","programId","associatedTokenProgramId","associatedToken","account","error","transaction","add","publicKey","equals"],"sources":["/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token/src/actions/getOrCreateAssociatedTokenAccount.ts"],"sourcesContent":["import type { Commitment, ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidMintError,\n    TokenInvalidOwnerError,\n} from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport type { Account } from '../state/account.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    commitment?: Commitment,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): Promise<Account> {\n    const associatedToken = getAssociatedTokenAddressSync(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n    let account: Account;\n    try {\n        account = await getAccount(connection, associatedToken, commitment, programId);\n    } catch (error: unknown) {\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n        // TokenInvalidAccountOwnerError in this code path.\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n            try {\n                const transaction = new Transaction().add(\n                    createAssociatedTokenAccountInstruction(\n                        payer.publicKey,\n                        associatedToken,\n                        owner,\n                        mint,\n                        programId,\n                        associatedTokenProgramId,\n                    ),\n                );\n\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n            } catch (error: unknown) {\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n                // instruction error if the associated account exists already.\n            }\n\n            // Now this should always succeed\n            account = await getAccount(connection, associatedToken, commitment, programId);\n        } else {\n            throw error;\n        }\n    }\n\n    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n    if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n\n    return account;\n}\n"],"mappings":"AACA,SAASA,yBAAyB,EAAEC,WAAW,QAAQ,iBAAiB;AACxE,SAASC,2BAA2B,EAAEC,gBAAgB,QAAQ,iBAAiB;AAC/E,SACIC,yBAAyB,EACzBC,6BAA6B,EAC7BC,qBAAqB,EACrBC,sBAAsB,QACnB,cAAc;AACrB,SAASC,uCAAuC,QAAQ,2CAA2C;AAEnG,SAASC,UAAU,QAAQ,qBAAqB;AAChD,SAASC,6BAA6B,QAAQ,kBAAkB;AAEhE;;;;;;;;;;;;;;;AAeA,OAAO,eAAeC,iCAAiCA,CACnDC,UAAsB,EACtBC,KAAa,EACbC,IAAe,EACfC,KAAgB,EAChBC,kBAAkB,GAAG,KAAK,EAC1BC,UAAuB,EACvBC,cAA+B,EAC/BC,SAAS,GAAGhB,gBAAgB,EAC5BiB,wBAAwB,GAAGlB,2BAA2B;EAEtD,MAAMmB,eAAe,GAAGX,6BAA6B,CACjDI,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBG,SAAS,EACTC,wBAAwB,CAC3B;EAED;EACA;EACA,IAAIE,OAAgB;EACpB,IAAI;IACAA,OAAO,GAAG,MAAMb,UAAU,CAACG,UAAU,EAAES,eAAe,EAAEJ,UAAU,EAAEE,SAAS,CAAC;EAClF,CAAC,CAAC,OAAOI,KAAc,EAAE;IACrB;IACA;IACA;IACA,IAAIA,KAAK,YAAYnB,yBAAyB,IAAImB,KAAK,YAAYlB,6BAA6B,EAAE;MAC9F;MACA,IAAI;QACA,MAAMmB,WAAW,GAAG,IAAIvB,WAAW,EAAE,CAACwB,GAAG,CACrCjB,uCAAuC,CACnCK,KAAK,CAACa,SAAS,EACfL,eAAe,EACfN,KAAK,EACLD,IAAI,EACJK,SAAS,EACTC,wBAAwB,CAC3B,CACJ;QAED,MAAMpB,yBAAyB,CAACY,UAAU,EAAEY,WAAW,EAAE,CAACX,KAAK,CAAC,EAAEK,cAAc,CAAC;MACrF,CAAC,CAAC,OAAOK,KAAc,EAAE;QACrB;QACA;MAAA;MAGJ;MACAD,OAAO,GAAG,MAAMb,UAAU,CAACG,UAAU,EAAES,eAAe,EAAEJ,UAAU,EAAEE,SAAS,CAAC;IAClF,CAAC,MAAM;MACH,MAAMI,KAAK;IACf;EACJ;EAEA,IAAI,CAACD,OAAO,CAACR,IAAI,CAACa,MAAM,CAACb,IAAI,CAAC,EAAE,MAAM,IAAIR,qBAAqB,EAAE;EACjE,IAAI,CAACgB,OAAO,CAACP,KAAK,CAACY,MAAM,CAACZ,KAAK,CAAC,EAAE,MAAM,IAAIR,sBAAsB,EAAE;EAEpE,OAAOe,OAAO;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}