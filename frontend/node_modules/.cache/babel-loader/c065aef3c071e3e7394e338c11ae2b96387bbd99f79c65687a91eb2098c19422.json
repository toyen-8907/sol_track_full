{"ast":null,"code":"/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { validateField, nLength } from './modular.js';\nimport { validateObject, bitLen } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF(c, bits) {\n  const constTimeNegate = (condition, item) => {\n    const neg = item.negate();\n    return condition ? neg : item;\n  };\n  const validateW = W => {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(`Wrong window size=${W}, should be [1..${bits}]`);\n  };\n  const opts = W => {\n    validateW(W);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return {\n      windows,\n      windowSize\n    };\n  };\n  return {\n    constTimeNegate,\n    // non-const time multiplication ladder\n    unsafeLadder(elm, n) {\n      let p = c.ZERO;\n      let d = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n    /**\r\n     * Creates a wNAF precomputation window. Used for caching.\r\n     * Default window size is set by `utils.precompute()` and is equal to 8.\r\n     * Number of precomputed points depends on the curve size:\r\n     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\r\n     * - ùëä is the window size\r\n     * - ùëõ is the bitlength of the curve order.\r\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\r\n     * @returns precomputed point tables flattened to a single array\r\n     */\n    precomputeWindow(elm, W) {\n      const {\n        windows,\n        windowSize\n      } = opts(W);\n      const points = [];\n      let p = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n    /**\r\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\r\n     * @param W window size\r\n     * @param precomputes precomputed tables\r\n     * @param n scalar (we don't check here, but should be less than curve order)\r\n     * @returns real and fake (for const-time) points\r\n     */\n    wNAF(W, precomputes, n) {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const {\n        windows,\n        windowSize\n      } = opts(W);\n      let p = c.ZERO;\n      let f = c.BASE;\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n        // Shift number by W bits.\n        n >>= shiftBy;\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return {\n        p,\n        f\n      };\n    },\n    wNAFCached(P, n, transform) {\n      const W = pointWindowSizes.get(P) || 1;\n      // Calculate precomputes on a first run, reuse them after\n      let comp = pointPrecomputes.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W);\n        if (W !== 1) pointPrecomputes.set(P, transform(comp));\n      }\n      return this.wNAF(W, comp, n);\n    },\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    setWindowSize(P, W) {\n      validateW(W);\n      pointWindowSizes.set(P, W);\n      pointPrecomputes.delete(P);\n    }\n  };\n}\n/**\r\n * Pippenger algorithm for multi-scalar multiplication (MSM).\r\n * MSM is basically (Pa + Qb + Rc + ...).\r\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\r\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\r\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\r\n * @param c Curve Point constructor\r\n * @param field field over CURVE.N - important that it's not over CURVE.P\r\n * @param points array of L curve points\r\n * @param scalars array of L scalars (aka private keys / bigints)\r\n */\nexport function pippenger(c, field, points, scalars) {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  if (!Array.isArray(points) || !Array.isArray(scalars) || scalars.length !== points.length) throw new Error('arrays of points and scalars must have equal length');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error(`wrong scalar at index ${i}`);\n  });\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error(`wrong point at index ${i}`);\n  });\n  const wbits = bitLen(BigInt(points.length));\n  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n  const MASK = (1 << windowSize) - 1;\n  const buckets = new Array(MASK + 1).fill(c.ZERO); // +1 for zero array\n  const lastBits = Math.floor((field.BITS - 1) / windowSize) * windowSize;\n  let sum = c.ZERO;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(c.ZERO);\n    for (let j = 0; j < scalars.length; j++) {\n      const scalar = scalars[j];\n      const wbits = Number(scalar >> BigInt(i) & BigInt(MASK));\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = c.ZERO; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = c.ZERO; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum;\n}\nexport function validateBasic(curve) {\n  validateField(curve.Fp);\n  validateObject(curve, {\n    n: 'bigint',\n    h: 'bigint',\n    Gx: 'field',\n    Gy: 'field'\n  }, {\n    nBitLength: 'isSafeInteger',\n    nByteLength: 'isSafeInteger'\n  });\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{\n      p: curve.Fp.ORDER\n    }\n  });\n}","map":{"version":3,"names":["validateField","nLength","validateObject","bitLen","_0n","BigInt","_1n","pointPrecomputes","WeakMap","pointWindowSizes","wNAF","c","bits","constTimeNegate","condition","item","neg","negate","validateW","W","Number","isSafeInteger","Error","opts","windows","Math","ceil","windowSize","unsafeLadder","elm","n","p","ZERO","d","add","double","precomputeWindow","points","base","window","push","i","precomputes","f","BASE","mask","maxNumber","shiftBy","offset","wbits","offset1","offset2","abs","cond1","cond2","wNAFCached","P","transform","get","comp","set","setWindowSize","delete","pippenger","field","scalars","Array","isArray","length","forEach","s","isValid","MASK","buckets","fill","lastBits","floor","BITS","sum","j","scalar","resI","sumI","validateBasic","curve","Fp","h","Gx","Gy","nBitLength","nByteLength","Object","freeze","ORDER"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@noble\\curves\\src\\abstract\\curve.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// Abelian group utilities\r\nimport { IField, validateField, nLength } from './modular.js';\r\nimport { validateObject, bitLen } from './utils.js';\r\nconst _0n = BigInt(0);\r\nconst _1n = BigInt(1);\r\n\r\nexport type AffinePoint<T> = {\r\n  x: T;\r\n  y: T;\r\n} & { z?: never; t?: never };\r\n\r\nexport interface Group<T extends Group<T>> {\r\n  double(): T;\r\n  negate(): T;\r\n  add(other: T): T;\r\n  subtract(other: T): T;\r\n  equals(other: T): boolean;\r\n  multiply(scalar: bigint): T;\r\n}\r\n\r\nexport type GroupConstructor<T> = {\r\n  BASE: T;\r\n  ZERO: T;\r\n};\r\nexport type Mapper<T> = (i: T[]) => T[];\r\n\r\n// Since points in different groups cannot be equal (different object constructor),\r\n// we can have single place to store precomputes\r\nconst pointPrecomputes = new WeakMap<any, any[]>();\r\nconst pointWindowSizes = new WeakMap<any, number>(); // This allows use make points immutable (nothing changes inside)\r\n\r\n// Elliptic curve multiplication of Point by scalar. Fragile.\r\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\r\n// Creates precomputation tables for fast multiplication:\r\n// - private scalar is split by fixed size windows of W bits\r\n// - every window point is collected from window's table & added to accumulator\r\n// - since windows are different, same point inside tables won't be accessed more than once per calc\r\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\r\n// - +1 window is neccessary for wNAF\r\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\r\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\r\n// windows to be in different memory locations\r\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number) {\r\n  const constTimeNegate = (condition: boolean, item: T): T => {\r\n    const neg = item.negate();\r\n    return condition ? neg : item;\r\n  };\r\n  const validateW = (W: number) => {\r\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\r\n      throw new Error(`Wrong window size=${W}, should be [1..${bits}]`);\r\n  };\r\n  const opts = (W: number) => {\r\n    validateW(W);\r\n    const windows = Math.ceil(bits / W) + 1; // +1, because\r\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\r\n    return { windows, windowSize };\r\n  };\r\n  return {\r\n    constTimeNegate,\r\n    // non-const time multiplication ladder\r\n    unsafeLadder(elm: T, n: bigint) {\r\n      let p = c.ZERO;\r\n      let d: T = elm;\r\n      while (n > _0n) {\r\n        if (n & _1n) p = p.add(d);\r\n        d = d.double();\r\n        n >>= _1n;\r\n      }\r\n      return p;\r\n    },\r\n\r\n    /**\r\n     * Creates a wNAF precomputation window. Used for caching.\r\n     * Default window size is set by `utils.precompute()` and is equal to 8.\r\n     * Number of precomputed points depends on the curve size:\r\n     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\r\n     * - ùëä is the window size\r\n     * - ùëõ is the bitlength of the curve order.\r\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\r\n     * @returns precomputed point tables flattened to a single array\r\n     */\r\n    precomputeWindow(elm: T, W: number): Group<T>[] {\r\n      const { windows, windowSize } = opts(W);\r\n      const points: T[] = [];\r\n      let p: T = elm;\r\n      let base = p;\r\n      for (let window = 0; window < windows; window++) {\r\n        base = p;\r\n        points.push(base);\r\n        // =1, because we skip zero\r\n        for (let i = 1; i < windowSize; i++) {\r\n          base = base.add(p);\r\n          points.push(base);\r\n        }\r\n        p = base.double();\r\n      }\r\n      return points;\r\n    },\r\n\r\n    /**\r\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\r\n     * @param W window size\r\n     * @param precomputes precomputed tables\r\n     * @param n scalar (we don't check here, but should be less than curve order)\r\n     * @returns real and fake (for const-time) points\r\n     */\r\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\r\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\r\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\r\n      const { windows, windowSize } = opts(W);\r\n\r\n      let p = c.ZERO;\r\n      let f = c.BASE;\r\n\r\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\r\n      const maxNumber = 2 ** W;\r\n      const shiftBy = BigInt(W);\r\n\r\n      for (let window = 0; window < windows; window++) {\r\n        const offset = window * windowSize;\r\n        // Extract W bits.\r\n        let wbits = Number(n & mask);\r\n\r\n        // Shift number by W bits.\r\n        n >>= shiftBy;\r\n\r\n        // If the bits are bigger than max size, we'll split those.\r\n        // +224 => 256 - 32\r\n        if (wbits > windowSize) {\r\n          wbits -= maxNumber;\r\n          n += _1n;\r\n        }\r\n\r\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\r\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\r\n        // there is negate now: it is possible that negated element from low value\r\n        // would be the same as high element, which will create carry into next window.\r\n        // It's not obvious how this can fail, but still worth investigating later.\r\n\r\n        // Check if we're onto Zero point.\r\n        // Add random point inside current window to f.\r\n        const offset1 = offset;\r\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\r\n        const cond1 = window % 2 !== 0;\r\n        const cond2 = wbits < 0;\r\n        if (wbits === 0) {\r\n          // The most important part for const-time getPublicKey\r\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\r\n        } else {\r\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\r\n        }\r\n      }\r\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\r\n      // Even if the variable is still unused, there are some checks which will\r\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\r\n      // At this point there is a way to F be infinity-point even if p is not,\r\n      // which makes it less const-time: around 1 bigint multiply.\r\n      return { p, f };\r\n    },\r\n\r\n    wNAFCached(P: T, n: bigint, transform: Mapper<T>): { p: T; f: T } {\r\n      const W: number = pointWindowSizes.get(P) || 1;\r\n      // Calculate precomputes on a first run, reuse them after\r\n      let comp = pointPrecomputes.get(P);\r\n      if (!comp) {\r\n        comp = this.precomputeWindow(P, W) as T[];\r\n        if (W !== 1) pointPrecomputes.set(P, transform(comp));\r\n      }\r\n      return this.wNAF(W, comp, n);\r\n    },\r\n    // We calculate precomputes for elliptic curve point multiplication\r\n    // using windowed method. This specifies window size and\r\n    // stores precomputed values. Usually only base point would be precomputed.\r\n\r\n    setWindowSize(P: T, W: number) {\r\n      validateW(W);\r\n      pointWindowSizes.set(P, W);\r\n      pointPrecomputes.delete(P);\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Pippenger algorithm for multi-scalar multiplication (MSM).\r\n * MSM is basically (Pa + Qb + Rc + ...).\r\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\r\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\r\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\r\n * @param c Curve Point constructor\r\n * @param field field over CURVE.N - important that it's not over CURVE.P\r\n * @param points array of L curve points\r\n * @param scalars array of L scalars (aka private keys / bigints)\r\n */\r\nexport function pippenger<T extends Group<T>>(\r\n  c: GroupConstructor<T>,\r\n  field: IField<bigint>,\r\n  points: T[],\r\n  scalars: bigint[]\r\n): T {\r\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\r\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\r\n  // TODO:\r\n  // - https://eprint.iacr.org/2024/750.pdf\r\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\r\n  // 0 is accepted in scalars\r\n  if (!Array.isArray(points) || !Array.isArray(scalars) || scalars.length !== points.length)\r\n    throw new Error('arrays of points and scalars must have equal length');\r\n  scalars.forEach((s, i) => {\r\n    if (!field.isValid(s)) throw new Error(`wrong scalar at index ${i}`);\r\n  });\r\n  points.forEach((p, i) => {\r\n    if (!(p instanceof (c as any))) throw new Error(`wrong point at index ${i}`);\r\n  });\r\n  const wbits = bitLen(BigInt(points.length));\r\n  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\r\n  const MASK = (1 << windowSize) - 1;\r\n  const buckets = new Array(MASK + 1).fill(c.ZERO); // +1 for zero array\r\n  const lastBits = Math.floor((field.BITS - 1) / windowSize) * windowSize;\r\n  let sum = c.ZERO;\r\n  for (let i = lastBits; i >= 0; i -= windowSize) {\r\n    buckets.fill(c.ZERO);\r\n    for (let j = 0; j < scalars.length; j++) {\r\n      const scalar = scalars[j];\r\n      const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\r\n      buckets[wbits] = buckets[wbits].add(points[j]);\r\n    }\r\n    let resI = c.ZERO; // not using this will do small speed-up, but will lose ct\r\n    // Skip first bucket, because it is zero\r\n    for (let j = buckets.length - 1, sumI = c.ZERO; j > 0; j--) {\r\n      sumI = sumI.add(buckets[j]);\r\n      resI = resI.add(sumI);\r\n    }\r\n    sum = sum.add(resI);\r\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\r\n  }\r\n  return sum as T;\r\n}\r\n\r\n// Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\r\n// Though generator can be different (Fp2 / Fp6 for BLS).\r\nexport type BasicCurve<T> = {\r\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\r\n  n: bigint; // Curve order, total count of valid points in the field\r\n  nBitLength?: number; // bit length of curve order\r\n  nByteLength?: number; // byte length of curve order\r\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\r\n  hEff?: bigint; // Number to multiply to clear cofactor\r\n  Gx: T; // base point X coordinate\r\n  Gy: T; // base point Y coordinate\r\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\r\n};\r\n\r\nexport function validateBasic<FP, T>(curve: BasicCurve<FP> & T) {\r\n  validateField(curve.Fp);\r\n  validateObject(\r\n    curve,\r\n    {\r\n      n: 'bigint',\r\n      h: 'bigint',\r\n      Gx: 'field',\r\n      Gy: 'field',\r\n    },\r\n    {\r\n      nBitLength: 'isSafeInteger',\r\n      nByteLength: 'isSafeInteger',\r\n    }\r\n  );\r\n  // Set defaults\r\n  return Object.freeze({\r\n    ...nLength(curve.n, curve.nBitLength),\r\n    ...curve,\r\n    ...{ p: curve.Fp.ORDER },\r\n  } as const);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}