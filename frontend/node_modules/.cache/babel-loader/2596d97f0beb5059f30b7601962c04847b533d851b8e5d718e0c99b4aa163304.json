{"ast":null,"code":"/* The MIT License (MIT)\r\n *\r\n * Copyright 2015-2018 Peter A. Bigot\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\n/**\r\n * Support for translating between Uint8Array instances and JavaScript\r\n * native types.\r\n *\r\n * {@link module:Layout~Layout|Layout} is the basis of a class\r\n * hierarchy that associates property names with sequences of encoded\r\n * bytes.\r\n *\r\n * Layouts are supported for these scalar (numeric) types:\r\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\r\n *   format} with {@link module:Layout.u8|8-bit}, {@link\r\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\r\n *   {@link module:Layout.u32|32-bit}, {@link\r\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\r\n *   representation ranges;\r\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\r\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\r\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\r\n *   {@link module:Layout.u40be|40-bit}, and {@link\r\n *   module:Layout.u48be|48-bit} representation ranges;\r\n * * {@link module:Layout~Int|Signed integers in little-endian\r\n *   format} with {@link module:Layout.s8|8-bit}, {@link\r\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\r\n *   {@link module:Layout.s32|32-bit}, {@link\r\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\r\n *   representation ranges;\r\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\r\n *   with {@link module:Layout.s16be|16-bit}, {@link\r\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\r\n *   {@link module:Layout.s40be|40-bit}, and {@link\r\n *   module:Layout.s48be|48-bit} representation ranges;\r\n * * 64-bit integral values that decode to an exact (if magnitude is\r\n *   less than 2^53) or nearby integral Number in {@link\r\n *   module:Layout.nu64|unsigned little-endian}, {@link\r\n *   module:Layout.nu64be|unsigned big-endian}, {@link\r\n *   module:Layout.ns64|signed little-endian}, and {@link\r\n *   module:Layout.ns64be|unsigned big-endian} encodings;\r\n * * 32-bit floating point values with {@link\r\n *   module:Layout.f32|little-endian} and {@link\r\n *   module:Layout.f32be|big-endian} representations;\r\n * * 64-bit floating point values with {@link\r\n *   module:Layout.f64|little-endian} and {@link\r\n *   module:Layout.f64be|big-endian} representations;\r\n * * {@link module:Layout.const|Constants} that take no space in the\r\n *   encoded expression.\r\n *\r\n * and for these aggregate types:\r\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\r\n *   module:Layout~Layout|Layout}, with JavaScript representation as\r\n *   an Array and constant or data-dependent {@link\r\n *   module:Layout~Sequence#count|length};\r\n * * {@link module:Layout.struct|Structure}s that aggregate a\r\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\r\n *   instances, with JavaScript representation as an Object;\r\n * * {@link module:Layout.union|Union}s that support multiple {@link\r\n *   module:Layout~VariantLayout|variant layouts} over a fixed\r\n *   (padded) or variable (not padded) span of bytes, using an\r\n *   unsigned integer at the start of the data or a separate {@link\r\n *   module:Layout.unionLayoutDiscriminator|layout element} to\r\n *   determine which layout to use when interpreting the buffer\r\n *   contents;\r\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\r\n *   of individual {@link\r\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\r\n *   16, 24, or 32-bit unsigned integer starting at the least- or\r\n *   most-significant bit;\r\n * * {@link module:Layout.cstr|C strings} of varying length;\r\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\r\n *   module:Layout~Blob#length|length} raw data.\r\n *\r\n * All {@link module:Layout~Layout|Layout} instances are immutable\r\n * after construction, to prevent internal state from becoming\r\n * inconsistent.\r\n *\r\n * @local Layout\r\n * @local ExternalLayout\r\n * @local GreedyCount\r\n * @local OffsetLayout\r\n * @local UInt\r\n * @local UIntBE\r\n * @local Int\r\n * @local IntBE\r\n * @local NearUInt64\r\n * @local NearUInt64BE\r\n * @local NearInt64\r\n * @local NearInt64BE\r\n * @local Float\r\n * @local FloatBE\r\n * @local Double\r\n * @local DoubleBE\r\n * @local Sequence\r\n * @local Structure\r\n * @local UnionDiscriminator\r\n * @local UnionLayoutDiscriminator\r\n * @local Union\r\n * @local VariantLayout\r\n * @local BitStructure\r\n * @local BitField\r\n * @local Boolean\r\n * @local Blob\r\n * @local CString\r\n * @local Constant\r\n * @local bindConstructorLayout\r\n * @module Layout\r\n * @license MIT\r\n * @author Peter A. Bigot\r\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\r\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\nconst buffer_1 = require(\"buffer\");\n/* Check if a value is a Uint8Array.\r\n *\r\n * @ignore */\nfunction checkUint8Array(b) {\n  if (!(b instanceof Uint8Array)) {\n    throw new TypeError('b must be a Uint8Array');\n  }\n}\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\r\n *\r\n * @ignore */\nfunction uint8ArrayToBuffer(b) {\n  checkUint8Array(b);\n  return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\r\n * Base class for layout objects.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support the {@link\r\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\r\n *\r\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\r\n * parameter must be an integer; a negative value signifies that the\r\n * span is {@link Layout#getSpan|value-specific}.\r\n *\r\n * @param {string} [property] - Initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @abstract\r\n */\nclass Layout {\n  constructor(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n    /** The span of the layout in bytes.\r\n     *\r\n     * Positive values are generally expected.\r\n     *\r\n     * Zero will only appear in {@link Constant}s and in {@link\r\n     * Sequence}s where the {@link Sequence#count|count} is zero.\r\n     *\r\n     * A negative value indicates that the span is value-specific, and\r\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n    /** The property name used when this layout is represented in an\r\n     * Object.\r\n     *\r\n     * Used only for layouts that {@link Layout#decode|decode} to Object\r\n     * instances.  If left undefined the span of the unnamed layout will\r\n     * be treated as padding: it will not be mutated by {@link\r\n     * Layout#encode|encode} nor represented as a property in the\r\n     * decoded Object. */\n    this.property = property;\n  }\n  /** Function to create an Object into which decoded properties will\r\n   * be written.\r\n   *\r\n   * Used only for layouts that {@link Layout#decode|decode} to Object\r\n   * instances, which means:\r\n   * * {@link Structure}\r\n   * * {@link Union}\r\n   * * {@link VariantLayout}\r\n   * * {@link BitStructure}\r\n   *\r\n   * If left undefined the JavaScript representation of these layouts\r\n   * will be Object instances.\r\n   *\r\n   * See {@link bindConstructorLayout}.\r\n   */\n  makeDestinationObject() {\n    return {};\n  }\n  /**\r\n   * Calculate the span of a specific instance of a layout.\r\n   *\r\n   * @param {Uint8Array} b - the buffer that contains an encoded instance.\r\n   *\r\n   * @param {Number} [offset] - the offset at which the encoded instance\r\n   * starts.  If absent a zero offset is inferred.\r\n   *\r\n   * @return {Number} - the number of bytes covered by the layout\r\n   * instance.  If this method is not overridden in a subclass the\r\n   * definition-time constant {@link Layout#span|span} will be\r\n   * returned.\r\n   *\r\n   * @throws {RangeError} - if the length of the value cannot be\r\n   * determined.\r\n   */\n  getSpan(b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n    return this.span;\n  }\n  /**\r\n   * Replicate the layout using a new property.\r\n   *\r\n   * This function must be used to get a structurally-equivalent layout\r\n   * with a different name since all {@link Layout} instances are\r\n   * immutable.\r\n   *\r\n   * **NOTE** This is a shallow copy.  All fields except {@link\r\n   * Layout#property|property} are strictly equal to the origin layout.\r\n   *\r\n   * @param {String} property - the value for {@link\r\n   * Layout#property|property} in the replica.\r\n   *\r\n   * @returns {Layout} - the copy with {@link Layout#property|property}\r\n   * set to `property`.\r\n   */\n  replicate(property) {\n    const rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  }\n  /**\r\n   * Create an object from layout properties and an array of values.\r\n   *\r\n   * **NOTE** This function returns `undefined` if invoked on a layout\r\n   * that does not return its value as an Object.  Objects are\r\n   * returned for things that are a {@link Structure}, which includes\r\n   * {@link VariantLayout|variant layouts} if they are structures, and\r\n   * excludes {@link Union}s.  If you want this feature for a union\r\n   * you must use {@link Union.getVariant|getVariant} to select the\r\n   * desired layout.\r\n   *\r\n   * @param {Array} values - an array of values that correspond to the\r\n   * default order for properties.  As with {@link Layout#decode|decode}\r\n   * layout elements that have no property name are skipped when\r\n   * iterating over the array values.  Only the top-level properties are\r\n   * assigned; arguments are not assigned to properties of contained\r\n   * layouts.  Any unused values are ignored.\r\n   *\r\n   * @return {(Object|undefined)}\r\n   */\n  fromArray(values) {\n    return undefined;\n  }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\r\n * be throwing an error) annotated with the property of a given layout\r\n * (such as one for which the value was unacceptable).\r\n *\r\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\r\n * Augment a class so that instances can be encoded/decoded using a\r\n * given layout.\r\n *\r\n * Calling this function couples `Class` with `layout` in several ways:\r\n *\r\n * * `Class.layout_` becomes a static member property equal to `layout`;\r\n * * `layout.boundConstructor_` becomes a static member property equal\r\n *    to `Class`;\r\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\r\n *   property of `layout` is set to a function that returns a `new\r\n *   Class()`;\r\n * * `Class.decode(b, offset)` becomes a static member function that\r\n *   delegates to {@link Layout#decode|layout.decode}.  The\r\n *   synthesized function may be captured and extended.\r\n * * `Class.prototype.encode(b, offset)` provides an instance member\r\n *   function that delegates to {@link Layout#encode|layout.encode}\r\n *   with `src` set to `this`.  The synthesized function may be\r\n *   captured and extended, but when the extension is invoked `this`\r\n *   must be explicitly bound to the instance.\r\n *\r\n * @param {class} Class - a JavaScript class with a nullary\r\n * constructor.\r\n *\r\n * @param {Layout} layout - the {@link Layout} instance used to encode\r\n * instances of `Class`.\r\n */\n// `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n  if (Object.prototype.hasOwnProperty.call(Class, 'layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n  if (!(layout && layout instanceof Layout)) {\n    throw new TypeError('layout must be a Layout');\n  }\n  if (Object.prototype.hasOwnProperty.call(layout, 'boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n  layout.makeDestinationObject = () => new Class();\n  Object.defineProperty(Class.prototype, 'encode', {\n    value(b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true\n  });\n  Object.defineProperty(Class, 'decode', {\n    value(b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true\n  });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\r\n * An object that behaves like a layout but does not consume space\r\n * within its containing layout.\r\n *\r\n * This is primarily used to obtain metadata about a member, such as a\r\n * {@link OffsetLayout} that can provide data about a {@link\r\n * Layout#getSpan|value-specific span}.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support {@link\r\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @abstract\r\n * @augments {Layout}\r\n */\nclass ExternalLayout extends Layout {\n  /**\r\n   * Return `true` iff the external layout decodes to an unsigned\r\n   * integer layout.\r\n   *\r\n   * In that case it can be used as the source of {@link\r\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\r\n   * or as {@link UnionLayoutDiscriminator#layout|external union\r\n   * discriminators}.\r\n   *\r\n   * @abstract\r\n   */\n  isCount() {\n    throw new Error('ExternalLayout is abstract');\n  }\n}\nexports.ExternalLayout = ExternalLayout;\n/**\r\n * An {@link ExternalLayout} that determines its {@link\r\n * Layout#decode|value} based on offset into and length of the buffer\r\n * on which it is invoked.\r\n *\r\n * *Factory*: {@link module:Layout.greedy|greedy}\r\n *\r\n * @param {Number} [elementSpan] - initializer for {@link\r\n * GreedyCount#elementSpan|elementSpan}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {ExternalLayout}\r\n */\nclass GreedyCount extends ExternalLayout {\n  constructor(elementSpan = 1, property) {\n    if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n    super(-1, property);\n    /** The layout for individual elements of the sequence.  The value\r\n     * must be a positive integer.  If not provided, the value will be\r\n     * 1. */\n    this.elementSpan = elementSpan;\n  }\n  /** @override */\n  isCount() {\n    return true;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    checkUint8Array(b);\n    const rem = b.length - offset;\n    return Math.floor(rem / this.elementSpan);\n  }\n  /** @override */\n  encode(src, b, offset) {\n    return 0;\n  }\n}\nexports.GreedyCount = GreedyCount;\n/**\r\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\r\n * at a fixed offset from the start of another Layout.  The offset may\r\n * be before, within, or after the base layout.\r\n *\r\n * *Factory*: {@link module:Layout.offset|offset}\r\n *\r\n * @param {Layout} layout - initializer for {@link\r\n * OffsetLayout#layout|layout}, modulo `property`.\r\n *\r\n * @param {Number} [offset] - Initializes {@link\r\n * OffsetLayout#offset|offset}.  Defaults to zero.\r\n *\r\n * @param {string} [property] - Optional new property name for a\r\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\r\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\r\n * unchanged.\r\n *\r\n * @augments {Layout}\r\n */\nclass OffsetLayout extends ExternalLayout {\n  constructor(layout, offset = 0, property) {\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n    if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n    super(layout.span, property || layout.property);\n    /** The subordinated layout. */\n    this.layout = layout;\n    /** The location of {@link OffsetLayout#layout} relative to the\r\n     * start of another layout.\r\n     *\r\n     * The value may be positive or negative, but an error will thrown\r\n     * if at the point of use it goes outside the span of the Uint8Array\r\n     * being accessed.  */\n    this.offset = offset;\n  }\n  /** @override */\n  isCount() {\n    return this.layout instanceof UInt || this.layout instanceof UIntBE;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return this.layout.decode(b, offset + this.offset);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    return this.layout.encode(src, b, offset + this.offset);\n  }\n}\nexports.OffsetLayout = OffsetLayout;\n/**\r\n * Represent an unsigned integer in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.u8|u8}, {@link\r\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\r\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\r\n *  module:Layout.u48|u48}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass UInt extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\nexports.UInt = UInt;\n/**\r\n * Represent an unsigned integer in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\r\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\r\n * {@link module:Layout.u32be|u32be}, {@link\r\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass UIntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\nexports.UIntBE = UIntBE;\n/**\r\n * Represent a signed integer in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.s8|s8}, {@link\r\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\r\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\r\n *  module:Layout.s48|s48}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass Int extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\nexports.Int = Int;\n/**\r\n * Represent a signed integer in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\r\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\r\n * {@link module:Layout.s32be|s32be}, {@link\r\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\r\n *\r\n * @param {Number} span - initializer for {@link Layout#span|span}.\r\n * The parameter can range from 1 through 6.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass IntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\nexports.IntBE = IntBE;\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\r\n * non-negative. */\nfunction divmodInt64(src) {\n  const hi32 = Math.floor(src / V2E32);\n  const lo32 = src - hi32 * V2E32;\n  return {\n    hi32,\n    lo32\n  };\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n/**\r\n * Represent an unsigned 64-bit integer in little-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.nu64|nu64}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\nclass NearUInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const buffer = uint8ArrayToBuffer(b);\n    const lo32 = buffer.readUInt32LE(offset);\n    const hi32 = buffer.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    const split = divmodInt64(src);\n    const buffer = uint8ArrayToBuffer(b);\n    buffer.writeUInt32LE(split.lo32, offset);\n    buffer.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\nexports.NearUInt64 = NearUInt64;\n/**\r\n * Represent an unsigned 64-bit integer in big-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.nu64be|nu64be}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\nclass NearUInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const buffer = uint8ArrayToBuffer(b);\n    const hi32 = buffer.readUInt32BE(offset);\n    const lo32 = buffer.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    const split = divmodInt64(src);\n    const buffer = uint8ArrayToBuffer(b);\n    buffer.writeUInt32BE(split.hi32, offset);\n    buffer.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\nexports.NearUInt64BE = NearUInt64BE;\n/**\r\n * Represent a signed 64-bit integer in little-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.ns64|ns64}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\nclass NearInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const buffer = uint8ArrayToBuffer(b);\n    const lo32 = buffer.readUInt32LE(offset);\n    const hi32 = buffer.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    const split = divmodInt64(src);\n    const buffer = uint8ArrayToBuffer(b);\n    buffer.writeUInt32LE(split.lo32, offset);\n    buffer.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\nexports.NearInt64 = NearInt64;\n/**\r\n * Represent a signed 64-bit integer in big-endian format when\r\n * encoded and as a near integral JavaScript Number when decoded.\r\n *\r\n * *Factory*: {@link module:Layout.ns64be|ns64be}\r\n *\r\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\r\n * the exact value of the encoded representation.\r\n *\r\n * @augments {Layout}\r\n */\nclass NearInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const buffer = uint8ArrayToBuffer(b);\n    const hi32 = buffer.readInt32BE(offset);\n    const lo32 = buffer.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    const split = divmodInt64(src);\n    const buffer = uint8ArrayToBuffer(b);\n    buffer.writeInt32BE(split.hi32, offset);\n    buffer.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\nexports.NearInt64BE = NearInt64BE;\n/**\r\n * Represent a 32-bit floating point number in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f32|f32}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass Float extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readFloatLE(offset);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n    return 4;\n  }\n}\nexports.Float = Float;\n/**\r\n * Represent a 32-bit floating point number in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f32be|f32be}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass FloatBE extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readFloatBE(offset);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n    return 4;\n  }\n}\nexports.FloatBE = FloatBE;\n/**\r\n * Represent a 64-bit floating point number in little-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f64|f64}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass Double extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readDoubleLE(offset);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n    return 8;\n  }\n}\nexports.Double = Double;\n/**\r\n * Represent a 64-bit floating point number in big-endian format.\r\n *\r\n * *Factory*: {@link module:Layout.f64be|f64be}\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass DoubleBE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readDoubleBE(offset);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n    return 8;\n  }\n}\nexports.DoubleBE = DoubleBE;\n/**\r\n * Represent a contiguous sequence of a specific layout as an Array.\r\n *\r\n * *Factory*: {@link module:Layout.seq|seq}\r\n *\r\n * @param {Layout} elementLayout - initializer for {@link\r\n * Sequence#elementLayout|elementLayout}.\r\n *\r\n * @param {(Number|ExternalLayout)} count - initializer for {@link\r\n * Sequence#count|count}.  The parameter must be either a positive\r\n * integer or an instance of {@link ExternalLayout}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass Sequence extends Layout {\n  constructor(elementLayout, count, property) {\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n    if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n      throw new TypeError('count must be non-negative integer ' + 'or an unsigned integer ExternalLayout');\n    }\n    let span = -1;\n    if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n      span = count * elementLayout.span;\n    }\n    super(span, property);\n    /** The layout for individual elements of the sequence. */\n    this.elementLayout = elementLayout;\n    /** The number of elements in the sequence.\r\n     *\r\n     * This will be either a non-negative integer or an instance of\r\n     * {@link ExternalLayout} for which {@link\r\n     * ExternalLayout#isCount|isCount()} is `true`. */\n    this.count = count;\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    let span = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    if (0 < this.elementLayout.span) {\n      span = count * this.elementLayout.span;\n    } else {\n      let idx = 0;\n      while (idx < count) {\n        span += this.elementLayout.getSpan(b, offset + span);\n        ++idx;\n      }\n    }\n    return span;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const rv = [];\n    let i = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    while (i < count) {\n      rv.push(this.elementLayout.decode(b, offset));\n      offset += this.elementLayout.getSpan(b, offset);\n      i += 1;\n    }\n    return rv;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\r\n   *\r\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\r\n   * the unused space in the buffer is left unchanged.  If `src` is\r\n   * longer than {@link Sequence#count|count} the unneeded elements are\r\n   * ignored.\r\n   *\r\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\r\n   * ExternalLayout} then the length of `src` will be encoded as the\r\n   * count after `src` is encoded. */\n  encode(src, b, offset = 0) {\n    const elo = this.elementLayout;\n    const span = src.reduce((span, v) => {\n      return span + elo.encode(v, b, offset + span);\n    }, 0);\n    if (this.count instanceof ExternalLayout) {\n      this.count.encode(src.length, b, offset);\n    }\n    return span;\n  }\n}\nexports.Sequence = Sequence;\n/**\r\n * Represent a contiguous sequence of arbitrary layout elements as an\r\n * Object.\r\n *\r\n * *Factory*: {@link module:Layout.struct|struct}\r\n *\r\n * **NOTE** The {@link Layout#span|span} of the structure is variable\r\n * if any layout in {@link Structure#fields|fields} has a variable\r\n * span.  When {@link Layout#encode|encoding} we must have a value for\r\n * all variable-length fields, or we wouldn't be able to figure out\r\n * how much space to use for storage.  We can only identify the value\r\n * for a field when it has a {@link Layout#property|property}.  As\r\n * such, although a structure may contain both unnamed fields and\r\n * variable-length fields, it cannot contain an unnamed\r\n * variable-length field.\r\n *\r\n * @param {Layout[]} fields - initializer for {@link\r\n * Structure#fields|fields}.  An error is raised if this contains a\r\n * variable-length field for which a {@link Layout#property|property}\r\n * is not defined.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @param {Boolean} [decodePrefixes] - initializer for {@link\r\n * Structure#decodePrefixes|property}.\r\n *\r\n * @throws {Error} - if `fields` contains an unnamed variable-length\r\n * layout.\r\n *\r\n * @augments {Layout}\r\n */\nclass Structure extends Layout {\n  constructor(fields, property, decodePrefixes) {\n    if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if ('boolean' === typeof property && undefined === decodePrefixes) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n    /* Verify absence of unnamed variable-length fields. */\n    for (const fd of fields) {\n      if (0 > fd.span && undefined === fd.property) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n    let span = -1;\n    try {\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n    } catch (e) {\n      // ignore error\n    }\n    super(span, property);\n    /** The sequence of {@link Layout} values that comprise the\r\n     * structure.\r\n     *\r\n     * The individual elements need not be the same type, and may be\r\n     * either scalar or aggregate layouts.  If a member layout leaves\r\n     * its {@link Layout#property|property} undefined the\r\n     * corresponding region of the buffer associated with the element\r\n     * will not be mutated.\r\n     *\r\n     * @type {Layout[]} */\n    this.fields = fields;\n    /** Control behavior of {@link Layout#decode|decode()} given short\r\n     * buffers.\r\n     *\r\n     * In some situations a structure many be extended with additional\r\n     * fields over time, with older installations providing only a\r\n     * prefix of the full structure.  If this property is `true`\r\n     * decoding will accept those buffers and leave subsequent fields\r\n     * undefined, as long as the buffer ends at a field boundary.\r\n     * Defaults to `false`. */\n    this.decodePrefixes = !!decodePrefixes;\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    let span = 0;\n    try {\n      span = this.fields.reduce((span, fd) => {\n        const fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n    return span;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    checkUint8Array(b);\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n      offset += fd.getSpan(b, offset);\n      if (this.decodePrefixes && b.length === offset) {\n        break;\n      }\n    }\n    return dest;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\r\n   *\r\n   * If `src` is missing a property for a member with a defined {@link\r\n   * Layout#property|property} the corresponding region of the buffer is\r\n   * left unmodified. */\n  encode(src, b, offset = 0) {\n    const firstOffset = offset;\n    let lastOffset = 0;\n    let lastWrote = 0;\n    for (const fd of this.fields) {\n      let span = fd.span;\n      lastWrote = 0 < span ? span : 0;\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\r\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\r\n     * item may have had a dynamic length and we don't want to include\r\n     * the padding between it and the end of the space reserved for\r\n     * it. */\n    return lastOffset + lastWrote - firstOffset;\n  }\n  /** @override */\n  fromArray(values) {\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property && 0 < values.length) {\n        dest[fd.property] = values.shift();\n      }\n    }\n    return dest;\n  }\n  /**\r\n   * Get access to the layout of a given property.\r\n   *\r\n   * @param {String} property - the structure member of interest.\r\n   *\r\n   * @return {Layout} - the layout associated with `property`, or\r\n   * undefined if there is no such property.\r\n   */\n  layoutFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n    return undefined;\n  }\n  /**\r\n   * Get the offset of a structure member.\r\n   *\r\n   * @param {String} property - the structure member of interest.\r\n   *\r\n   * @return {Number} - the offset in bytes to the start of `property`\r\n   * within the structure, or undefined if `property` is not a field\r\n   * within the structure.  If the property is a member but follows a\r\n   * variable-length structure member a negative number will be\r\n   * returned.\r\n   */\n  offsetOf(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    let offset = 0;\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return offset;\n      }\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n    return undefined;\n  }\n}\nexports.Structure = Structure;\n/**\r\n * An object that can provide a {@link\r\n * Union#discriminator|discriminator} API for {@link Union}.\r\n *\r\n * **NOTE** This is an abstract base class; you can create instances\r\n * if it amuses you, but they won't support the {@link\r\n * UnionDiscriminator#encode|encode} or {@link\r\n * UnionDiscriminator#decode|decode} functions.\r\n *\r\n * @param {string} [property] - Default for {@link\r\n * UnionDiscriminator#property|property}.\r\n *\r\n * @abstract\r\n */\nclass UnionDiscriminator {\n  constructor(property) {\n    /** The {@link Layout#property|property} to be used when the\r\n     * discriminator is referenced in isolation (generally when {@link\r\n     * Union#decode|Union decode} cannot delegate to a specific\r\n     * variant). */\n    this.property = property;\n  }\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\r\n   *\r\n   * The implementation of this method need not reference the buffer if\r\n   * variant information is available through other means. */\n  decode(b, offset) {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\r\n   *\r\n   * The implementation of this method need not store the value if\r\n   * variant information is maintained through other means. */\n  encode(src, b, offset) {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n}\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\r\n * An object that can provide a {@link\r\n * UnionDiscriminator|discriminator API} for {@link Union} using an\r\n * unsigned integral {@link Layout} instance located either inside or\r\n * outside the union.\r\n *\r\n * @param {ExternalLayout} layout - initializes {@link\r\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\r\n * ExternalLayout#isCount|isCount()}.\r\n *\r\n * @param {string} [property] - Default for {@link\r\n * UnionDiscriminator#property|property}, superseding the property\r\n * from `layout`, but defaulting to `variant` if neither `property`\r\n * nor layout provide a property name.\r\n *\r\n * @augments {UnionDiscriminator}\r\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n  constructor(layout, property) {\n    if (!(layout instanceof ExternalLayout && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n    super(property || layout.property || 'variant');\n    /** The {@link ExternalLayout} used to access the discriminator\r\n     * value. */\n    this.layout = layout;\n  }\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  decode(b, offset) {\n    return this.layout.decode(b, offset);\n  }\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  encode(src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  }\n}\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\r\n * Represent any number of span-compatible layouts.\r\n *\r\n * *Factory*: {@link module:Layout.union|union}\r\n *\r\n * If the union has a {@link Union#defaultLayout|default layout} that\r\n * layout must have a non-negative {@link Layout#span|span}.  The span\r\n * of a fixed-span union includes its {@link\r\n * Union#discriminator|discriminator} if the variant is a {@link\r\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\r\n * of its {@link Union#defaultLayout|default layout}.\r\n *\r\n * If the union does not have a default layout then the encoded span\r\n * of the union depends on the encoded span of its variant (which may\r\n * be fixed or variable).\r\n *\r\n * {@link VariantLayout#layout|Variant layout}s are added through\r\n * {@link Union#addVariant|addVariant}.  If the union has a default\r\n * layout, the span of the {@link VariantLayout#layout|layout\r\n * contained by the variant} must not exceed the span of the {@link\r\n * Union#defaultLayout|default layout} (minus the span of a {@link\r\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\r\n * span of the variant will equal the span of the union itself.\r\n *\r\n * The variant for a buffer can only be identified from the {@link\r\n * Union#discriminator|discriminator} {@link\r\n * UnionDiscriminator#property|property} (in the case of the {@link\r\n * Union#defaultLayout|default layout}), or by using {@link\r\n * Union#getVariant|getVariant} and examining the resulting {@link\r\n * VariantLayout} instance.\r\n *\r\n * A variant compatible with a JavaScript object can be identified\r\n * using {@link Union#getSourceVariant|getSourceVariant}.\r\n *\r\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\r\n * identify the layout used to interpret the union contents.  The\r\n * parameter must be an instance of {@link UnionDiscriminator}, an\r\n * {@link ExternalLayout} that satisfies {@link\r\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\r\n * UIntBE}).  When a non-external layout element is passed the layout\r\n * appears at the start of the union.  In all cases the (synthesized)\r\n * {@link UnionDiscriminator} instance is recorded as {@link\r\n * Union#discriminator|discriminator}.\r\n *\r\n * @param {(Layout|null)} defaultLayout - initializer for {@link\r\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\r\n * If `null` there is no default layout: the union has data-dependent\r\n * length and attempts to decode or encode unrecognized variants will\r\n * throw an exception.  A {@link Layout} instance must have a\r\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\r\n * Layout#property|property} the {@link\r\n * Union#defaultLayout|defaultLayout} will be a {@link\r\n * Layout#replicate|replica} with property `content`.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass Union extends Layout {\n  constructor(discr, defaultLayout, property) {\n    let discriminator;\n    if (discr instanceof UInt || discr instanceof UIntBE) {\n      discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if (discr instanceof ExternalLayout && discr.isCount()) {\n      discriminator = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator ' + 'or an unsigned integer layout');\n    } else {\n      discriminator = discr;\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n    /* The union span can be estimated only if there's a default\r\n     * layout.  The union spans its default layout, plus any prefix\r\n     * variant layout.  By construction both layouts, if present, have\r\n     * non-negative span. */\n    let span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {\n        span += discriminator.layout.span;\n      }\n    }\n    super(span, property);\n    /** The interface for the discriminator value in isolation.\r\n     *\r\n     * This a {@link UnionDiscriminator} either passed to the\r\n     * constructor or synthesized from the `discr` constructor\r\n     * argument.  {@link\r\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\r\n     * `true` iff the `discr` parameter was a non-offset {@link\r\n     * Layout} instance. */\n    this.discriminator = discriminator;\n    /** `true` if the {@link Union#discriminator|discriminator} is the\r\n     * first field in the union.\r\n     *\r\n     * If `false` the discriminator is obtained from somewhere\r\n     * else. */\n    this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;\n    /** The layout for non-discriminator content when the value of the\r\n     * discriminator is not recognized.\r\n     *\r\n     * This is the value passed to the constructor.  It is\r\n     * structurally equivalent to the second component of {@link\r\n     * Union#layout|layout} but may have a different property\r\n     * name. */\n    this.defaultLayout = defaultLayout;\n    /** A registry of allowed variants.\r\n     *\r\n     * The keys are unsigned integers which should be compatible with\r\n     * {@link Union.discriminator|discriminator}.  The property value\r\n     * is the corresponding {@link VariantLayout} instances assigned\r\n     * to this union by {@link Union#addVariant|addVariant}.\r\n     *\r\n     * **NOTE** The registry remains mutable so that variants can be\r\n     * {@link Union#addVariant|added} at any time.  Users should not\r\n     * manipulate the content of this property. */\n    this.registry = {};\n    /* Private variable used when invoking getSourceVariant */\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n    /** Function to infer the variant selected by a source object.\r\n     *\r\n     * Defaults to {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\r\n     * be overridden using {@link\r\n     * Union#configGetSourceVariant|configGetSourceVariant}.\r\n     *\r\n     * @param {Object} src - as with {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\r\n     *\r\n     * @returns {(undefined|VariantLayout)} The default variant\r\n     * (`undefined`) or first registered variant that uses a property\r\n     * available in `src`. */\n    this.getSourceVariant = function (src) {\n      return boundGetSourceVariant(src);\n    };\n    /** Function to override the implementation of {@link\r\n     * Union#getSourceVariant|getSourceVariant}.\r\n     *\r\n     * Use this if the desired variant cannot be identified using the\r\n     * algorithm of {@link\r\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\r\n     *\r\n     * **NOTE** The provided function will be invoked bound to this\r\n     * Union instance, providing local access to {@link\r\n     * Union#registry|registry}.\r\n     *\r\n     * @param {Function} gsv - a function that follows the API of\r\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    this.configGetSourceVariant = function (gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    /* Default layouts always have non-negative span, so we don't have\r\n     * one and we have to recognize the variant which will in turn\r\n     * determine the span. */\n    const vlo = this.getVariant(b, offset);\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n    return vlo.getSpan(b, offset);\n  }\n  /**\r\n   * Method to infer a registered Union variant compatible with `src`.\r\n   *\r\n   * The first satisfied rule in the following sequence defines the\r\n   * return value:\r\n   * * If `src` has properties matching the Union discriminator and\r\n   *   the default layout, `undefined` is returned regardless of the\r\n   *   value of the discriminator property (this ensures the default\r\n   *   layout will be used);\r\n   * * If `src` has a property matching the Union discriminator, the\r\n   *   value of the discriminator identifies a registered variant, and\r\n   *   either (a) the variant has no layout, or (b) `src` has the\r\n   *   variant's property, then the variant is returned (because the\r\n   *   source satisfies the constraints of the variant it identifies);\r\n   * * If `src` does not have a property matching the Union\r\n   *   discriminator, but does have a property matching a registered\r\n   *   variant, then the variant is returned (because the source\r\n   *   matches a variant without an explicit conflict);\r\n   * * An error is thrown (because we either can't identify a variant,\r\n   *   or we were explicitly told the variant but can't satisfy it).\r\n   *\r\n   * @param {Object} src - an object presumed to be compatible with\r\n   * the content of the Union.\r\n   *\r\n   * @return {(undefined|VariantLayout)} - as described above.\r\n   *\r\n   * @throws {Error} - if `src` cannot be associated with a default or\r\n   * registered variant.\r\n   */\n  defaultGetSourceVariant(src) {\n    if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n      if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n        return undefined;\n      }\n      const vlo = this.registry[src[this.discriminator.property]];\n      if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (const tag in this.registry) {\n        const vlo = this.registry[tag];\n        if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n    throw new Error('unable to infer src variant');\n  }\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\r\n   *\r\n   * If the variant is {@link Union#addVariant|registered} the return\r\n   * value is an instance of that variant, with no explicit\r\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\r\n   * layout} is used to decode the content. */\n  decode(b, offset = 0) {\n    let dest;\n    const dlo = this.discriminator;\n    const discr = dlo.decode(b, offset);\n    const clo = this.registry[discr];\n    if (undefined === clo) {\n      const defaultLayout = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      // defaultLayout.property can be undefined, but this is allowed by buffer-layout\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n    return dest;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\r\n   *\r\n   * This API assumes the `src` object is consistent with the union's\r\n   * {@link Union#defaultLayout|default layout}.  To encode variants\r\n   * use the appropriate variant-specific {@link VariantLayout#encode}\r\n   * method. */\n  encode(src, b, offset = 0) {\n    const vlo = this.getSourceVariant(src);\n    if (undefined === vlo) {\n      const dlo = this.discriminator;\n      // this.defaultLayout is not undefined when vlo is undefined\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const clo = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dlo.encode(src[dlo.property], b, offset);\n      // clo.property is not undefined when vlo is undefined\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n    }\n    return vlo.encode(src, b, offset);\n  }\n  /** Register a new variant structure within a union.  The newly\r\n   * created variant is returned.\r\n   *\r\n   * @param {Number} variant - initializer for {@link\r\n   * VariantLayout#variant|variant}.\r\n   *\r\n   * @param {Layout} layout - initializer for {@link\r\n   * VariantLayout#layout|layout}.\r\n   *\r\n   * @param {String} property - initializer for {@link\r\n   * Layout#property|property}.\r\n   *\r\n   * @return {VariantLayout} */\n  addVariant(variant, layout, property) {\n    const rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  }\n  /**\r\n   * Get the layout associated with a registered variant.\r\n   *\r\n   * If `vb` does not produce a registered variant the function returns\r\n   * `undefined`.\r\n   *\r\n   * @param {(Number|Uint8Array)} vb - either the variant number, or a\r\n   * buffer from which the discriminator is to be read.\r\n   *\r\n   * @param {Number} offset - offset into `vb` for the start of the\r\n   * union.  Used only when `vb` is an instance of {Uint8Array}.\r\n   *\r\n   * @return {({VariantLayout}|undefined)}\r\n   */\n  getVariant(vb, offset = 0) {\n    let variant;\n    if (vb instanceof Uint8Array) {\n      variant = this.discriminator.decode(vb, offset);\n    } else {\n      variant = vb;\n    }\n    return this.registry[variant];\n  }\n}\nexports.Union = Union;\n/**\r\n * Represent a specific variant within a containing union.\r\n *\r\n * **NOTE** The {@link Layout#span|span} of the variant may include\r\n * the span of the {@link Union#discriminator|discriminator} used to\r\n * identify it, but values read and written using the variant strictly\r\n * conform to the content of {@link VariantLayout#layout|layout}.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.  Use\r\n * the union {@link Union#addVariant|addVariant} helper method.\r\n *\r\n * @param {Union} union - initializer for {@link\r\n * VariantLayout#union|union}.\r\n *\r\n * @param {Number} variant - initializer for {@link\r\n * VariantLayout#variant|variant}.\r\n *\r\n * @param {Layout} [layout] - initializer for {@link\r\n * VariantLayout#layout|layout}.  If absent the variant carries no\r\n * data.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.  Unlike many other layouts, variant\r\n * layouts normally include a property name so they can be identified\r\n * within their containing {@link Union}.  The property identifier may\r\n * be absent only if `layout` is is absent.\r\n *\r\n * @augments {Layout}\r\n */\nclass VariantLayout extends Layout {\n  constructor(union, variant, layout, property) {\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if (!Number.isInteger(variant) || 0 > variant) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if ('string' === typeof layout && undefined === property) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    let span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if (0 <= span && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    super(span, property);\n    /** The {@link Union} to which this variant belongs. */\n    this.union = union;\n    /** The unsigned integral value identifying this variant within\r\n     * the {@link Union#discriminator|discriminator} of the containing\r\n     * union. */\n    this.variant = variant;\n    /** The {@link Layout} to be used when reading/writing the\r\n     * non-discriminator part of the {@link\r\n     * VariantLayout#union|union}.  If `null` the variant carries no\r\n     * data. */\n    this.layout = layout || null;\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\r\n       * variable. */\n      return this.span;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n    let span = 0;\n    if (this.layout) {\n      span = this.layout.getSpan(b, offset + contentOffset);\n    }\n    return contentOffset + span;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const dest = this.makeDestinationObject();\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout) {\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\n    } else if (this.property) {\n      dest[this.property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n    return dest;\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {\n      throw new TypeError('variant lacks property ' + this.property);\n    }\n    this.union.discriminator.encode(this.variant, b, offset);\n    let span = contentOffset;\n    if (this.layout) {\n      this.layout.encode(src[this.property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n      if (0 <= this.union.span && span > this.union.span) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n    return span;\n  }\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\r\n   * VariantLayout#layout|layout}. */\n  fromArray(values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n    return undefined;\n  }\n}\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\r\n * signed 32-bit values in 2's complement form, meaning any integer\r\n * with bit 31 set is going to look negative.  For right shifts that's\r\n * not a problem, because `>>>` is a logical shift, but for every\r\n * other bitwise operator we have to compensate for possible negative\r\n * results. */\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n  return v;\n}\n/**\r\n * Contain a sequence of bit fields as an unsigned integer.\r\n *\r\n * *Factory*: {@link module:Layout.bits|bits}\r\n *\r\n * This is a container element; within it there are {@link BitField}\r\n * instances that provide the extracted properties.  The container\r\n * simply defines the aggregate representation and its bit ordering.\r\n * The representation is an object containing properties with numeric\r\n * or {@link Boolean} values.\r\n *\r\n * {@link BitField}s are added with the {@link\r\n * BitStructure#addField|addField} and {@link\r\n * BitStructure#addBoolean|addBoolean} methods.\r\n\r\n * @param {Layout} word - initializer for {@link\r\n * BitStructure#word|word}.  The parameter must be an instance of\r\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\r\n *\r\n * @param {bool} [msb] - `true` if the bit numbering starts at the\r\n * most significant bit of the containing word; `false` (default) if\r\n * it starts at the least significant bit of the containing word.  If\r\n * the parameter at this position is a string and `property` is\r\n * `undefined` the value of this argument will instead be used as the\r\n * value of `property`.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass BitStructure extends Layout {\n  constructor(word, msb, property) {\n    if (!(word instanceof UInt || word instanceof UIntBE)) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n    if ('string' === typeof msb && undefined === property) {\n      property = msb;\n      msb = false;\n    }\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n    super(word.span, property);\n    /** The layout used for the packed value.  {@link BitField}\r\n     * instances are packed sequentially depending on {@link\r\n     * BitStructure#msb|msb}. */\n    this.word = word;\n    /** Whether the bit sequences are packed starting at the most\r\n     * significant bit growing down (`true`), or the least significant\r\n     * bit growing up (`false`).\r\n     *\r\n     * **NOTE** Regardless of this value, the least significant bit of\r\n     * any {@link BitField} value is the least significant bit of the\r\n     * corresponding section of the packed value. */\n    this.msb = !!msb;\n    /** The sequence of {@link BitField} layouts that comprise the\r\n     * packed structure.\r\n     *\r\n     * **NOTE** The array remains mutable to allow fields to be {@link\r\n     * BitStructure#addField|added} after construction.  Users should\r\n     * not manipulate the content of this property.*/\n    this.fields = [];\n    /* Storage for the value.  Capture a variable instead of using an\r\n     * instance property because we don't want anything to change the\r\n     * value without going through the mutator. */\n    let value = 0;\n    this._packedSetValue = function (v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n    this._packedGetValue = function () {\n      return value;\n    };\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const dest = this.makeDestinationObject();\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b);\n      }\n    }\n    return dest;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\r\n   *\r\n   * If `src` is missing a property for a member with a defined {@link\r\n   * Layout#property|property} the corresponding region of the packed\r\n   * value is left unmodified.  Unused bits are also left unmodified. */\n  encode(src, b, offset = 0) {\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          fd.encode(fv);\n        }\n      }\n    }\n    return this.word.encode(this._packedGetValue(), b, offset);\n  }\n  /** Register a new bitfield with a containing bit structure.  The\r\n   * resulting bitfield is returned.\r\n   *\r\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\r\n   *\r\n   * @param {string} property - initializer for {@link\r\n   * Layout#property|property}.\r\n   *\r\n   * @return {BitField} */\n  addField(bits, property) {\n    const bf = new BitField(this, bits, property);\n    this.fields.push(bf);\n    return bf;\n  }\n  /** As with {@link BitStructure#addField|addField} for single-bit\r\n   * fields with `boolean` value representation.\r\n   *\r\n   * @param {string} property - initializer for {@link\r\n   * Layout#property|property}.\r\n   *\r\n   * @return {Boolean} */\n  // `Boolean` conflicts with the native primitive type\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  addBoolean(property) {\n    // This is my Boolean, not the Javascript one.\n    const bf = new Boolean(this, property);\n    this.fields.push(bf);\n    return bf;\n  }\n  /**\r\n   * Get access to the bit field for a given property.\r\n   *\r\n   * @param {String} property - the bit field of interest.\r\n   *\r\n   * @return {BitField} - the field associated with `property`, or\r\n   * undefined if there is no such property.\r\n   */\n  fieldFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n    return undefined;\n  }\n}\nexports.BitStructure = BitStructure;\n/**\r\n * Represent a sequence of bits within a {@link BitStructure}.\r\n *\r\n * All bit field values are represented as unsigned integers.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.\r\n * Use the container {@link BitStructure#addField|addField} helper\r\n * method.\r\n *\r\n * **NOTE** BitField instances are not instances of {@link Layout}\r\n * since {@link Layout#span|span} measures 8-bit units.\r\n *\r\n * @param {BitStructure} container - initializer for {@link\r\n * BitField#container|container}.\r\n *\r\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n */\nclass BitField {\n  constructor(container, bits, property) {\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n    if (!Number.isInteger(bits) || 0 >= bits) {\n      throw new TypeError('bits must be positive integer');\n    }\n    const totalBits = 8 * container.span;\n    const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n    if (bits + usedBits > totalBits) {\n      throw new Error('bits too long for span remainder (' + (totalBits - usedBits) + ' of ' + totalBits + ' remain)');\n    }\n    /** The {@link BitStructure} instance to which this bit field\r\n     * belongs. */\n    this.container = container;\n    /** The span of this value in bits. */\n    this.bits = bits;\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\r\n     * that fit within the field.\r\n     *\r\n     * That is, it masks a value that has not yet been shifted into\r\n     * position within its containing packed integer. */\n    this.valueMask = (1 << bits) - 1;\n    if (32 === bits) {\n      // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n    /** The offset of the value within the containing packed unsigned\r\n     * integer.  The least significant bit of the packed value is at\r\n     * offset zero, regardless of bit ordering used. */\n    this.start = usedBits;\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n    /** A mask of {@link BitField#bits|bits} isolating the field value\r\n     * within the containing packed unsigned integer. */\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n    /** The property name used when this bitfield is represented in an\r\n     * Object.\r\n     *\r\n     * Intended to be functionally equivalent to {@link\r\n     * Layout#property}.\r\n     *\r\n     * If left undefined the corresponding span of bits will be\r\n     * treated as padding: it will not be mutated by {@link\r\n     * Layout#encode|encode} nor represented as a property in the\r\n     * decoded Object. */\n    this.property = property;\n  }\n  /** Store a value into the corresponding subsequence of the containing\r\n   * bit field. */\n  decode(b, offset) {\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(word & this.wordMask);\n    const value = wordValue >>> this.start;\n    return value;\n  }\n  /** Store a value into the corresponding subsequence of the containing\r\n   * bit field.\r\n   *\r\n   * **NOTE** This is not a specialization of {@link\r\n   * Layout#encode|Layout.encode} and there is no return value. */\n  encode(value) {\n    if ('number' !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n      throw new TypeError(nameWithProperty('BitField.encode', this) + ' value must be integer not exceeding ' + this.valueMask);\n    }\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(value << this.start);\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n  }\n}\nexports.BitField = BitField;\n/**\r\n * Represent a single bit within a {@link BitStructure} as a\r\n * JavaScript boolean.\r\n *\r\n * **NOTE** User code should not invoke this constructor directly.\r\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\r\n * method.\r\n *\r\n * @param {BitStructure} container - initializer for {@link\r\n * BitField#container|container}.\r\n *\r\n * @param {string} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {BitField}\r\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n  constructor(container, property) {\n    super(container, 1, property);\n  }\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\r\n   *\r\n   * @returns {boolean} */\n  decode(b, offset) {\n    return !!super.decode(b, offset);\n  }\n  /** @override */\n  encode(value) {\n    if ('boolean' === typeof value) {\n      // BitField requires integer values\n      value = +value;\n    }\n    super.encode(value);\n  }\n}\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */\n/**\r\n * Contain a fixed-length block of arbitrary data, represented as a\r\n * Uint8Array.\r\n *\r\n * *Factory*: {@link module:Layout.blob|blob}\r\n *\r\n * @param {(Number|ExternalLayout)} length - initializes {@link\r\n * Blob#length|length}.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass Blob extends Layout {\n  constructor(length, property) {\n    if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n      throw new TypeError('length must be positive integer ' + 'or an unsigned integer ExternalLayout');\n    }\n    let span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    super(span, property);\n    /** The number of bytes in the blob.\r\n     *\r\n     * This may be a non-negative integer, or an instance of {@link\r\n     * ExternalLayout} that satisfies {@link\r\n     * ExternalLayout#isCount|isCount()}. */\n    this.length = length;\n  }\n  /** @override */\n  getSpan(b, offset) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return span;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return uint8ArrayToBuffer(b).slice(offset, offset + span);\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\r\n   *\r\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\r\n   * ExternalLayout} then the length of `src` will be encoded as the\r\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    let span = this.length;\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n    if (!(src instanceof Uint8Array && span === src.length)) {\n      throw new TypeError(nameWithProperty('Blob.encode', this) + ' requires (length ' + span + ') Uint8Array as src');\n    }\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Uint8Array');\n    }\n    const srcBuffer = uint8ArrayToBuffer(src);\n    uint8ArrayToBuffer(b).write(srcBuffer.toString('hex'), offset, span, 'hex');\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n    return span;\n  }\n}\nexports.Blob = Blob;\n/**\r\n * Contain a `NUL`-terminated UTF8 string.\r\n *\r\n * *Factory*: {@link module:Layout.cstr|cstr}\r\n *\r\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\r\n * not be correctly decoded by this layout.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass CString extends Layout {\n  constructor(property) {\n    super(-1, property);\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    checkUint8Array(b);\n    let idx = offset;\n    while (idx < b.length && 0 !== b[idx]) {\n      idx += 1;\n    }\n    return 1 + idx - offset;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const span = this.getSpan(b, offset);\n    return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString('utf-8');\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    /* Must force this to a string, lest it be a number and the\r\n     * \"utf8-encoding\" below actually allocate a buffer of length\r\n     * src */\n    if ('string' !== typeof src) {\n      src = String(src);\n    }\n    const srcb = buffer_1.Buffer.from(src, 'utf8');\n    const span = srcb.length;\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    const buffer = uint8ArrayToBuffer(b);\n    srcb.copy(buffer, offset);\n    buffer[offset + span] = 0;\n    return span + 1;\n  }\n}\nexports.CString = CString;\n/**\r\n * Contain a UTF8 string with implicit length.\r\n *\r\n * *Factory*: {@link module:Layout.utf8|utf8}\r\n *\r\n * **NOTE** Because the length is implicit in the size of the buffer\r\n * this layout should be used only in isolation, or in a situation\r\n * where the length can be expressed by operating on a slice of the\r\n * containing buffer.\r\n *\r\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\r\n * string content.  If not provided there is no bound on the allowed\r\n * content.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass UTF8 extends Layout {\n  constructor(maxSpan, property) {\n    if ('string' === typeof maxSpan && undefined === property) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n    super(-1, property);\n    /** The maximum span of the layout in bytes.\r\n     *\r\n     * Positive values are generally expected.  Zero is abnormal.\r\n     * Attempts to encode or decode a value that exceeds this length\r\n     * will throw a `RangeError`.\r\n     *\r\n     * A negative value indicates that there is no bound on the length\r\n     * of the content. */\n    this.maxSpan = maxSpan;\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    checkUint8Array(b);\n    return b.length - offset;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const span = this.getSpan(b, offset);\n    if (0 <= this.maxSpan && this.maxSpan < span) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    return uint8ArrayToBuffer(b).slice(offset, offset + span).toString('utf-8');\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    /* Must force this to a string, lest it be a number and the\r\n     * \"utf8-encoding\" below actually allocate a buffer of length\r\n     * src */\n    if ('string' !== typeof src) {\n      src = String(src);\n    }\n    const srcb = buffer_1.Buffer.from(src, 'utf8');\n    const span = srcb.length;\n    if (0 <= this.maxSpan && this.maxSpan < span) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(uint8ArrayToBuffer(b), offset);\n    return span;\n  }\n}\nexports.UTF8 = UTF8;\n/**\r\n * Contain a constant value.\r\n *\r\n * This layout may be used in cases where a JavaScript value can be\r\n * inferred without an expression in the binary encoding.  An example\r\n * would be a {@link VariantLayout|variant layout} where the content\r\n * is implied by the union {@link Union#discriminator|discriminator}.\r\n *\r\n * @param {Object|Number|String} value - initializer for {@link\r\n * Constant#value|value}.  If the value is an object (or array) and\r\n * the application intends the object to remain unchanged regardless\r\n * of what is done to values decoded by this layout, the value should\r\n * be frozen prior passing it to this constructor.\r\n *\r\n * @param {String} [property] - initializer for {@link\r\n * Layout#property|property}.\r\n *\r\n * @augments {Layout}\r\n */\nclass Constant extends Layout {\n  constructor(value, property) {\n    super(0, property);\n    /** The value produced by this constant when the layout is {@link\r\n     * Constant#decode|decoded}.\r\n     *\r\n     * Any JavaScript value including `null` and `undefined` is\r\n     * permitted.\r\n     *\r\n     * **WARNING** If `value` passed in the constructor was not\r\n     * frozen, it is possible for users of decoded values to change\r\n     * the content of the value. */\n    this.value = value;\n  }\n  /** @override */\n  decode(b, offset) {\n    return this.value;\n  }\n  /** @override */\n  encode(src, b, offset) {\n    /* Constants take no space */\n    return 0;\n  }\n}\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */\nexports.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);\n/** Factory for {@link OffsetLayout}. */\nexports.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property);\n/** Factory for {@link UInt|unsigned int layouts} spanning one\r\n * byte. */\nexports.u8 = property => new UInt(1, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning two bytes. */\nexports.u16 = property => new UInt(2, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning three bytes. */\nexports.u24 = property => new UInt(3, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning four bytes. */\nexports.u32 = property => new UInt(4, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning five bytes. */\nexports.u40 = property => new UInt(5, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\r\n * spanning six bytes. */\nexports.u48 = property => new UInt(6, property);\n/** Factory for {@link NearUInt64|little-endian unsigned int\r\n * layouts} interpreted as Numbers. */\nexports.nu64 = property => new NearUInt64(property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning two bytes. */\nexports.u16be = property => new UIntBE(2, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning three bytes. */\nexports.u24be = property => new UIntBE(3, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning four bytes. */\nexports.u32be = property => new UIntBE(4, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning five bytes. */\nexports.u40be = property => new UIntBE(5, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\r\n * spanning six bytes. */\nexports.u48be = property => new UIntBE(6, property);\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\r\n * layouts} interpreted as Numbers. */\nexports.nu64be = property => new NearUInt64BE(property);\n/** Factory for {@link Int|signed int layouts} spanning one\r\n * byte. */\nexports.s8 = property => new Int(1, property);\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning two bytes. */\nexports.s16 = property => new Int(2, property);\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning three bytes. */\nexports.s24 = property => new Int(3, property);\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning four bytes. */\nexports.s32 = property => new Int(4, property);\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning five bytes. */\nexports.s40 = property => new Int(5, property);\n/** Factory for {@link Int|little-endian signed int layouts}\r\n * spanning six bytes. */\nexports.s48 = property => new Int(6, property);\n/** Factory for {@link NearInt64|little-endian signed int layouts}\r\n * interpreted as Numbers. */\nexports.ns64 = property => new NearInt64(property);\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning two bytes. */\nexports.s16be = property => new IntBE(2, property);\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning three bytes. */\nexports.s24be = property => new IntBE(3, property);\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning four bytes. */\nexports.s32be = property => new IntBE(4, property);\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning five bytes. */\nexports.s40be = property => new IntBE(5, property);\n/** Factory for {@link Int|big-endian signed int layouts}\r\n * spanning six bytes. */\nexports.s48be = property => new IntBE(6, property);\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\r\n * interpreted as Numbers. */\nexports.ns64be = property => new NearInt64BE(property);\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = property => new Float(property);\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = property => new FloatBE(property);\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = property => new Double(property);\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = property => new DoubleBE(property);\n/** Factory for {@link Structure} values. */\nexports.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);\n/** Factory for {@link BitStructure} values. */\nexports.bits = (word, msb, property) => new BitStructure(word, msb, property);\n/** Factory for {@link Sequence} values. */\nexports.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);\n/** Factory for {@link Union} values. */\nexports.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);\n/** Factory for {@link Blob} values. */\nexports.blob = (length, property) => new Blob(length, property);\n/** Factory for {@link CString} values. */\nexports.cstr = property => new CString(property);\n/** Factory for {@link UTF8} values. */\nexports.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);\n/** Factory for {@link Constant} values. */\nexports.constant = (value, property) => new Constant(value, property);","map":{"version":3,"names":["buffer_1","require","checkUint8Array","b","Uint8Array","TypeError","exports","uint8ArrayToBuffer","Buffer","from","buffer","byteOffset","length","Layout","constructor","span","property","Number","isInteger","makeDestinationObject","getSpan","offset","RangeError","replicate","rv","Object","create","prototype","assign","fromArray","values","undefined","nameWithProperty","name","lo","bindConstructorLayout","Class","layout","hasOwnProperty","call","Error","layout_","boundConstructor_","defineProperty","value","encode","writable","decode","ExternalLayout","isCount","GreedyCount","elementSpan","rem","Math","floor","src","OffsetLayout","UInt","UIntBE","readUIntLE","writeUIntLE","readUIntBE","writeUIntBE","Int","readIntLE","writeIntLE","IntBE","readIntBE","writeIntBE","V2E32","pow","divmodInt64","hi32","lo32","roundedInt64","NearUInt64","readUInt32LE","split","writeUInt32LE","NearUInt64BE","readUInt32BE","writeUInt32BE","NearInt64","readInt32LE","writeInt32LE","NearInt64BE","readInt32BE","writeInt32BE","Float","readFloatLE","writeFloatLE","FloatBE","readFloatBE","writeFloatBE","Double","readDoubleLE","writeDoubleLE","DoubleBE","readDoubleBE","writeDoubleBE","Sequence","elementLayout","count","idx","i","push","elo","reduce","v","Structure","fields","decodePrefixes","Array","isArray","acc","fd","e","fsp","dest","firstOffset","lastOffset","lastWrote","fv","shift","layoutFor","offsetOf","UnionDiscriminator","UnionLayoutDiscriminator","Union","discr","defaultLayout","discriminator","usesPrefixDiscriminator","registry","boundGetSourceVariant","defaultGetSourceVariant","bind","getSourceVariant","configGetSourceVariant","gsv","vlo","getVariant","tag","dlo","clo","contentOffset","addVariant","variant","VariantLayout","vb","union","fixBitwiseResult","BitStructure","word","msb","_packedSetValue","_packedGetValue","addField","bits","bf","BitField","addBoolean","Boolean","fieldFor","container","totalBits","usedBits","sum","valueMask","start","wordMask","wordValue","Blob","slice","srcBuffer","write","toString","CString","String","srcb","copy","UTF8","maxSpan","Constant","greedy","u8","u16","u24","u32","u40","u48","nu64","u16be","u24be","u32be","u40be","u48be","nu64be","s8","s16","s24","s32","s40","s48","ns64","s16be","s24be","s32be","s40be","s48be","ns64be","f32","f32be","f64","f64be","struct","seq","unionLayoutDiscriminator","blob","cstr","utf8","constant"],"sources":["../src/Layout.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}