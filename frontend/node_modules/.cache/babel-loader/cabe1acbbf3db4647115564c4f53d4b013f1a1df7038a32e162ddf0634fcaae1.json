{"ast":null,"code":"/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nimport { validateBasic, wNAF, pippenger } from './curve.js';\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes, memoized, abool } from './utils.js';\nfunction validateSigVerOpts(opts) {\n  if (opts.lowS !== undefined) abool('lowS', opts.lowS);\n  if (opts.prehash !== undefined) abool('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n  const opts = validateBasic(curve);\n  ut.validateObject(opts, {\n    a: 'field',\n    b: 'field'\n  }, {\n    allowedPrivateKeyLengths: 'array',\n    wrapPrivateKey: 'boolean',\n    isTorsionFree: 'function',\n    clearCofactor: 'function',\n    allowInfinityPoint: 'boolean',\n    fromBytes: 'function',\n    toBytes: 'function'\n  });\n  const {\n    endo,\n    Fp,\n    a\n  } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n    }\n    if (typeof endo !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') {\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({\n    ...opts\n  });\n}\nconst {\n  bytesToNumberBE: b2n,\n  hexToBytes: h2b\n} = ut;\n/**\r\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\r\n *\r\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\r\n *\r\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\r\n */\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: class DERErr extends Error {\n    constructor(m = '') {\n      super(m);\n    }\n  },\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag, data) => {\n      const {\n        Err: E\n      } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = ut.numberToHexUnpadded(dataLen);\n      if (len.length / 2 & 128) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? ut.numberToHexUnpadded(len.length / 2 | 128) : '';\n      return `${ut.numberToHexUnpadded(tag)}${lenLen}${len}${data}`;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag, data) {\n      const {\n        Err: E\n      } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 127;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = length << 8 | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return {\n        v,\n        l: data.subarray(pos + length)\n      };\n    }\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num) {\n      const {\n        Err: E\n      } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = ut.numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected assertion');\n      return hex;\n    },\n    decode(data) {\n      const {\n        Err: E\n      } = DER;\n      if (data[0] & 128) throw new E('Invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 128)) throw new E('Invalid signature integer: unnecessary leading zero');\n      return b2n(data);\n    }\n  },\n  toSig(hex) {\n    // parse DER signature\n    const {\n      Err: E,\n      _int: int,\n      _tlv: tlv\n    } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    ut.abytes(data);\n    const {\n      v: seqBytes,\n      l: seqLeftBytes\n    } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('Invalid signature: left bytes after parsing');\n    const {\n      v: rBytes,\n      l: rLeftBytes\n    } = tlv.decode(0x02, seqBytes);\n    const {\n      v: sBytes,\n      l: sLeftBytes\n    } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('Invalid signature: left bytes after parsing');\n    return {\n      r: int.decode(rBytes),\n      s: int.decode(sBytes)\n    };\n  },\n  hexFromSig(sig) {\n    const {\n      _tlv: tlv,\n      _int: int\n    } = DER;\n    const seq = `${tlv.encode(0x02, int.encode(sig.r))}${tlv.encode(0x02, int.encode(sig.s))}`;\n    return tlv.encode(0x30, seq);\n  }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _3n = BigInt(3),\n  _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n  const CURVE = validatePointOpts(opts);\n  const {\n    Fp\n  } = CURVE; // All curves has same field / group length as for now, but they can differ\n  const Fn = mod.Field(CURVE.n, CURVE.nBitLength);\n  const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {\n    const a = point.toAffine();\n    return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n  });\n  const fromBytes = CURVE.fromBytes || (bytes => {\n    // const head = bytes[0];\n    const tail = bytes.subarray(1);\n    // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n    return {\n      x,\n      y\n    };\n  });\n  /**\r\n   * y² = x³ + ax + b: Short weierstrass curve formula\r\n   * @returns y²\r\n   */\n  function weierstrassEquation(x) {\n    const {\n      a,\n      b\n    } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error('bad generator point: equation left != right');\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num) {\n    return ut.inRange(num, _1n, CURVE.n);\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key) {\n    const {\n      allowedPrivateKeyLengths: lengths,\n      nByteLength,\n      wrapPrivateKey,\n      n: N\n    } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (ut.isBytes(key)) key = ut.bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num;\n    try {\n      num = typeof key === 'bigint' ? key : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n    }\n    if (wrapPrivateKey) num = mod.mod(num, N); // disabled by default, enabled for BLS\n    ut.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n    return num;\n  }\n  function assertPrjPoint(other) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (x, y, z) ∋ (x=x/z, y=y/z)\n  const toAffineMemo = memoized((p, iz) => {\n    const {\n      px: x,\n      py: y,\n      pz: z\n    } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(z, Fp.ONE)) return {\n      x,\n      y\n    };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n    const ax = Fp.mul(x, iz);\n    const ay = Fp.mul(y, iz);\n    const zz = Fp.mul(z, iz);\n    if (is0) return {\n      x: Fp.ZERO,\n      y: Fp.ZERO\n    };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return {\n      x: ax,\n      y: ay\n    };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized(p => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n      if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const {\n      x,\n      y\n    } = p.toAffine();\n    // Check if x, y are valid field elements\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n    const left = Fp.sqr(y); // y²\n    const right = weierstrassEquation(x); // x³ + ax + b\n    if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n  /**\r\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\r\n   * Default Point works in 2d / affine coordinates: (x, y)\r\n   * We're doing calculations in projective, because its operations don't require costly inversion.\r\n   */\n  class Point {\n    constructor(px, py, pz) {\n      this.px = px;\n      this.py = py;\n      this.pz = pz;\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n      Object.freeze(this);\n    }\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p) {\n      const {\n        x,\n        y\n      } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = i => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    /**\r\n     * Takes a bunch of Projective Points but executes only one\r\n     * inversion on all of them. Inversion is very slow operation,\r\n     * so this improves performance massively.\r\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\r\n     */\n    static normalizeZ(points) {\n      const toInv = Fp.invertBatch(points.map(p => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    /**\r\n     * Converts hash string or Uint8Array to Point.\r\n     * @param hex short/long ECDSA hex\r\n     */\n    static fromHex(hex) {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n    // Multiscalar Multiplication\n    static msm(points, scalars) {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n    // A point on curve is valid if it conforms to equation.\n    assertValidity() {\n      assertValidMemo(this);\n    }\n    hasEvenY() {\n      const {\n        y\n      } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n    /**\r\n     * Compare one point to another.\r\n     */\n    equals(other) {\n      assertPrjPoint(other);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      const {\n        px: X2,\n        py: Y2,\n        pz: Z2\n      } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n    /**\r\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\r\n     */\n    negate() {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const {\n        a,\n        b\n      } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      let X3 = Fp.ZERO,\n        Y3 = Fp.ZERO,\n        Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other) {\n      assertPrjPoint(other);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      const {\n        px: X2,\n        py: Y2,\n        pz: Z2\n      } = other;\n      let X3 = Fp.ZERO,\n        Y3 = Fp.ZERO,\n        Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    wNAF(n) {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n    /**\r\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\r\n     * It's faster, but should only be used when you don't care about\r\n     * an exposed private key e.g. sig verification, which works over *public* keys.\r\n     */\n    multiplyUnsafe(sc) {\n      ut.aInRange('scalar', sc, _0n, CURVE.n);\n      const I = Point.ZERO;\n      if (sc === _0n) return I;\n      if (sc === _1n) return this;\n      const {\n        endo\n      } = CURVE;\n      if (!endo) return wnaf.unsafeLadder(this, sc);\n      // Apply endomorphism\n      let {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n      } = endo.splitScalar(sc);\n      let k1p = I;\n      let k2p = I;\n      let d = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n    /**\r\n     * Constant time multiplication.\r\n     * Uses wNAF method. Windowed method may be 10% faster,\r\n     * but takes 2x longer to generate and consumes 2x memory.\r\n     * Uses precomputes when available.\r\n     * Uses endomorphism for Koblitz curves.\r\n     * @param scalar by which the point would be multiplied\r\n     * @returns New point\r\n     */\n    multiply(scalar) {\n      const {\n        endo,\n        n: N\n      } = CURVE;\n      ut.aInRange('scalar', scalar, _1n, N);\n      let point, fake; // Fake point is used to const-time mult\n      if (endo) {\n        const {\n          k1neg,\n          k1,\n          k2neg,\n          k2\n        } = endo.splitScalar(scalar);\n        let {\n          p: k1p,\n          f: f1p\n        } = this.wNAF(k1);\n        let {\n          p: k2p,\n          f: f2p\n        } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const {\n          p,\n          f\n        } = this.wNAF(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n    /**\r\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\r\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\r\n     * The trick could be useful if both P and Q are not G (not in our case).\r\n     * @returns non-zero affine point\r\n     */\n    multiplyAndAddUnsafe(Q, a, b) {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (P, a // Select faster multiply() method\n      ) => a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    toAffine(iz) {\n      return toAffineMemo(this, iz);\n    }\n    isTorsionFree() {\n      const {\n        h: cofactor,\n        isTorsionFree\n      } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor() {\n      const {\n        h: cofactor,\n        clearCofactor\n      } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this);\n      return this.multiplyUnsafe(CURVE.h);\n    }\n    toRawBytes(isCompressed = true) {\n      abool('isCompressed', isCompressed);\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n    toHex(isCompressed = true) {\n      abool('isCompressed', isCompressed);\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  // Validate if generator point is on curve\n  return {\n    CURVE,\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder\n  };\n}\nfunction validateOpts(curve) {\n  const opts = validateBasic(curve);\n  ut.validateObject(opts, {\n    hash: 'hash',\n    hmac: 'function',\n    randomBytes: 'function'\n  }, {\n    bits2int: 'function',\n    bits2int_modN: 'function',\n    lowS: 'boolean'\n  });\n  return Object.freeze({\n    lowS: true,\n    ...opts\n  });\n}\n/**\r\n * Creates short weierstrass curve and ECDSA signature methods for it.\r\n * @example\r\n * import { Field } from '@noble/curves/abstract/modular';\r\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\r\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\r\n */\nexport function weierstrass(curveDef) {\n  const CURVE = validateOpts(curveDef);\n  const {\n    Fp,\n    n: CURVE_ORDER\n  } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n  function modN(a) {\n    return mod.mod(a, CURVE_ORDER);\n  }\n  function invN(a) {\n    return mod.invert(a, CURVE_ORDER);\n  }\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(_c, point, isCompressed) {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = ut.concatBytes;\n      abool('isCompressed', isCompressed);\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = ut.bytesToNumberBE(tail);\n        if (!ut.inRange(x, _1n, Fp.ORDER)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n        let y;\n        try {\n          y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n        } catch (sqrtError) {\n          const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n          throw new Error('Point is not on curve' + suffix);\n        }\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return {\n          x,\n          y\n        };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n          x,\n          y\n        };\n      } else {\n        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n      }\n    }\n  });\n  const numToNByteStr = num => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n  function isBiggerThanHalfOrder(number) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n  function normalizeS(s) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n  /**\r\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\r\n   */\n  class Signature {\n    constructor(r, s, recovery) {\n      this.r = r;\n      this.s = s;\n      this.recovery = recovery;\n      this.assertValidity();\n    }\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex) {\n      const {\n        r,\n        s\n      } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n    assertValidity() {\n      ut.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n      ut.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n    }\n    addRecoveryBit(recovery) {\n      return new Signature(this.r, this.s, recovery);\n    }\n    recoverPublicKey(msgHash) {\n      const {\n        r,\n        s,\n        recovery: rec\n      } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS() {\n      return isBiggerThanHalfOrder(this.s);\n    }\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n    // DER-encoded\n    toDERRawBytes() {\n      return ut.hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig({\n        r: this.r,\n        s: this.s\n      });\n    }\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return ut.hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n  }\n  const utils = {\n    isValidPrivateKey(privateKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n    /**\r\n     * Produces cryptographically secure private key from random of size\r\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\r\n     */\n    randomPrivateKey: () => {\n      const length = mod.getMinHashLength(CURVE.n);\n      return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n    },\n    /**\r\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\r\n     * Allows to massively speed-up `point.multiply(scalar)`.\r\n     * @returns cached point\r\n     * @example\r\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\r\n     * fast.multiply(privKey); // much faster ECDH now\r\n     */\n    precompute(windowSize = 8, point = Point.BASE) {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    }\n  };\n  /**\r\n   * Computes public key for a private key. Checks for validity of the private key.\r\n   * @param privateKey private key\r\n   * @param isCompressed whether to return compact (default), or full key\r\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\r\n   */\n  function getPublicKey(privateKey, isCompressed = true) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n  /**\r\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\r\n   */\n  function isProbPub(item) {\n    const arr = ut.isBytes(item);\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n  /**\r\n   * ECDH (Elliptic Curve Diffie Hellman).\r\n   * Computes shared public key from private key and public key.\r\n   * Checks: 1) private key validity 2) shared key is on-curve.\r\n   * Does NOT hash the result.\r\n   * @param privateA private key\r\n   * @param publicB different public key\r\n   * @param isCompressed whether to return compact (default), or full key\r\n   * @returns shared public key\r\n   */\n  function getSharedSecret(privateA, publicB, isCompressed = true) {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int = CURVE.bits2int || function (bytes) {\n    // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n    // for some cases, since bytes.length * 8 is not actual bitLength.\n    const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n    const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n    return delta > 0 ? num >> BigInt(delta) : num;\n  };\n  const bits2int_modN = CURVE.bits2int_modN || function (bytes) {\n    return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n  };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n  /**\r\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\r\n   */\n  function int2octets(num) {\n    ut.aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n, ORDER_MASK);\n    // works with order, can have different size than numToField!\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\n  }\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n  // Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some(k => k in opts)) throw new Error('sign() legacy options not supported');\n    const {\n      hash,\n      randomBytes\n    } = CURVE;\n    let {\n      lowS,\n      prehash,\n      extraEntropy: ent\n    } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    validateSigVerOpts(opts);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null && ent !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes) {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery); // use normS, not s\n    }\n    return {\n      seed,\n      k2sig\n    };\n  }\n  const defaultSigOpts = {\n    lowS: CURVE.lowS,\n    prehash: false\n  };\n  const defaultVerOpts = {\n    lowS: CURVE.lowS,\n    prehash: false\n  };\n  /**\r\n   * Signs message hash with a private key.\r\n   * ```\r\n   * sign(m, d, k) where\r\n   *   (x, y) = G × k\r\n   *   r = x mod n\r\n   *   s = (m + dr)/k mod n\r\n   * ```\r\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\r\n   * @param privKey private key\r\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\r\n   * @returns signature with recovery param\r\n   */\n  function sign(msgHash, privKey, opts = defaultSigOpts) {\n    const {\n      seed,\n      k2sig\n    } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n  /**\r\n   * Verifies a signature against message hash and public key.\r\n   * Rejects lowS signatures by default: to override,\r\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\r\n   *\r\n   * ```\r\n   * verify(r, s, h, P) where\r\n   *   U1 = hs^-1 mod n\r\n   *   U2 = rs^-1 mod n\r\n   *   R = U1⋅G - U2⋅P\r\n   *   mod(R.x, n) == r\r\n   * ```\r\n   */\n  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    validateSigVerOpts(opts);\n    const {\n      lowS,\n      prehash\n    } = opts;\n    let _sig = undefined;\n    let P;\n    try {\n      if (typeof sg === 'string' || ut.isBytes(sg)) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n          _sig = Signature.fromCompact(sg);\n        }\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n        const {\n          r,\n          s\n        } = sg;\n        _sig = new Signature(r, s);\n      } else {\n        throw new Error('PARSE');\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      if (error.message === 'PARSE') throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n      return false;\n    }\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const {\n      r,\n      s\n    } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils\n  };\n}\n/**\r\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\r\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\r\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\r\n * b = False and y = sqrt(Z * (u / v)) otherwise.\r\n * @param Fp\r\n * @param Z\r\n * @returns\r\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u, v) => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return {\n      isValid: isQR,\n      value: tv3\n    };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u, v) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return {\n        isValid: isQR,\n        value: y\n      }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\r\n * Simplified Shallue-van de Woestijne-Ulas Method\r\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\r\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n  mod.validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return u => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const {\n      isValid,\n      value\n    } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n    return {\n      x,\n      y\n    };\n  };\n}","map":{"version":3,"names":["validateBasic","wNAF","pippenger","mod","ut","ensureBytes","memoized","abool","validateSigVerOpts","opts","lowS","undefined","prehash","validatePointOpts","curve","validateObject","a","b","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","clearCofactor","allowInfinityPoint","fromBytes","toBytes","endo","Fp","eql","ZERO","Error","beta","splitScalar","Object","freeze","bytesToNumberBE","b2n","hexToBytes","h2b","DER","Err","DERErr","constructor","m","_tlv","encode","tag","data","E","length","dataLen","len","numberToHexUnpadded","lenLen","decode","pos","first","isLong","lengthBytes","subarray","v","l","_int","num","_0n","hex","Number","parseInt","toSig","int","tlv","abytes","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","r","s","hexFromSig","sig","seq","BigInt","_1n","_2n","_3n","_4n","weierstrassPoints","CURVE","Fn","Field","n","nBitLength","_c","point","_isCompressed","toAffine","concatBytes","Uint8Array","from","x","y","bytes","tail","BYTES","weierstrassEquation","x2","sqr","x3","mul","add","Gy","Gx","isWithinCurveOrder","inRange","normPrivateKeyToScalar","key","lengths","nByteLength","N","isBytes","bytesToHex","includes","padStart","error","aInRange","assertPrjPoint","other","Point","toAffineMemo","p","iz","px","py","pz","z","ONE","is0","inv","ax","ay","zz","assertValidMemo","isValid","left","right","fromAffine","i","normalizeZ","points","toInv","invertBatch","map","fromHex","P","assertValidity","fromPrivateKey","privateKey","BASE","multiply","msm","scalars","_setWindowSize","windowSize","wnaf","setWindowSize","hasEvenY","isOdd","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","neg","double","b3","X3","Y3","Z3","t0","t1","t2","t3","sub","t4","t5","subtract","wNAFCached","multiplyUnsafe","sc","I","unsafeLadder","k1neg","k1","k2neg","k2","k1p","k2p","d","scalar","fake","f","f1p","f2p","constTimeNegate","multiplyAndAddUnsafe","Q","G","sum","h","cofactor","toRawBytes","isCompressed","toHex","_bits","Math","ceil","ProjectivePoint","validateOpts","hash","hmac","randomBytes","bits2int","bits2int_modN","weierstrass","curveDef","CURVE_ORDER","compressedLen","uncompressedLen","modN","invN","invert","cat","head","ORDER","y2","sqrt","sqrtError","suffix","message","isYOdd","isHeadOdd","numToNByteStr","numberToBytesBE","isBiggerThanHalfOrder","number","HALF","normalizeS","slcNum","to","slice","Signature","recovery","fromCompact","fromDER","addRecoveryBit","recoverPublicKey","msgHash","rec","radj","prefix","R","ir","u1","u2","hasHighS","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","utils","isValidPrivateKey","randomPrivateKey","getMinHashLength","mapHashToField","precompute","getPublicKey","isProbPub","item","arr","str","getSharedSecret","privateA","publicB","delta","ORDER_MASK","bitMask","int2octets","prepSig","defaultSigOpts","some","k","extraEntropy","ent","h1int","seedArgs","e","push","seed","k2sig","kBytes","ik","q","normS","defaultVerOpts","sign","privKey","C","drbg","createHmacDrbg","outputLen","verify","signature","publicKey","sg","_sig","derError","is","SWUFpSqrtRatio","Z","o","c1","_2n_pow_c1_1","_2n_pow_c1","c2","c3","c4","c5","c6","pow","c7","sqrtRatio","u","tv1","tv2","tv3","tv5","tv4","isQR","cmov","tvv5","e1","value","y1","mapToCurveSimpleSWU","validateField","A","B","tv6","div"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@noble\\curves\\src\\abstract\\weierstrass.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\r\nimport {\r\n  AffinePoint,\r\n  BasicCurve,\r\n  Group,\r\n  GroupConstructor,\r\n  validateBasic,\r\n  wNAF,\r\n  pippenger,\r\n} from './curve.js';\r\nimport * as mod from './modular.js';\r\nimport * as ut from './utils.js';\r\nimport { CHash, Hex, PrivKey, ensureBytes, memoized, abool } from './utils.js';\r\n\r\nexport type { AffinePoint };\r\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\r\ntype EndomorphismOpts = {\r\n  beta: bigint;\r\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\r\n};\r\nexport type BasicWCurve<T> = BasicCurve<T> & {\r\n  // Params: a, b\r\n  a: T;\r\n  b: T;\r\n\r\n  // Optional params\r\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\r\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\r\n  endo?: EndomorphismOpts; // Endomorphism options for Koblitz curves\r\n  // When a cofactor != 1, there can be an effective methods to:\r\n  // 1. Determine whether a point is torsion-free\r\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\r\n  // 2. Clear torsion component\r\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\r\n};\r\n\r\ntype Entropy = Hex | boolean;\r\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\r\nexport type VerOpts = { lowS?: boolean; prehash?: boolean };\r\n\r\nfunction validateSigVerOpts(opts: SignOpts | VerOpts) {\r\n  if (opts.lowS !== undefined) abool('lowS', opts.lowS);\r\n  if (opts.prehash !== undefined) abool('prehash', opts.prehash);\r\n}\r\n\r\n/**\r\n * ### Design rationale for types\r\n *\r\n * * Interaction between classes from different curves should fail:\r\n *   `k256.Point.BASE.add(p256.Point.BASE)`\r\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\r\n * * Different calls of `curve()` would return different classes -\r\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\r\n *   it won't affect others\r\n *\r\n * TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call.\r\n *\r\n * We can use generic types via some param, like curve opts, but that would:\r\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\r\n *     which is hard to debug.\r\n *     2. Params can be generic and we can't enforce them to be constant value:\r\n *     if somebody creates curve from non-constant params,\r\n *     it would be allowed to interact with other curves with non-constant params\r\n *\r\n * TODO: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\r\n */\r\n\r\n// Instance for 3d XYZ points\r\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\r\n  readonly px: T;\r\n  readonly py: T;\r\n  readonly pz: T;\r\n  get x(): T;\r\n  get y(): T;\r\n  multiply(scalar: bigint): ProjPointType<T>;\r\n  toAffine(iz?: T): AffinePoint<T>;\r\n  isTorsionFree(): boolean;\r\n  clearCofactor(): ProjPointType<T>;\r\n  assertValidity(): void;\r\n  hasEvenY(): boolean;\r\n  toRawBytes(isCompressed?: boolean): Uint8Array;\r\n  toHex(isCompressed?: boolean): string;\r\n\r\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\r\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\r\n  _setWindowSize(windowSize: number): void;\r\n}\r\n// Static methods for 3d XYZ points\r\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\r\n  new (x: T, y: T, z: T): ProjPointType<T>;\r\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\r\n  fromHex(hex: Hex): ProjPointType<T>;\r\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\r\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\r\n  msm(points: ProjPointType<T>[], scalars: bigint[]): ProjPointType<T>;\r\n}\r\n\r\nexport type CurvePointsType<T> = BasicWCurve<T> & {\r\n  // Bytes\r\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\r\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\r\n};\r\n\r\nfunction validatePointOpts<T>(curve: CurvePointsType<T>) {\r\n  const opts = validateBasic(curve);\r\n  ut.validateObject(\r\n    opts,\r\n    {\r\n      a: 'field',\r\n      b: 'field',\r\n    },\r\n    {\r\n      allowedPrivateKeyLengths: 'array',\r\n      wrapPrivateKey: 'boolean',\r\n      isTorsionFree: 'function',\r\n      clearCofactor: 'function',\r\n      allowInfinityPoint: 'boolean',\r\n      fromBytes: 'function',\r\n      toBytes: 'function',\r\n    }\r\n  );\r\n  const { endo, Fp, a } = opts;\r\n  if (endo) {\r\n    if (!Fp.eql(a, Fp.ZERO)) {\r\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\r\n    }\r\n    if (\r\n      typeof endo !== 'object' ||\r\n      typeof endo.beta !== 'bigint' ||\r\n      typeof endo.splitScalar !== 'function'\r\n    ) {\r\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\r\n    }\r\n  }\r\n  return Object.freeze({ ...opts } as const);\r\n}\r\n\r\nexport type CurvePointsRes<T> = {\r\n  CURVE: ReturnType<typeof validatePointOpts<T>>;\r\n  ProjectivePoint: ProjConstructor<T>;\r\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\r\n  weierstrassEquation: (x: T) => T;\r\n  isWithinCurveOrder: (num: bigint) => boolean;\r\n};\r\n\r\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\r\n\r\n/**\r\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\r\n *\r\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\r\n *\r\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\r\n */\r\nexport const DER = {\r\n  // asn.1 DER encoding utils\r\n  Err: class DERErr extends Error {\r\n    constructor(m = '') {\r\n      super(m);\r\n    }\r\n  },\r\n  // Basic building block is TLV (Tag-Length-Value)\r\n  _tlv: {\r\n    encode: (tag: number, data: string) => {\r\n      const { Err: E } = DER;\r\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\r\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\r\n      const dataLen = data.length / 2;\r\n      const len = ut.numberToHexUnpadded(dataLen);\r\n      if ((len.length / 2) & 0b1000_0000) throw new E('tlv.encode: long form length too big');\r\n      // length of length with long form flag\r\n      const lenLen = dataLen > 127 ? ut.numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\r\n      return `${ut.numberToHexUnpadded(tag)}${lenLen}${len}${data}`;\r\n    },\r\n    // v - value, l - left bytes (unparsed)\r\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array } {\r\n      const { Err: E } = DER;\r\n      let pos = 0;\r\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\r\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\r\n      const first = data[pos++];\r\n      const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\r\n      let length = 0;\r\n      if (!isLong) length = first;\r\n      else {\r\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\r\n        const lenLen = first & 0b0111_1111;\r\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\r\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\r\n        const lengthBytes = data.subarray(pos, pos + lenLen);\r\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\r\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\r\n        for (const b of lengthBytes) length = (length << 8) | b;\r\n        pos += lenLen;\r\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\r\n      }\r\n      const v = data.subarray(pos, pos + length);\r\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\r\n      return { v, l: data.subarray(pos + length) };\r\n    },\r\n  },\r\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\r\n  // since we always use positive integers here. It must always be empty:\r\n  // - add zero byte if exists\r\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\r\n  _int: {\r\n    encode(num: bigint) {\r\n      const { Err: E } = DER;\r\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\r\n      let hex = ut.numberToHexUnpadded(num);\r\n      // Pad with zero byte if negative flag is present\r\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\r\n      if (hex.length & 1) throw new E('unexpected assertion');\r\n      return hex;\r\n    },\r\n    decode(data: Uint8Array): bigint {\r\n      const { Err: E } = DER;\r\n      if (data[0] & 0b1000_0000) throw new E('Invalid signature integer: negative');\r\n      if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\r\n        throw new E('Invalid signature integer: unnecessary leading zero');\r\n      return b2n(data);\r\n    },\r\n  },\r\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\r\n    // parse DER signature\r\n    const { Err: E, _int: int, _tlv: tlv } = DER;\r\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\r\n    ut.abytes(data);\r\n    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\r\n    if (seqLeftBytes.length) throw new E('Invalid signature: left bytes after parsing');\r\n    const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\r\n    const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\r\n    if (sLeftBytes.length) throw new E('Invalid signature: left bytes after parsing');\r\n    return { r: int.decode(rBytes), s: int.decode(sBytes) };\r\n  },\r\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\r\n    const { _tlv: tlv, _int: int } = DER;\r\n    const seq = `${tlv.encode(0x02, int.encode(sig.r))}${tlv.encode(0x02, int.encode(sig.s))}`;\r\n    return tlv.encode(0x30, seq);\r\n  },\r\n};\r\n\r\n// Be friendly to bad ECMAScript parsers by not using bigint literals\r\n// prettier-ignore\r\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\r\n\r\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>): CurvePointsRes<T> {\r\n  const CURVE = validatePointOpts(opts);\r\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\r\n  const Fn = mod.Field(CURVE.n, CURVE.nBitLength);\r\n\r\n  const toBytes =\r\n    CURVE.toBytes ||\r\n    ((_c: ProjConstructor<T>, point: ProjPointType<T>, _isCompressed: boolean) => {\r\n      const a = point.toAffine();\r\n      return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\r\n    });\r\n  const fromBytes =\r\n    CURVE.fromBytes ||\r\n    ((bytes: Uint8Array) => {\r\n      // const head = bytes[0];\r\n      const tail = bytes.subarray(1);\r\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\r\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\r\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\r\n      return { x, y };\r\n    });\r\n\r\n  /**\r\n   * y² = x³ + ax + b: Short weierstrass curve formula\r\n   * @returns y²\r\n   */\r\n  function weierstrassEquation(x: T): T {\r\n    const { a, b } = CURVE;\r\n    const x2 = Fp.sqr(x); // x * x\r\n    const x3 = Fp.mul(x2, x); // x2 * x\r\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\r\n  }\r\n  // Validate whether the passed curve params are valid.\r\n  // We check if curve equation works for generator point.\r\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\r\n  // ProjectivePoint class has not been initialized yet.\r\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\r\n    throw new Error('bad generator point: equation left != right');\r\n\r\n  // Valid group elements reside in range 1..n-1\r\n  function isWithinCurveOrder(num: bigint): boolean {\r\n    return ut.inRange(num, _1n, CURVE.n);\r\n  }\r\n  // Validates if priv key is valid and converts it to bigint.\r\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\r\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\r\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\r\n    if (lengths && typeof key !== 'bigint') {\r\n      if (ut.isBytes(key)) key = ut.bytesToHex(key);\r\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\r\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\r\n      key = key.padStart(nByteLength * 2, '0');\r\n    }\r\n    let num: bigint;\r\n    try {\r\n      num =\r\n        typeof key === 'bigint'\r\n          ? key\r\n          : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\r\n    } catch (error) {\r\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\r\n    }\r\n    if (wrapPrivateKey) num = mod.mod(num, N); // disabled by default, enabled for BLS\r\n    ut.aInRange('private key', num, _1n, N); // num in range [1..N-1]\r\n    return num;\r\n  }\r\n\r\n  function assertPrjPoint(other: unknown) {\r\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\r\n  }\r\n\r\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\r\n\r\n  // Converts Projective point to affine (x, y) coordinates.\r\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\r\n  // (x, y, z) ∋ (x=x/z, y=y/z)\r\n  const toAffineMemo = memoized((p: Point, iz?: T): AffinePoint<T> => {\r\n    const { px: x, py: y, pz: z } = p;\r\n    // Fast-path for normalized points\r\n    if (Fp.eql(z, Fp.ONE)) return { x, y };\r\n    const is0 = p.is0();\r\n    // If invZ was 0, we return zero point. However we still want to execute\r\n    // all operations, so we replace invZ with a random number, 1.\r\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\r\n    const ax = Fp.mul(x, iz);\r\n    const ay = Fp.mul(y, iz);\r\n    const zz = Fp.mul(z, iz);\r\n    if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\r\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\r\n    return { x: ax, y: ay };\r\n  });\r\n  // NOTE: on exception this will crash 'cached' and no value will be set.\r\n  // Otherwise true will be return\r\n  const assertValidMemo = memoized((p: Point) => {\r\n    if (p.is0()) {\r\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\r\n      // In BLS, ZERO can be serialized, so we allow it.\r\n      // (0, 0, 0) is wrong representation of ZERO and is always invalid.\r\n      if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\r\n      throw new Error('bad point: ZERO');\r\n    }\r\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\r\n    const { x, y } = p.toAffine();\r\n    // Check if x, y are valid field elements\r\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\r\n    const left = Fp.sqr(y); // y²\r\n    const right = weierstrassEquation(x); // x³ + ax + b\r\n    if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\r\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\r\n    return true;\r\n  });\r\n\r\n  /**\r\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\r\n   * Default Point works in 2d / affine coordinates: (x, y)\r\n   * We're doing calculations in projective, because its operations don't require costly inversion.\r\n   */\r\n  class Point implements ProjPointType<T> {\r\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\r\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\r\n\r\n    constructor(\r\n      readonly px: T,\r\n      readonly py: T,\r\n      readonly pz: T\r\n    ) {\r\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\r\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\r\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\r\n      Object.freeze(this);\r\n    }\r\n\r\n    // Does not validate if the point is on-curve.\r\n    // Use fromHex instead, or call assertValidity() later.\r\n    static fromAffine(p: AffinePoint<T>): Point {\r\n      const { x, y } = p || {};\r\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\r\n      if (p instanceof Point) throw new Error('projective point not allowed');\r\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\r\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\r\n      if (is0(x) && is0(y)) return Point.ZERO;\r\n      return new Point(x, y, Fp.ONE);\r\n    }\r\n\r\n    get x(): T {\r\n      return this.toAffine().x;\r\n    }\r\n    get y(): T {\r\n      return this.toAffine().y;\r\n    }\r\n\r\n    /**\r\n     * Takes a bunch of Projective Points but executes only one\r\n     * inversion on all of them. Inversion is very slow operation,\r\n     * so this improves performance massively.\r\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\r\n     */\r\n    static normalizeZ(points: Point[]): Point[] {\r\n      const toInv = Fp.invertBatch(points.map((p) => p.pz));\r\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\r\n    }\r\n\r\n    /**\r\n     * Converts hash string or Uint8Array to Point.\r\n     * @param hex short/long ECDSA hex\r\n     */\r\n    static fromHex(hex: Hex): Point {\r\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\r\n      P.assertValidity();\r\n      return P;\r\n    }\r\n\r\n    // Multiplies generator point by privateKey.\r\n    static fromPrivateKey(privateKey: PrivKey) {\r\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\r\n    }\r\n\r\n    // Multiscalar Multiplication\r\n    static msm(points: Point[], scalars: bigint[]) {\r\n      return pippenger(Point, Fn, points, scalars);\r\n    }\r\n\r\n    // \"Private method\", don't use it directly\r\n    _setWindowSize(windowSize: number) {\r\n      wnaf.setWindowSize(this, windowSize);\r\n    }\r\n\r\n    // A point on curve is valid if it conforms to equation.\r\n    assertValidity(): void {\r\n      assertValidMemo(this);\r\n    }\r\n\r\n    hasEvenY(): boolean {\r\n      const { y } = this.toAffine();\r\n      if (Fp.isOdd) return !Fp.isOdd(y);\r\n      throw new Error(\"Field doesn't support isOdd\");\r\n    }\r\n\r\n    /**\r\n     * Compare one point to another.\r\n     */\r\n    equals(other: Point): boolean {\r\n      assertPrjPoint(other);\r\n      const { px: X1, py: Y1, pz: Z1 } = this;\r\n      const { px: X2, py: Y2, pz: Z2 } = other;\r\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\r\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\r\n      return U1 && U2;\r\n    }\r\n\r\n    /**\r\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\r\n     */\r\n    negate(): Point {\r\n      return new Point(this.px, Fp.neg(this.py), this.pz);\r\n    }\r\n\r\n    // Renes-Costello-Batina exception-free doubling formula.\r\n    // There is 30% faster Jacobian formula, but it is not complete.\r\n    // https://eprint.iacr.org/2015/1060, algorithm 3\r\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\r\n    double() {\r\n      const { a, b } = CURVE;\r\n      const b3 = Fp.mul(b, _3n);\r\n      const { px: X1, py: Y1, pz: Z1 } = this;\r\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\r\n      let t0 = Fp.mul(X1, X1); // step 1\r\n      let t1 = Fp.mul(Y1, Y1);\r\n      let t2 = Fp.mul(Z1, Z1);\r\n      let t3 = Fp.mul(X1, Y1);\r\n      t3 = Fp.add(t3, t3); // step 5\r\n      Z3 = Fp.mul(X1, Z1);\r\n      Z3 = Fp.add(Z3, Z3);\r\n      X3 = Fp.mul(a, Z3);\r\n      Y3 = Fp.mul(b3, t2);\r\n      Y3 = Fp.add(X3, Y3); // step 10\r\n      X3 = Fp.sub(t1, Y3);\r\n      Y3 = Fp.add(t1, Y3);\r\n      Y3 = Fp.mul(X3, Y3);\r\n      X3 = Fp.mul(t3, X3);\r\n      Z3 = Fp.mul(b3, Z3); // step 15\r\n      t2 = Fp.mul(a, t2);\r\n      t3 = Fp.sub(t0, t2);\r\n      t3 = Fp.mul(a, t3);\r\n      t3 = Fp.add(t3, Z3);\r\n      Z3 = Fp.add(t0, t0); // step 20\r\n      t0 = Fp.add(Z3, t0);\r\n      t0 = Fp.add(t0, t2);\r\n      t0 = Fp.mul(t0, t3);\r\n      Y3 = Fp.add(Y3, t0);\r\n      t2 = Fp.mul(Y1, Z1); // step 25\r\n      t2 = Fp.add(t2, t2);\r\n      t0 = Fp.mul(t2, t3);\r\n      X3 = Fp.sub(X3, t0);\r\n      Z3 = Fp.mul(t2, t1);\r\n      Z3 = Fp.add(Z3, Z3); // step 30\r\n      Z3 = Fp.add(Z3, Z3);\r\n      return new Point(X3, Y3, Z3);\r\n    }\r\n\r\n    // Renes-Costello-Batina exception-free addition formula.\r\n    // There is 30% faster Jacobian formula, but it is not complete.\r\n    // https://eprint.iacr.org/2015/1060, algorithm 1\r\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\r\n    add(other: Point): Point {\r\n      assertPrjPoint(other);\r\n      const { px: X1, py: Y1, pz: Z1 } = this;\r\n      const { px: X2, py: Y2, pz: Z2 } = other;\r\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\r\n      const a = CURVE.a;\r\n      const b3 = Fp.mul(CURVE.b, _3n);\r\n      let t0 = Fp.mul(X1, X2); // step 1\r\n      let t1 = Fp.mul(Y1, Y2);\r\n      let t2 = Fp.mul(Z1, Z2);\r\n      let t3 = Fp.add(X1, Y1);\r\n      let t4 = Fp.add(X2, Y2); // step 5\r\n      t3 = Fp.mul(t3, t4);\r\n      t4 = Fp.add(t0, t1);\r\n      t3 = Fp.sub(t3, t4);\r\n      t4 = Fp.add(X1, Z1);\r\n      let t5 = Fp.add(X2, Z2); // step 10\r\n      t4 = Fp.mul(t4, t5);\r\n      t5 = Fp.add(t0, t2);\r\n      t4 = Fp.sub(t4, t5);\r\n      t5 = Fp.add(Y1, Z1);\r\n      X3 = Fp.add(Y2, Z2); // step 15\r\n      t5 = Fp.mul(t5, X3);\r\n      X3 = Fp.add(t1, t2);\r\n      t5 = Fp.sub(t5, X3);\r\n      Z3 = Fp.mul(a, t4);\r\n      X3 = Fp.mul(b3, t2); // step 20\r\n      Z3 = Fp.add(X3, Z3);\r\n      X3 = Fp.sub(t1, Z3);\r\n      Z3 = Fp.add(t1, Z3);\r\n      Y3 = Fp.mul(X3, Z3);\r\n      t1 = Fp.add(t0, t0); // step 25\r\n      t1 = Fp.add(t1, t0);\r\n      t2 = Fp.mul(a, t2);\r\n      t4 = Fp.mul(b3, t4);\r\n      t1 = Fp.add(t1, t2);\r\n      t2 = Fp.sub(t0, t2); // step 30\r\n      t2 = Fp.mul(a, t2);\r\n      t4 = Fp.add(t4, t2);\r\n      t0 = Fp.mul(t1, t4);\r\n      Y3 = Fp.add(Y3, t0);\r\n      t0 = Fp.mul(t5, t4); // step 35\r\n      X3 = Fp.mul(t3, X3);\r\n      X3 = Fp.sub(X3, t0);\r\n      t0 = Fp.mul(t3, t1);\r\n      Z3 = Fp.mul(t5, Z3);\r\n      Z3 = Fp.add(Z3, t0); // step 40\r\n      return new Point(X3, Y3, Z3);\r\n    }\r\n\r\n    subtract(other: Point) {\r\n      return this.add(other.negate());\r\n    }\r\n\r\n    is0() {\r\n      return this.equals(Point.ZERO);\r\n    }\r\n    private wNAF(n: bigint): { p: Point; f: Point } {\r\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\r\n    }\r\n\r\n    /**\r\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\r\n     * It's faster, but should only be used when you don't care about\r\n     * an exposed private key e.g. sig verification, which works over *public* keys.\r\n     */\r\n    multiplyUnsafe(sc: bigint): Point {\r\n      ut.aInRange('scalar', sc, _0n, CURVE.n);\r\n      const I = Point.ZERO;\r\n      if (sc === _0n) return I;\r\n      if (sc === _1n) return this;\r\n      const { endo } = CURVE;\r\n      if (!endo) return wnaf.unsafeLadder(this, sc);\r\n\r\n      // Apply endomorphism\r\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\r\n      let k1p = I;\r\n      let k2p = I;\r\n      let d: Point = this;\r\n      while (k1 > _0n || k2 > _0n) {\r\n        if (k1 & _1n) k1p = k1p.add(d);\r\n        if (k2 & _1n) k2p = k2p.add(d);\r\n        d = d.double();\r\n        k1 >>= _1n;\r\n        k2 >>= _1n;\r\n      }\r\n      if (k1neg) k1p = k1p.negate();\r\n      if (k2neg) k2p = k2p.negate();\r\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\r\n      return k1p.add(k2p);\r\n    }\r\n\r\n    /**\r\n     * Constant time multiplication.\r\n     * Uses wNAF method. Windowed method may be 10% faster,\r\n     * but takes 2x longer to generate and consumes 2x memory.\r\n     * Uses precomputes when available.\r\n     * Uses endomorphism for Koblitz curves.\r\n     * @param scalar by which the point would be multiplied\r\n     * @returns New point\r\n     */\r\n    multiply(scalar: bigint): Point {\r\n      const { endo, n: N } = CURVE;\r\n      ut.aInRange('scalar', scalar, _1n, N);\r\n      let point: Point, fake: Point; // Fake point is used to const-time mult\r\n      if (endo) {\r\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\r\n        let { p: k1p, f: f1p } = this.wNAF(k1);\r\n        let { p: k2p, f: f2p } = this.wNAF(k2);\r\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\r\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\r\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\r\n        point = k1p.add(k2p);\r\n        fake = f1p.add(f2p);\r\n      } else {\r\n        const { p, f } = this.wNAF(scalar);\r\n        point = p;\r\n        fake = f;\r\n      }\r\n      // Normalize `z` for both points, but return only real one\r\n      return Point.normalizeZ([point, fake])[0];\r\n    }\r\n\r\n    /**\r\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\r\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\r\n     * The trick could be useful if both P and Q are not G (not in our case).\r\n     * @returns non-zero affine point\r\n     */\r\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\r\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\r\n      const mul = (\r\n        P: Point,\r\n        a: bigint // Select faster multiply() method\r\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\r\n      const sum = mul(this, a).add(mul(Q, b));\r\n      return sum.is0() ? undefined : sum;\r\n    }\r\n\r\n    // Converts Projective point to affine (x, y) coordinates.\r\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\r\n    // (x, y, z) ∋ (x=x/z, y=y/z)\r\n    toAffine(iz?: T): AffinePoint<T> {\r\n      return toAffineMemo(this, iz);\r\n    }\r\n    isTorsionFree(): boolean {\r\n      const { h: cofactor, isTorsionFree } = CURVE;\r\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\r\n      if (isTorsionFree) return isTorsionFree(Point, this);\r\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\r\n    }\r\n    clearCofactor(): Point {\r\n      const { h: cofactor, clearCofactor } = CURVE;\r\n      if (cofactor === _1n) return this; // Fast-path\r\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\r\n      return this.multiplyUnsafe(CURVE.h);\r\n    }\r\n\r\n    toRawBytes(isCompressed = true): Uint8Array {\r\n      abool('isCompressed', isCompressed);\r\n      this.assertValidity();\r\n      return toBytes(Point, this, isCompressed);\r\n    }\r\n\r\n    toHex(isCompressed = true): string {\r\n      abool('isCompressed', isCompressed);\r\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\r\n    }\r\n  }\r\n  const _bits = CURVE.nBitLength;\r\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\r\n  // Validate if generator point is on curve\r\n  return {\r\n    CURVE,\r\n    ProjectivePoint: Point as ProjConstructor<T>,\r\n    normPrivateKeyToScalar,\r\n    weierstrassEquation,\r\n    isWithinCurveOrder,\r\n  };\r\n}\r\n\r\n// Instance\r\nexport interface SignatureType {\r\n  readonly r: bigint;\r\n  readonly s: bigint;\r\n  readonly recovery?: number;\r\n  assertValidity(): void;\r\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\r\n  hasHighS(): boolean;\r\n  normalizeS(): SignatureType;\r\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\r\n  toCompactRawBytes(): Uint8Array;\r\n  toCompactHex(): string;\r\n  // DER-encoded\r\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\r\n  toDERHex(isCompressed?: boolean): string;\r\n}\r\nexport type RecoveredSignatureType = SignatureType & {\r\n  readonly recovery: number;\r\n};\r\n// Static methods\r\nexport type SignatureConstructor = {\r\n  new (r: bigint, s: bigint): SignatureType;\r\n  fromCompact(hex: Hex): SignatureType;\r\n  fromDER(hex: Hex): SignatureType;\r\n};\r\ntype SignatureLike = { r: bigint; s: bigint };\r\n\r\nexport type PubKey = Hex | ProjPointType<bigint>;\r\n\r\nexport type CurveType = BasicWCurve<bigint> & {\r\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\r\n  hmac: HmacFnSync;\r\n  randomBytes: (bytesLength?: number) => Uint8Array;\r\n  lowS?: boolean;\r\n  bits2int?: (bytes: Uint8Array) => bigint;\r\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\r\n};\r\n\r\nfunction validateOpts(curve: CurveType) {\r\n  const opts = validateBasic(curve);\r\n  ut.validateObject(\r\n    opts,\r\n    {\r\n      hash: 'hash',\r\n      hmac: 'function',\r\n      randomBytes: 'function',\r\n    },\r\n    {\r\n      bits2int: 'function',\r\n      bits2int_modN: 'function',\r\n      lowS: 'boolean',\r\n    }\r\n  );\r\n  return Object.freeze({ lowS: true, ...opts } as const);\r\n}\r\n\r\nexport type CurveFn = {\r\n  CURVE: ReturnType<typeof validateOpts>;\r\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\r\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\r\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\r\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\r\n  ProjectivePoint: ProjConstructor<bigint>;\r\n  Signature: SignatureConstructor;\r\n  utils: {\r\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\r\n    isValidPrivateKey(privateKey: PrivKey): boolean;\r\n    randomPrivateKey: () => Uint8Array;\r\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\r\n  };\r\n};\r\n\r\n/**\r\n * Creates short weierstrass curve and ECDSA signature methods for it.\r\n * @example\r\n * import { Field } from '@noble/curves/abstract/modular';\r\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\r\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\r\n */\r\nexport function weierstrass(curveDef: CurveType): CurveFn {\r\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\r\n  const { Fp, n: CURVE_ORDER } = CURVE;\r\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\r\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\r\n\r\n  function modN(a: bigint) {\r\n    return mod.mod(a, CURVE_ORDER);\r\n  }\r\n  function invN(a: bigint) {\r\n    return mod.invert(a, CURVE_ORDER);\r\n  }\r\n\r\n  const {\r\n    ProjectivePoint: Point,\r\n    normPrivateKeyToScalar,\r\n    weierstrassEquation,\r\n    isWithinCurveOrder,\r\n  } = weierstrassPoints({\r\n    ...CURVE,\r\n    toBytes(_c, point, isCompressed: boolean): Uint8Array {\r\n      const a = point.toAffine();\r\n      const x = Fp.toBytes(a.x);\r\n      const cat = ut.concatBytes;\r\n      abool('isCompressed', isCompressed);\r\n      if (isCompressed) {\r\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\r\n      } else {\r\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\r\n      }\r\n    },\r\n    fromBytes(bytes: Uint8Array) {\r\n      const len = bytes.length;\r\n      const head = bytes[0];\r\n      const tail = bytes.subarray(1);\r\n      // this.assertValidity() is done inside of fromHex\r\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\r\n        const x = ut.bytesToNumberBE(tail);\r\n        if (!ut.inRange(x, _1n, Fp.ORDER)) throw new Error('Point is not on curve');\r\n        const y2 = weierstrassEquation(x); // y² = x³ + ax + b\r\n        let y: bigint;\r\n        try {\r\n          y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\r\n        } catch (sqrtError) {\r\n          const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\r\n          throw new Error('Point is not on curve' + suffix);\r\n        }\r\n        const isYOdd = (y & _1n) === _1n;\r\n        // ECDSA\r\n        const isHeadOdd = (head & 1) === 1;\r\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\r\n        return { x, y };\r\n      } else if (len === uncompressedLen && head === 0x04) {\r\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\r\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\r\n        return { x, y };\r\n      } else {\r\n        throw new Error(\r\n          `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`\r\n        );\r\n      }\r\n    },\r\n  });\r\n  const numToNByteStr = (num: bigint): string =>\r\n    ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\r\n\r\n  function isBiggerThanHalfOrder(number: bigint) {\r\n    const HALF = CURVE_ORDER >> _1n;\r\n    return number > HALF;\r\n  }\r\n\r\n  function normalizeS(s: bigint) {\r\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\r\n  }\r\n  // slice bytes num\r\n  const slcNum = (b: Uint8Array, from: number, to: number) => ut.bytesToNumberBE(b.slice(from, to));\r\n\r\n  /**\r\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\r\n   */\r\n  class Signature implements SignatureType {\r\n    constructor(\r\n      readonly r: bigint,\r\n      readonly s: bigint,\r\n      readonly recovery?: number\r\n    ) {\r\n      this.assertValidity();\r\n    }\r\n\r\n    // pair (bytes of r, bytes of s)\r\n    static fromCompact(hex: Hex) {\r\n      const l = CURVE.nByteLength;\r\n      hex = ensureBytes('compactSignature', hex, l * 2);\r\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\r\n    }\r\n\r\n    // DER encoded ECDSA signature\r\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\r\n    static fromDER(hex: Hex) {\r\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\r\n      return new Signature(r, s);\r\n    }\r\n\r\n    assertValidity(): void {\r\n      ut.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\r\n      ut.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\r\n    }\r\n\r\n    addRecoveryBit(recovery: number): RecoveredSignature {\r\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\r\n    }\r\n\r\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\r\n      const { r, s, recovery: rec } = this;\r\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\r\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\r\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\r\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\r\n      const prefix = (rec & 1) === 0 ? '02' : '03';\r\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\r\n      const ir = invN(radj); // r^-1\r\n      const u1 = modN(-h * ir); // -hr^-1\r\n      const u2 = modN(s * ir); // sr^-1\r\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\r\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\r\n      Q.assertValidity();\r\n      return Q;\r\n    }\r\n\r\n    // Signatures should be low-s, to prevent malleability.\r\n    hasHighS(): boolean {\r\n      return isBiggerThanHalfOrder(this.s);\r\n    }\r\n\r\n    normalizeS() {\r\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\r\n    }\r\n\r\n    // DER-encoded\r\n    toDERRawBytes() {\r\n      return ut.hexToBytes(this.toDERHex());\r\n    }\r\n    toDERHex() {\r\n      return DER.hexFromSig({ r: this.r, s: this.s });\r\n    }\r\n\r\n    // padded bytes of r, then padded bytes of s\r\n    toCompactRawBytes() {\r\n      return ut.hexToBytes(this.toCompactHex());\r\n    }\r\n    toCompactHex() {\r\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\r\n    }\r\n  }\r\n  type RecoveredSignature = Signature & { recovery: number };\r\n\r\n  const utils = {\r\n    isValidPrivateKey(privateKey: PrivKey) {\r\n      try {\r\n        normPrivateKeyToScalar(privateKey);\r\n        return true;\r\n      } catch (error) {\r\n        return false;\r\n      }\r\n    },\r\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\r\n\r\n    /**\r\n     * Produces cryptographically secure private key from random of size\r\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\r\n     */\r\n    randomPrivateKey: (): Uint8Array => {\r\n      const length = mod.getMinHashLength(CURVE.n);\r\n      return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\r\n    },\r\n\r\n    /**\r\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\r\n     * Allows to massively speed-up `point.multiply(scalar)`.\r\n     * @returns cached point\r\n     * @example\r\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\r\n     * fast.multiply(privKey); // much faster ECDH now\r\n     */\r\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\r\n      point._setWindowSize(windowSize);\r\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\r\n      return point;\r\n    },\r\n  };\r\n\r\n  /**\r\n   * Computes public key for a private key. Checks for validity of the private key.\r\n   * @param privateKey private key\r\n   * @param isCompressed whether to return compact (default), or full key\r\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\r\n   */\r\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\r\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\r\n  }\r\n\r\n  /**\r\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\r\n   */\r\n  function isProbPub(item: PrivKey | PubKey): boolean {\r\n    const arr = ut.isBytes(item);\r\n    const str = typeof item === 'string';\r\n    const len = (arr || str) && (item as Hex).length;\r\n    if (arr) return len === compressedLen || len === uncompressedLen;\r\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\r\n    if (item instanceof Point) return true;\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * ECDH (Elliptic Curve Diffie Hellman).\r\n   * Computes shared public key from private key and public key.\r\n   * Checks: 1) private key validity 2) shared key is on-curve.\r\n   * Does NOT hash the result.\r\n   * @param privateA private key\r\n   * @param publicB different public key\r\n   * @param isCompressed whether to return compact (default), or full key\r\n   * @returns shared public key\r\n   */\r\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\r\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\r\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\r\n    const b = Point.fromHex(publicB); // check for being on-curve\r\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\r\n  }\r\n\r\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\r\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\r\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\r\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\r\n  const bits2int =\r\n    CURVE.bits2int ||\r\n    function (bytes: Uint8Array): bigint {\r\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\r\n      // for some cases, since bytes.length * 8 is not actual bitLength.\r\n      const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\r\n      const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\r\n      return delta > 0 ? num >> BigInt(delta) : num;\r\n    };\r\n  const bits2int_modN =\r\n    CURVE.bits2int_modN ||\r\n    function (bytes: Uint8Array): bigint {\r\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\r\n    };\r\n  // NOTE: pads output with zero as per spec\r\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\r\n  /**\r\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\r\n   */\r\n  function int2octets(num: bigint): Uint8Array {\r\n    ut.aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n, ORDER_MASK);\r\n    // works with order, can have different size than numToField!\r\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\r\n  }\r\n\r\n  // Steps A, D of RFC6979 3.2\r\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\r\n  // Used only in sign, not in verify.\r\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\r\n  // Also it can be bigger for P224 + SHA256\r\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\r\n    if (['recovered', 'canonical'].some((k) => k in opts))\r\n      throw new Error('sign() legacy options not supported');\r\n    const { hash, randomBytes } = CURVE;\r\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\r\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\r\n    msgHash = ensureBytes('msgHash', msgHash);\r\n    validateSigVerOpts(opts);\r\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\r\n\r\n    // We can't later call bits2octets, since nested bits2int is broken for curves\r\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\r\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\r\n    const h1int = bits2int_modN(msgHash);\r\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\r\n    const seedArgs = [int2octets(d), int2octets(h1int)];\r\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\r\n    if (ent != null && ent !== false) {\r\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\r\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\r\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\r\n    }\r\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\r\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\r\n    // Converts signature params into point w r/s, checks result for validity.\r\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\r\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\r\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\r\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\r\n      const ik = invN(k); // k^-1 mod n\r\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\r\n      const r = modN(q.x); // r = q.x mod n\r\n      if (r === _0n) return;\r\n      // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\r\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\r\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\r\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\r\n      if (s === _0n) return;\r\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\r\n      let normS = s;\r\n      if (lowS && isBiggerThanHalfOrder(s)) {\r\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\r\n        recovery ^= 1; // // in the bottom half of N\r\n      }\r\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\r\n    }\r\n    return { seed, k2sig };\r\n  }\r\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\r\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\r\n\r\n  /**\r\n   * Signs message hash with a private key.\r\n   * ```\r\n   * sign(m, d, k) where\r\n   *   (x, y) = G × k\r\n   *   r = x mod n\r\n   *   s = (m + dr)/k mod n\r\n   * ```\r\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\r\n   * @param privKey private key\r\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\r\n   * @returns signature with recovery param\r\n   */\r\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\r\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\r\n    const C = CURVE;\r\n    const drbg = ut.createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\r\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\r\n  }\r\n\r\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\r\n  Point.BASE._setWindowSize(8);\r\n  // utils.precompute(8, ProjectivePoint.BASE)\r\n\r\n  /**\r\n   * Verifies a signature against message hash and public key.\r\n   * Rejects lowS signatures by default: to override,\r\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\r\n   *\r\n   * ```\r\n   * verify(r, s, h, P) where\r\n   *   U1 = hs^-1 mod n\r\n   *   U2 = rs^-1 mod n\r\n   *   R = U1⋅G - U2⋅P\r\n   *   mod(R.x, n) == r\r\n   * ```\r\n   */\r\n  function verify(\r\n    signature: Hex | SignatureLike,\r\n    msgHash: Hex,\r\n    publicKey: Hex,\r\n    opts = defaultVerOpts\r\n  ): boolean {\r\n    const sg = signature;\r\n    msgHash = ensureBytes('msgHash', msgHash);\r\n    publicKey = ensureBytes('publicKey', publicKey);\r\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\r\n    validateSigVerOpts(opts);\r\n    const { lowS, prehash } = opts;\r\n\r\n    let _sig: Signature | undefined = undefined;\r\n    let P: ProjPointType<bigint>;\r\n    try {\r\n      if (typeof sg === 'string' || ut.isBytes(sg)) {\r\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\r\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\r\n        try {\r\n          _sig = Signature.fromDER(sg);\r\n        } catch (derError) {\r\n          if (!(derError instanceof DER.Err)) throw derError;\r\n          _sig = Signature.fromCompact(sg);\r\n        }\r\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\r\n        const { r, s } = sg;\r\n        _sig = new Signature(r, s);\r\n      } else {\r\n        throw new Error('PARSE');\r\n      }\r\n      P = Point.fromHex(publicKey);\r\n    } catch (error) {\r\n      if ((error as Error).message === 'PARSE')\r\n        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\r\n      return false;\r\n    }\r\n    if (lowS && _sig.hasHighS()) return false;\r\n    if (prehash) msgHash = CURVE.hash(msgHash);\r\n    const { r, s } = _sig;\r\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\r\n    const is = invN(s); // s^-1\r\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\r\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\r\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\r\n    if (!R) return false;\r\n    const v = modN(R.x);\r\n    return v === r;\r\n  }\r\n  return {\r\n    CURVE,\r\n    getPublicKey,\r\n    getSharedSecret,\r\n    sign,\r\n    verify,\r\n    ProjectivePoint: Point,\r\n    Signature,\r\n    utils,\r\n  };\r\n}\r\n\r\n/**\r\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\r\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\r\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\r\n * b = False and y = sqrt(Z * (u / v)) otherwise.\r\n * @param Fp\r\n * @param Z\r\n * @returns\r\n */\r\nexport function SWUFpSqrtRatio<T>(Fp: mod.IField<T>, Z: T) {\r\n  // Generic implementation\r\n  const q = Fp.ORDER;\r\n  let l = _0n;\r\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\r\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\r\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\r\n  // 2n ** c1 == 2n << (c1-1)\r\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\r\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\r\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\r\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\r\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\r\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\r\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\r\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\r\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\r\n    let tv1 = c6; // 1. tv1 = c6\r\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\r\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\r\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\r\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\r\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\r\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\r\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\r\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\r\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\r\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\r\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\r\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\r\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\r\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\r\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\r\n    // 17. for i in (c1, c1 - 1, ..., 2):\r\n    for (let i = c1; i > _1n; i--) {\r\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\r\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\r\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\r\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\r\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\r\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\r\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\r\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\r\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\r\n    }\r\n    return { isValid: isQR, value: tv3 };\r\n  };\r\n  if (Fp.ORDER % _4n === _3n) {\r\n    // sqrt_ratio_3mod4(u, v)\r\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\r\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\r\n    sqrtRatio = (u: T, v: T) => {\r\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\r\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\r\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\r\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\r\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\r\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\r\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\r\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\r\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\r\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\r\n    };\r\n  }\r\n  // No curves uses that\r\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\r\n  return sqrtRatio;\r\n}\r\n/**\r\n * Simplified Shallue-van de Woestijne-Ulas Method\r\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\r\n */\r\nexport function mapToCurveSimpleSWU<T>(\r\n  Fp: mod.IField<T>,\r\n  opts: {\r\n    A: T;\r\n    B: T;\r\n    Z: T;\r\n  }\r\n) {\r\n  mod.validateField(Fp);\r\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\r\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\r\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\r\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\r\n  // Input: u, an element of F.\r\n  // Output: (x, y), a point on E.\r\n  return (u: T): { x: T; y: T } => {\r\n    // prettier-ignore\r\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\r\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\r\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\r\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\r\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\r\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\r\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\r\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\r\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\r\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\r\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\r\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\r\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\r\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\r\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\r\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\r\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\r\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\r\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\r\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\r\n    y = Fp.mul(y, value); // 20.   y = y * y1\r\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\r\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\r\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\r\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\r\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\r\n    return { x, y };\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}