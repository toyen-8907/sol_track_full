{"ast":null,"code":"import { Field, unpack } from '@solana/spl-token-metadata';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nimport { getMint } from '../../state/mint.js';\nconst getNormalizedTokenMetadataField = field => {\n  if (field === Field.Name || field === 'Name' || field === 'name') {\n    return 'name';\n  }\n  if (field === Field.Symbol || field === 'Symbol' || field === 'symbol') {\n    return 'symbol';\n  }\n  if (field === Field.Uri || field === 'Uri' || field === 'uri') {\n    return 'uri';\n  }\n  return field;\n};\nexport function updateTokenMetadata(current, key, value) {\n  const field = getNormalizedTokenMetadataField(key);\n  if (field === 'mint' || field === 'updateAuthority') {\n    throw new Error(`Cannot update ${field} via this instruction`);\n  }\n  // Handle updates to default keys\n  if (['name', 'symbol', 'uri'].includes(field)) {\n    return {\n      ...current,\n      [field]: value\n    };\n  }\n  // Avoid mutating input, make a shallow copy\n  const additionalMetadata = [...current.additionalMetadata];\n  const i = current.additionalMetadata.findIndex(x => x[0] === field);\n  if (i === -1) {\n    // Key was not found, add it\n    additionalMetadata.push([field, value]);\n  } else {\n    // Key was found, change value\n    additionalMetadata[i] = [field, value];\n  }\n  return {\n    ...current,\n    additionalMetadata\n  };\n}\n/**\n * Retrieve Token Metadata Information\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token Metadata information\n */\nexport async function getTokenMetadata(connection, address, commitment, programId = TOKEN_2022_PROGRAM_ID) {\n  const mintInfo = await getMint(connection, address, commitment, programId);\n  const data = getExtensionData(ExtensionType.TokenMetadata, mintInfo.tlvData);\n  if (data === null) {\n    return null;\n  }\n  return unpack(data);\n}","map":{"version":3,"names":["Field","unpack","TOKEN_2022_PROGRAM_ID","ExtensionType","getExtensionData","getMint","getNormalizedTokenMetadataField","field","Name","Symbol","Uri","updateTokenMetadata","current","key","value","Error","includes","additionalMetadata","i","findIndex","x","push","getTokenMetadata","connection","address","commitment","programId","mintInfo","data","TokenMetadata","tlvData"],"sources":["/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token/src/extensions/tokenMetadata/state.ts"],"sourcesContent":["import type { Commitment, Connection } from '@solana/web3.js';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { TokenMetadata } from '@solana/spl-token-metadata';\nimport { Field, unpack } from '@solana/spl-token-metadata';\n\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nimport { getMint } from '../../state/mint.js';\n\nconst getNormalizedTokenMetadataField = (field: Field | string): string => {\n    if (field === Field.Name || field === 'Name' || field === 'name') {\n        return 'name';\n    }\n\n    if (field === Field.Symbol || field === 'Symbol' || field === 'symbol') {\n        return 'symbol';\n    }\n\n    if (field === Field.Uri || field === 'Uri' || field === 'uri') {\n        return 'uri';\n    }\n\n    return field;\n};\n\nexport function updateTokenMetadata(current: TokenMetadata, key: Field | string, value: string): TokenMetadata {\n    const field = getNormalizedTokenMetadataField(key);\n\n    if (field === 'mint' || field === 'updateAuthority') {\n        throw new Error(`Cannot update ${field} via this instruction`);\n    }\n\n    // Handle updates to default keys\n    if (['name', 'symbol', 'uri'].includes(field)) {\n        return {\n            ...current,\n            [field]: value,\n        };\n    }\n\n    // Avoid mutating input, make a shallow copy\n    const additionalMetadata = [...current.additionalMetadata];\n\n    const i = current.additionalMetadata.findIndex(x => x[0] === field);\n\n    if (i === -1) {\n        // Key was not found, add it\n        additionalMetadata.push([field, value]);\n    } else {\n        // Key was found, change value\n        additionalMetadata[i] = [field, value];\n    }\n\n    return {\n        ...current,\n        additionalMetadata,\n    };\n}\n\n/**\n * Retrieve Token Metadata Information\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token Metadata information\n */\nexport async function getTokenMetadata(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TokenMetadata | null> {\n    const mintInfo = await getMint(connection, address, commitment, programId);\n    const data = getExtensionData(ExtensionType.TokenMetadata, mintInfo.tlvData);\n\n    if (data === null) {\n        return null;\n    }\n\n    return unpack(data);\n}\n"],"mappings":"AAGA,SAASA,KAAK,EAAEC,MAAM,QAAQ,4BAA4B;AAE1D,SAASC,qBAAqB,QAAQ,oBAAoB;AAC1D,SAASC,aAAa,EAAEC,gBAAgB,QAAQ,qBAAqB;AACrE,SAASC,OAAO,QAAQ,qBAAqB;AAE7C,MAAMC,+BAA+B,GAAIC,KAAqB,IAAY;EACtE,IAAIA,KAAK,KAAKP,KAAK,CAACQ,IAAI,IAAID,KAAK,KAAK,MAAM,IAAIA,KAAK,KAAK,MAAM,EAAE;IAC9D,OAAO,MAAM;EACjB;EAEA,IAAIA,KAAK,KAAKP,KAAK,CAACS,MAAM,IAAIF,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,QAAQ,EAAE;IACpE,OAAO,QAAQ;EACnB;EAEA,IAAIA,KAAK,KAAKP,KAAK,CAACU,GAAG,IAAIH,KAAK,KAAK,KAAK,IAAIA,KAAK,KAAK,KAAK,EAAE;IAC3D,OAAO,KAAK;EAChB;EAEA,OAAOA,KAAK;AAChB,CAAC;AAED,OAAM,SAAUI,mBAAmBA,CAACC,OAAsB,EAAEC,GAAmB,EAAEC,KAAa;EAC1F,MAAMP,KAAK,GAAGD,+BAA+B,CAACO,GAAG,CAAC;EAElD,IAAIN,KAAK,KAAK,MAAM,IAAIA,KAAK,KAAK,iBAAiB,EAAE;IACjD,MAAM,IAAIQ,KAAK,CAAC,iBAAiBR,KAAK,uBAAuB,CAAC;EAClE;EAEA;EACA,IAAI,CAAC,MAAM,EAAE,QAAQ,EAAE,KAAK,CAAC,CAACS,QAAQ,CAACT,KAAK,CAAC,EAAE;IAC3C,OAAO;MACH,GAAGK,OAAO;MACV,CAACL,KAAK,GAAGO;KACZ;EACL;EAEA;EACA,MAAMG,kBAAkB,GAAG,CAAC,GAAGL,OAAO,CAACK,kBAAkB,CAAC;EAE1D,MAAMC,CAAC,GAAGN,OAAO,CAACK,kBAAkB,CAACE,SAAS,CAACC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,KAAKb,KAAK,CAAC;EAEnE,IAAIW,CAAC,KAAK,CAAC,CAAC,EAAE;IACV;IACAD,kBAAkB,CAACI,IAAI,CAAC,CAACd,KAAK,EAAEO,KAAK,CAAC,CAAC;EAC3C,CAAC,MAAM;IACH;IACAG,kBAAkB,CAACC,CAAC,CAAC,GAAG,CAACX,KAAK,EAAEO,KAAK,CAAC;EAC1C;EAEA,OAAO;IACH,GAAGF,OAAO;IACVK;GACH;AACL;AAEA;;;;;;;;;;AAUA,OAAO,eAAeK,gBAAgBA,CAClCC,UAAsB,EACtBC,OAAkB,EAClBC,UAAuB,EACvBC,SAAS,GAAGxB,qBAAqB;EAEjC,MAAMyB,QAAQ,GAAG,MAAMtB,OAAO,CAACkB,UAAU,EAAEC,OAAO,EAAEC,UAAU,EAAEC,SAAS,CAAC;EAC1E,MAAME,IAAI,GAAGxB,gBAAgB,CAACD,aAAa,CAAC0B,aAAa,EAAEF,QAAQ,CAACG,OAAO,CAAC;EAE5E,IAAIF,IAAI,KAAK,IAAI,EAAE;IACf,OAAO,IAAI;EACf;EAEA,OAAO3B,MAAM,CAAC2B,IAAI,CAAC;AACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}