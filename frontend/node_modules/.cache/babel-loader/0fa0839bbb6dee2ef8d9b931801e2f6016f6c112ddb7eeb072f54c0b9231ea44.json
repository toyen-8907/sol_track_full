{"ast":null,"code":"/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */BigInt(0);\nconst _1n = /* @__PURE__ */BigInt(1);\nconst _2n = /* @__PURE__ */BigInt(2);\nexport function isBytes(a) {\n  return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';\n}\nexport function abytes(item) {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\nexport function abool(title, value) {\n  if (typeof value !== 'boolean') throw new Error(`${title} must be valid boolean, got \"${value}\".`);\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */Array.from({\n  length: 256\n}, (_, i) => i.toString(16).padStart(2, '0'));\n/**\r\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\r\n */\nexport function bytesToHex(bytes) {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\nexport function numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\nexport function hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n  _0: 48,\n  _9: 57,\n  _A: 65,\n  _F: 70,\n  _a: 97,\n  _f: 102\n};\nfunction asciiToBase16(char) {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n/**\r\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\r\n */\nexport function hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n/**\r\n * Takes hex string or Uint8Array, converts to Uint8Array.\r\n * Validates output length.\r\n * Will throw error for other types.\r\n * @param title descriptive title for an error e.g. 'private key'\r\n * @param hex hex string or Uint8Array\r\n * @param expectedLength optional, will compare to result array's length\r\n * @returns\r\n */\nexport function ensureBytes(title, hex, expectedLength) {\n  let res;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n/**\r\n * Copies several Uint8Arrays into one.\r\n */\nexport function concatBytes(...arrays) {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n/**\r\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\r\n */\nexport function utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = n => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\r\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\r\n * @example\r\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\r\n */\nexport function aInRange(title, n, min, max) {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max)) throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);\n}\n// Bit operations\n/**\r\n * Calculates amount of bits in a bigint.\r\n * Same as `n.toString(2).length`\r\n */\nexport function bitLen(n) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n/**\r\n * Gets single bit at position.\r\n * NOTE: first bit position is 0 (same as arrays)\r\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\r\n */\nexport function bitGet(n, pos) {\n  return n >> BigInt(pos) & _1n;\n}\n/**\r\n * Sets single bit at position.\r\n */\nexport function bitSet(n, pos, value) {\n  return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\r\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\r\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\r\n */\nexport const bitMask = n => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = data => new Uint8Array(data); // creates Uint8Array\nconst u8fr = arr => Uint8Array.from(arr); // another shortcut\n/**\r\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\r\n * @returns function that will call DRBG until 2nd arg returns something meaningful\r\n * @example\r\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\r\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\r\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed, pred) => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n  bigint: val => typeof val === 'bigint',\n  function: val => typeof val === 'function',\n  boolean: val => typeof val === 'boolean',\n  string: val => typeof val === 'string',\n  stringOrUint8Array: val => typeof val === 'string' || isBytes(val),\n  isSafeInteger: val => Number.isSafeInteger(val),\n  array: val => Array.isArray(val),\n  field: (val, object) => object.Fp.isValid(val),\n  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n  const checkField = (fieldName, type, isOptional) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error(`Invalid validator \"${type}\", expected function`);\n    const val = object[fieldName];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\r\n * throws not implemented error\r\n */\nexport const notImplemented = () => {\n  throw new Error('not implemented');\n};\n/**\r\n * Memoizes (caches) computation result.\r\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\r\n */\nexport function memoized(fn) {\n  const map = new WeakMap();\n  return (arg, ...args) => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}","map":{"version":3,"names":["_0n","BigInt","_1n","_2n","isBytes","a","Uint8Array","constructor","name","abytes","item","Error","abool","title","value","hexes","Array","from","length","_","i","toString","padStart","bytesToHex","bytes","hex","numberToHexUnpadded","num","hexToNumber","asciis","_0","_9","_A","_F","_a","_f","asciiToBase16","char","hexToBytes","hl","al","array","ai","hi","n1","charCodeAt","n2","undefined","bytesToNumberBE","bytesToNumberLE","reverse","numberToBytesBE","n","len","numberToBytesLE","numberToVarBytesBE","ensureBytes","expectedLength","res","e","concatBytes","arrays","sum","pad","set","equalBytes","b","diff","utf8ToBytes","str","TextEncoder","encode","isPosBig","inRange","min","max","aInRange","bitLen","bitGet","pos","bitSet","bitMask","u8n","data","u8fr","arr","createHmacDrbg","hashLen","qByteLen","hmacFn","v","k","reset","fill","h","reseed","seed","gen","out","sl","slice","push","genUntil","pred","validatorFns","bigint","val","function","boolean","string","stringOrUint8Array","isSafeInteger","Number","isArray","field","object","Fp","isValid","hash","outputLen","validateObject","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","Object","entries","notImplemented","memoized","fn","map","WeakMap","arg","args","get","computed"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@noble\\curves\\src\\abstract\\utils.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\r\n// This is OK: `abstract` directory does not use noble-hashes.\r\n// User may opt-in into using different hashing library. This way, noble-hashes\r\n// won't be included into their bundle.\r\nconst _0n = /* @__PURE__ */ BigInt(0);\r\nconst _1n = /* @__PURE__ */ BigInt(1);\r\nconst _2n = /* @__PURE__ */ BigInt(2);\r\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\r\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\r\nexport type CHash = {\r\n  (message: Uint8Array | string): Uint8Array;\r\n  blockLen: number;\r\n  outputLen: number;\r\n  create(opts?: { dkLen?: number }): any; // For shake\r\n};\r\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\r\n\r\nexport function isBytes(a: unknown): a is Uint8Array {\r\n  return (\r\n    a instanceof Uint8Array ||\r\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\r\n  );\r\n}\r\n\r\nexport function abytes(item: unknown): void {\r\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\r\n}\r\n\r\nexport function abool(title: string, value: boolean): void {\r\n  if (typeof value !== 'boolean')\r\n    throw new Error(`${title} must be valid boolean, got \"${value}\".`);\r\n}\r\n\r\n// Array where index 0xf0 (240) is mapped to string 'f0'\r\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\r\n  i.toString(16).padStart(2, '0')\r\n);\r\n/**\r\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\r\n */\r\nexport function bytesToHex(bytes: Uint8Array): string {\r\n  abytes(bytes);\r\n  // pre-caching improves the speed 6x\r\n  let hex = '';\r\n  for (let i = 0; i < bytes.length; i++) {\r\n    hex += hexes[bytes[i]];\r\n  }\r\n  return hex;\r\n}\r\n\r\nexport function numberToHexUnpadded(num: number | bigint): string {\r\n  const hex = num.toString(16);\r\n  return hex.length & 1 ? `0${hex}` : hex;\r\n}\r\n\r\nexport function hexToNumber(hex: string): bigint {\r\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\r\n  // Big Endian\r\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\r\n}\r\n\r\n// We use optimized technique to convert hex string to byte array\r\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\r\nfunction asciiToBase16(char: number): number | undefined {\r\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\r\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\r\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\r\n  return;\r\n}\r\n\r\n/**\r\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\r\n */\r\nexport function hexToBytes(hex: string): Uint8Array {\r\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\r\n  const hl = hex.length;\r\n  const al = hl / 2;\r\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\r\n  const array = new Uint8Array(al);\r\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\r\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\r\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\r\n    if (n1 === undefined || n2 === undefined) {\r\n      const char = hex[hi] + hex[hi + 1];\r\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\r\n    }\r\n    array[ai] = n1 * 16 + n2;\r\n  }\r\n  return array;\r\n}\r\n\r\n// BE: Big Endian, LE: Little Endian\r\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\r\n  return hexToNumber(bytesToHex(bytes));\r\n}\r\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\r\n  abytes(bytes);\r\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\r\n}\r\n\r\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\r\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\r\n}\r\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\r\n  return numberToBytesBE(n, len).reverse();\r\n}\r\n// Unpadded, rarely used\r\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\r\n  return hexToBytes(numberToHexUnpadded(n));\r\n}\r\n\r\n/**\r\n * Takes hex string or Uint8Array, converts to Uint8Array.\r\n * Validates output length.\r\n * Will throw error for other types.\r\n * @param title descriptive title for an error e.g. 'private key'\r\n * @param hex hex string or Uint8Array\r\n * @param expectedLength optional, will compare to result array's length\r\n * @returns\r\n */\r\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\r\n  let res: Uint8Array;\r\n  if (typeof hex === 'string') {\r\n    try {\r\n      res = hexToBytes(hex);\r\n    } catch (e) {\r\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\r\n    }\r\n  } else if (isBytes(hex)) {\r\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\r\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\r\n    res = Uint8Array.from(hex);\r\n  } else {\r\n    throw new Error(`${title} must be hex string or Uint8Array`);\r\n  }\r\n  const len = res.length;\r\n  if (typeof expectedLength === 'number' && len !== expectedLength)\r\n    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\r\n  return res;\r\n}\r\n\r\n/**\r\n * Copies several Uint8Arrays into one.\r\n */\r\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\r\n  let sum = 0;\r\n  for (let i = 0; i < arrays.length; i++) {\r\n    const a = arrays[i];\r\n    abytes(a);\r\n    sum += a.length;\r\n  }\r\n  const res = new Uint8Array(sum);\r\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\r\n    const a = arrays[i];\r\n    res.set(a, pad);\r\n    pad += a.length;\r\n  }\r\n  return res;\r\n}\r\n\r\n// Compares 2 u8a-s in kinda constant time\r\nexport function equalBytes(a: Uint8Array, b: Uint8Array) {\r\n  if (a.length !== b.length) return false;\r\n  let diff = 0;\r\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\r\n  return diff === 0;\r\n}\r\n\r\n// Global symbols in both browsers and Node.js since v11\r\n// See https://github.com/microsoft/TypeScript/issues/31535\r\ndeclare const TextEncoder: any;\r\n\r\n/**\r\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\r\n */\r\nexport function utf8ToBytes(str: string): Uint8Array {\r\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\r\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\r\n}\r\n\r\n// Is positive bigint\r\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\r\n\r\nexport function inRange(n: bigint, min: bigint, max: bigint) {\r\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\r\n}\r\n\r\n/**\r\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\r\n * @example\r\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\r\n */\r\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint) {\r\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\r\n  // consider P=256n, min=0n, max=P\r\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\r\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\r\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\r\n  if (!inRange(n, min, max))\r\n    throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);\r\n}\r\n\r\n// Bit operations\r\n\r\n/**\r\n * Calculates amount of bits in a bigint.\r\n * Same as `n.toString(2).length`\r\n */\r\nexport function bitLen(n: bigint) {\r\n  let len;\r\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\r\n  return len;\r\n}\r\n\r\n/**\r\n * Gets single bit at position.\r\n * NOTE: first bit position is 0 (same as arrays)\r\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\r\n */\r\nexport function bitGet(n: bigint, pos: number) {\r\n  return (n >> BigInt(pos)) & _1n;\r\n}\r\n\r\n/**\r\n * Sets single bit at position.\r\n */\r\nexport function bitSet(n: bigint, pos: number, value: boolean) {\r\n  return n | ((value ? _1n : _0n) << BigInt(pos));\r\n}\r\n\r\n/**\r\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\r\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\r\n */\r\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\r\n\r\n// DRBG\r\n\r\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\r\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\r\ntype Pred<T> = (v: Uint8Array) => T | undefined;\r\n/**\r\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\r\n * @returns function that will call DRBG until 2nd arg returns something meaningful\r\n * @example\r\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\r\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\r\n */\r\nexport function createHmacDrbg<T>(\r\n  hashLen: number,\r\n  qByteLen: number,\r\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\r\n): (seed: Uint8Array, predicate: Pred<T>) => T {\r\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\r\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\r\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\r\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\r\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\r\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\r\n  let i = 0; // Iterations counter, will throw when over 1000\r\n  const reset = () => {\r\n    v.fill(1);\r\n    k.fill(0);\r\n    i = 0;\r\n  };\r\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\r\n  const reseed = (seed = u8n()) => {\r\n    // HMAC-DRBG reseed() function. Steps D-G\r\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\r\n    v = h(); // v = hmac(k || v)\r\n    if (seed.length === 0) return;\r\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\r\n    v = h(); // v = hmac(k || v)\r\n  };\r\n  const gen = () => {\r\n    // HMAC-DRBG generate() function\r\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\r\n    let len = 0;\r\n    const out: Uint8Array[] = [];\r\n    while (len < qByteLen) {\r\n      v = h();\r\n      const sl = v.slice();\r\n      out.push(sl);\r\n      len += v.length;\r\n    }\r\n    return concatBytes(...out);\r\n  };\r\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\r\n    reset();\r\n    reseed(seed); // Steps D-G\r\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\r\n    while (!(res = pred(gen()))) reseed();\r\n    reset();\r\n    return res;\r\n  };\r\n  return genUntil;\r\n}\r\n\r\n// Validating curves and fields\r\n\r\nconst validatorFns = {\r\n  bigint: (val: any) => typeof val === 'bigint',\r\n  function: (val: any) => typeof val === 'function',\r\n  boolean: (val: any) => typeof val === 'boolean',\r\n  string: (val: any) => typeof val === 'string',\r\n  stringOrUint8Array: (val: any) => typeof val === 'string' || isBytes(val),\r\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\r\n  array: (val: any) => Array.isArray(val),\r\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\r\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\r\n} as const;\r\ntype Validator = keyof typeof validatorFns;\r\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\r\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\r\n\r\nexport function validateObject<T extends Record<string, any>>(\r\n  object: T,\r\n  validators: ValMap<T>,\r\n  optValidators: ValMap<T> = {}\r\n) {\r\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\r\n    const checkVal = validatorFns[type];\r\n    if (typeof checkVal !== 'function')\r\n      throw new Error(`Invalid validator \"${type}\", expected function`);\r\n\r\n    const val = object[fieldName as keyof typeof object];\r\n    if (isOptional && val === undefined) return;\r\n    if (!checkVal(val, object)) {\r\n      throw new Error(\r\n        `Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`\r\n      );\r\n    }\r\n  };\r\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\r\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\r\n  return object;\r\n}\r\n// validate type tests\r\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\r\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\r\n// // Should fail type-check\r\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\r\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\r\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\r\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\r\n\r\n/**\r\n * throws not implemented error\r\n */\r\nexport const notImplemented = () => {\r\n  throw new Error('not implemented');\r\n};\r\n\r\n/**\r\n * Memoizes (caches) computation result.\r\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\r\n */\r\nexport function memoized<T extends object, R, O extends any[]>(fn: (arg: T, ...args: O) => R) {\r\n  const map = new WeakMap<T, R>();\r\n  return (arg: T, ...args: O): R => {\r\n    const val = map.get(arg);\r\n    if (val !== undefined) return val;\r\n    const computed = fn(arg, ...args);\r\n    map.set(arg, computed);\r\n    return computed;\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}