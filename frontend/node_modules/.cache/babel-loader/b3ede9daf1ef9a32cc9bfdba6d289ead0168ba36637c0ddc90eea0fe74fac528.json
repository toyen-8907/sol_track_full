{"ast":null,"code":"import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { createTransferCheckedInstruction } from '../../instructions/transferChecked.js';\nimport { createTransferCheckedWithFeeInstruction } from '../transferFee/instructions.js';\nimport { getMint } from '../../state/mint.js';\nimport { getExtraAccountMetaAddress, getExtraAccountMetas, getTransferHook, resolveExtraAccountMeta } from './state.js';\nexport var TransferHookInstruction;\n(function (TransferHookInstruction) {\n  TransferHookInstruction[TransferHookInstruction[\"Initialize\"] = 0] = \"Initialize\";\n  TransferHookInstruction[TransferHookInstruction[\"Update\"] = 1] = \"Update\";\n})(TransferHookInstruction || (TransferHookInstruction = {}));\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeTransferHookInstructionData = struct([u8('instruction'), u8('transferHookInstruction'), publicKey('authority'), publicKey('transferHookProgramId')]);\n/**\n * Construct an InitializeTransferHook instruction\n *\n * @param mint                  Token mint account\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId Transfer hook program account\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const keys = [{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }];\n  const data = Buffer.alloc(initializeTransferHookInstructionData.span);\n  initializeTransferHookInstructionData.encode({\n    instruction: TokenInstruction.TransferHookExtension,\n    transferHookInstruction: TransferHookInstruction.Initialize,\n    authority,\n    transferHookProgramId\n  }, data);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/** The struct that represents the instruction data as it is read by the program */\nexport const updateTransferHookInstructionData = struct([u8('instruction'), u8('transferHookInstruction'), publicKey('transferHookProgramId')]);\n/**\n * Construct an UpdateTransferHook instruction\n *\n * @param mint                  Mint to update\n * @param authority             The mint's transfer hook authority\n * @param transferHookProgramId The new transfer hook program account\n * @param signers               The signer account(s) for a multisig\n * @param tokenProgramId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateTransferHookInstruction(mint, authority, transferHookProgramId, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const keys = addSigners([{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }], authority, multiSigners);\n  const data = Buffer.alloc(updateTransferHookInstructionData.span);\n  updateTransferHookInstructionData.encode({\n    instruction: TokenInstruction.TransferHookExtension,\n    transferHookInstruction: TransferHookInstruction.Update,\n    transferHookProgramId\n  }, data);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\nfunction deEscalateAccountMeta(accountMeta, accountMetas) {\n  const maybeHighestPrivileges = accountMetas.filter(x => x.pubkey.equals(accountMeta.pubkey)).reduce((acc, x) => {\n    if (!acc) return {\n      isSigner: x.isSigner,\n      isWritable: x.isWritable\n    };\n    return {\n      isSigner: acc.isSigner || x.isSigner,\n      isWritable: acc.isWritable || x.isWritable\n    };\n  }, undefined);\n  if (maybeHighestPrivileges) {\n    const {\n      isSigner,\n      isWritable\n    } = maybeHighestPrivileges;\n    if (!isSigner && isSigner !== accountMeta.isSigner) {\n      accountMeta.isSigner = false;\n    }\n    if (!isWritable && isWritable !== accountMeta.isWritable) {\n      accountMeta.isWritable = false;\n    }\n  }\n  return accountMeta;\n}\n/**\n * Construct an `ExecuteInstruction` for a transfer hook program, without the\n * additional accounts\n *\n * @param programId             The program ID of the transfer hook program\n * @param source                The source account\n * @param mint                  The mint account\n * @param destination           The destination account\n * @param owner                 Owner of the source account\n * @param validateStatePubkey   The validate state pubkey\n * @param amount                The amount of tokens to transfer\n * @returns Instruction to add to a transaction\n */\nexport function createExecuteInstruction(programId, source, mint, destination, owner, validateStatePubkey, amount) {\n  const keys = [source, mint, destination, owner, validateStatePubkey].map(pubkey => ({\n    pubkey,\n    isSigner: false,\n    isWritable: false\n  }));\n  const data = Buffer.alloc(16);\n  data.set(Buffer.from([105, 37, 101, 197, 75, 251, 102, 26]), 0); // `ExecuteInstruction` discriminator\n  data.writeBigUInt64LE(BigInt(amount), 8);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/**\n * Adds all the extra accounts needed for a transfer hook to an instruction.\n *\n * Note this will modify the instruction passed in.\n *\n * @param connection            Connection to use\n * @param instruction           The instruction to add accounts to\n * @param programId             Transfer hook program ID\n * @param source                The source account\n * @param mint                  The mint account\n * @param destination           The destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param commitment            Commitment to use\n */\nexport async function addExtraAccountMetasForExecute(connection, instruction, programId, source, mint, destination, owner, amount, commitment) {\n  const validateStatePubkey = getExtraAccountMetaAddress(mint, programId);\n  const validateStateAccount = await connection.getAccountInfo(validateStatePubkey, commitment);\n  if (validateStateAccount == null) {\n    return instruction;\n  }\n  const validateStateData = getExtraAccountMetas(validateStateAccount);\n  // Check to make sure the provided keys are in the instruction\n  if (![source, mint, destination, owner].every(key => instruction.keys.some(meta => meta.pubkey.equals(key)))) {\n    throw new Error('Missing required account in instruction');\n  }\n  const executeInstruction = createExecuteInstruction(programId, source, mint, destination, owner, validateStatePubkey, BigInt(amount));\n  for (const extraAccountMeta of validateStateData) {\n    executeInstruction.keys.push(deEscalateAccountMeta(await resolveExtraAccountMeta(connection, extraAccountMeta, executeInstruction.keys, executeInstruction.data, executeInstruction.programId), executeInstruction.keys));\n  }\n  // Add only the extra accounts resolved from the validation state\n  instruction.keys.push(...executeInstruction.keys.slice(5));\n  // Add the transfer hook program ID and the validation state account\n  instruction.keys.push({\n    pubkey: programId,\n    isSigner: false,\n    isWritable: false\n  });\n  instruction.keys.push({\n    pubkey: validateStatePubkey,\n    isSigner: false,\n    isWritable: false\n  });\n}\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, owner, amount, decimals, multiSigners = [], commitment, programId = TOKEN_PROGRAM_ID) {\n  const instruction = createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners, programId);\n  const mintInfo = await getMint(connection, mint, commitment, programId);\n  const transferHook = getTransferHook(mintInfo);\n  if (transferHook) {\n    await addExtraAccountMetasForExecute(connection, instruction, transferHook.programId, source, mint, destination, owner, amount, commitment);\n  }\n  return instruction;\n}\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param fee                   The calculated fee for the transfer fee extension\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, owner, amount, decimals, fee, multiSigners = [], commitment, programId = TOKEN_PROGRAM_ID) {\n  const instruction = createTransferCheckedWithFeeInstruction(source, mint, destination, owner, amount, decimals, fee, multiSigners, programId);\n  const mintInfo = await getMint(connection, mint, commitment, programId);\n  const transferHook = getTransferHook(mintInfo);\n  if (transferHook) {\n    await addExtraAccountMetasForExecute(connection, instruction, transferHook.programId, source, mint, destination, owner, amount, commitment);\n  }\n  return instruction;\n}","map":{"version":3,"names":["struct","u8","TransactionInstruction","programSupportsExtensions","TOKEN_2022_PROGRAM_ID","TOKEN_PROGRAM_ID","TokenUnsupportedInstructionError","addSigners","TokenInstruction","publicKey","createTransferCheckedInstruction","createTransferCheckedWithFeeInstruction","getMint","getExtraAccountMetaAddress","getExtraAccountMetas","getTransferHook","resolveExtraAccountMeta","TransferHookInstruction","initializeTransferHookInstructionData","createInitializeTransferHookInstruction","mint","authority","transferHookProgramId","programId","keys","pubkey","isSigner","isWritable","data","Buffer","alloc","span","encode","instruction","TransferHookExtension","transferHookInstruction","Initialize","updateTransferHookInstructionData","createUpdateTransferHookInstruction","multiSigners","Update","deEscalateAccountMeta","accountMeta","accountMetas","maybeHighestPrivileges","filter","x","equals","reduce","acc","undefined","createExecuteInstruction","source","destination","owner","validateStatePubkey","amount","map","set","from","writeBigUInt64LE","BigInt","addExtraAccountMetasForExecute","connection","commitment","validateStateAccount","getAccountInfo","validateStateData","every","key","some","meta","Error","executeInstruction","extraAccountMeta","push","slice","createTransferCheckedWithTransferHookInstruction","decimals","mintInfo","transferHook","createTransferCheckedWithFeeAndTransferHookInstruction","fee"],"sources":["/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token/src/extensions/transferHook/instructions.ts"],"sourcesContent":["import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, Commitment, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { createTransferCheckedInstruction } from '../../instructions/transferChecked.js';\nimport { createTransferCheckedWithFeeInstruction } from '../transferFee/instructions.js';\nimport { getMint } from '../../state/mint.js';\nimport { getExtraAccountMetaAddress, getExtraAccountMetas, getTransferHook, resolveExtraAccountMeta } from './state.js';\n\nexport enum TransferHookInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\n/** Deserialized instruction for the initiation of an transfer hook */\nexport interface InitializeTransferHookInstructionData {\n    instruction: TokenInstruction.TransferHookExtension;\n    transferHookInstruction: TransferHookInstruction.Initialize;\n    authority: PublicKey;\n    transferHookProgramId: PublicKey;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeTransferHookInstructionData = struct<InitializeTransferHookInstructionData>([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('authority'),\n    publicKey('transferHookProgramId'),\n]);\n\n/**\n * Construct an InitializeTransferHook instruction\n *\n * @param mint                  Token mint account\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId Transfer hook program account\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferHookInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeTransferHookInstructionData.span);\n    initializeTransferHookInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferHookExtension,\n            transferHookInstruction: TransferHookInstruction.Initialize,\n            authority,\n            transferHookProgramId,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** Deserialized instruction for the initiation of an transfer hook */\nexport interface UpdateTransferHookInstructionData {\n    instruction: TokenInstruction.TransferHookExtension;\n    transferHookInstruction: TransferHookInstruction.Update;\n    transferHookProgramId: PublicKey;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const updateTransferHookInstructionData = struct<UpdateTransferHookInstructionData>([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('transferHookProgramId'),\n]);\n\n/**\n * Construct an UpdateTransferHook instruction\n *\n * @param mint                  Mint to update\n * @param authority             The mint's transfer hook authority\n * @param transferHookProgramId The new transfer hook program account\n * @param signers               The signer account(s) for a multisig\n * @param tokenProgramId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateTransferHookInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(updateTransferHookInstructionData.span);\n    updateTransferHookInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferHookExtension,\n            transferHookInstruction: TransferHookInstruction.Update,\n            transferHookProgramId,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\nfunction deEscalateAccountMeta(accountMeta: AccountMeta, accountMetas: AccountMeta[]): AccountMeta {\n    const maybeHighestPrivileges = accountMetas\n        .filter(x => x.pubkey.equals(accountMeta.pubkey))\n        .reduce<{ isSigner: boolean; isWritable: boolean } | undefined>((acc, x) => {\n            if (!acc) return { isSigner: x.isSigner, isWritable: x.isWritable };\n            return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };\n        }, undefined);\n    if (maybeHighestPrivileges) {\n        const { isSigner, isWritable } = maybeHighestPrivileges;\n        if (!isSigner && isSigner !== accountMeta.isSigner) {\n            accountMeta.isSigner = false;\n        }\n        if (!isWritable && isWritable !== accountMeta.isWritable) {\n            accountMeta.isWritable = false;\n        }\n    }\n    return accountMeta;\n}\n\n/**\n * Construct an `ExecuteInstruction` for a transfer hook program, without the\n * additional accounts\n *\n * @param programId             The program ID of the transfer hook program\n * @param source                The source account\n * @param mint                  The mint account\n * @param destination           The destination account\n * @param owner                 Owner of the source account\n * @param validateStatePubkey   The validate state pubkey\n * @param amount                The amount of tokens to transfer\n * @returns Instruction to add to a transaction\n */\nexport function createExecuteInstruction(\n    programId: PublicKey,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    validateStatePubkey: PublicKey,\n    amount: bigint,\n): TransactionInstruction {\n    const keys = [source, mint, destination, owner, validateStatePubkey].map(pubkey => ({\n        pubkey,\n        isSigner: false,\n        isWritable: false,\n    }));\n\n    const data = Buffer.alloc(16);\n    data.set(Buffer.from([105, 37, 101, 197, 75, 251, 102, 26]), 0); // `ExecuteInstruction` discriminator\n    data.writeBigUInt64LE(BigInt(amount), 8);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/**\n * Adds all the extra accounts needed for a transfer hook to an instruction.\n *\n * Note this will modify the instruction passed in.\n *\n * @param connection            Connection to use\n * @param instruction           The instruction to add accounts to\n * @param programId             Transfer hook program ID\n * @param source                The source account\n * @param mint                  The mint account\n * @param destination           The destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param commitment            Commitment to use\n */\nexport async function addExtraAccountMetasForExecute(\n    connection: Connection,\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    commitment?: Commitment,\n) {\n    const validateStatePubkey = getExtraAccountMetaAddress(mint, programId);\n    const validateStateAccount = await connection.getAccountInfo(validateStatePubkey, commitment);\n    if (validateStateAccount == null) {\n        return instruction;\n    }\n    const validateStateData = getExtraAccountMetas(validateStateAccount);\n\n    // Check to make sure the provided keys are in the instruction\n    if (![source, mint, destination, owner].every(key => instruction.keys.some(meta => meta.pubkey.equals(key)))) {\n        throw new Error('Missing required account in instruction');\n    }\n\n    const executeInstruction = createExecuteInstruction(\n        programId,\n        source,\n        mint,\n        destination,\n        owner,\n        validateStatePubkey,\n        BigInt(amount),\n    );\n\n    for (const extraAccountMeta of validateStateData) {\n        executeInstruction.keys.push(\n            deEscalateAccountMeta(\n                await resolveExtraAccountMeta(\n                    connection,\n                    extraAccountMeta,\n                    executeInstruction.keys,\n                    executeInstruction.data,\n                    executeInstruction.programId,\n                ),\n                executeInstruction.keys,\n            ),\n        );\n    }\n\n    // Add only the extra accounts resolved from the validation state\n    instruction.keys.push(...executeInstruction.keys.slice(5));\n\n    // Add the transfer hook program ID and the validation state account\n    instruction.keys.push({ pubkey: programId, isSigner: false, isWritable: false });\n    instruction.keys.push({ pubkey: validateStatePubkey, isSigner: false, isWritable: false });\n}\n\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithTransferHookInstruction(\n    connection: Connection,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n) {\n    const instruction = createTransferCheckedInstruction(\n        source,\n        mint,\n        destination,\n        owner,\n        amount,\n        decimals,\n        multiSigners,\n        programId,\n    );\n\n    const mintInfo = await getMint(connection, mint, commitment, programId);\n    const transferHook = getTransferHook(mintInfo);\n\n    if (transferHook) {\n        await addExtraAccountMetasForExecute(\n            connection,\n            instruction,\n            transferHook.programId,\n            source,\n            mint,\n            destination,\n            owner,\n            amount,\n            commitment,\n        );\n    }\n\n    return instruction;\n}\n\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param fee                   The calculated fee for the transfer fee extension\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithFeeAndTransferHookInstruction(\n    connection: Connection,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n) {\n    const instruction = createTransferCheckedWithFeeInstruction(\n        source,\n        mint,\n        destination,\n        owner,\n        amount,\n        decimals,\n        fee,\n        multiSigners,\n        programId,\n    );\n\n    const mintInfo = await getMint(connection, mint, commitment, programId);\n    const transferHook = getTransferHook(mintInfo);\n\n    if (transferHook) {\n        await addExtraAccountMetasForExecute(\n            connection,\n            instruction,\n            transferHook.programId,\n            source,\n            mint,\n            destination,\n            owner,\n            amount,\n            commitment,\n        );\n    }\n\n    return instruction;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}