{"ast":null,"code":"import { SolanaError, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE } from '@solana/errors';\nimport { createEncoder, createDecoder, combineCodec } from '@solana/codecs-core';\n\n// src/assertions.ts\nfunction assertValidBaseString(alphabet4, testValue, givenValue = testValue) {\n  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n      alphabet: alphabet4,\n      base: alphabet4.length,\n      value: givenValue\n    });\n  }\n}\nvar getBaseXEncoder = alphabet4 => {\n  return createEncoder({\n    getSizeFromValue: value => {\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) return value.length;\n      const base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n    },\n    write(value, bytes, offset) {\n      assertValidBaseString(alphabet4, value);\n      if (value === \"\") return offset;\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) {\n        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n        return offset + leadingZeroes.length;\n      }\n      let base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      const tailBytes = [];\n      while (base10Number > 0n) {\n        tailBytes.unshift(Number(base10Number % 256n));\n        base10Number /= 256n;\n      }\n      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getBaseXDecoder = alphabet4 => {\n  return createDecoder({\n    read(rawBytes, offset) {\n      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n      if (bytes.length === 0) return [\"\", 0];\n      let trailIndex = bytes.findIndex(n => n !== 0);\n      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n      const leadingZeroes = alphabet4[0].repeat(trailIndex);\n      if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n      const tailChars = getBaseXFromBigInt(base10Number, alphabet4);\n      return [leadingZeroes + tailChars, rawBytes.length];\n    }\n  });\n};\nvar getBaseXCodec = alphabet4 => combineCodec(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4));\nfunction partitionLeadingZeroes(value, zeroCharacter) {\n  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n  return [leadingZeros, tailChars];\n}\nfunction getBigIntFromBaseX(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  let sum = 0n;\n  for (const char of value) {\n    sum *= base;\n    sum += BigInt(alphabet4.indexOf(char));\n  }\n  return sum;\n}\nfunction getBaseXFromBigInt(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  const tailChars = [];\n  while (value > 0n) {\n    tailChars.unshift(alphabet4[Number(value % base)]);\n    value /= base;\n  }\n  return tailChars.join(\"\");\n}\n\n// src/base10.ts\nvar alphabet = \"0123456789\";\nvar getBase10Encoder = () => getBaseXEncoder(alphabet);\nvar getBase10Decoder = () => getBaseXDecoder(alphabet);\nvar getBase10Codec = () => getBaseXCodec(alphabet);\nvar INVALID_STRING_ERROR_BASE_CONFIG = {\n  alphabet: \"0123456789abcdef\",\n  base: 16\n};\nfunction charCodeToBase16(char) {\n  if (char >= 48 /* ZERO */ && char <= 57 /* NINE */) return char - 48 /* ZERO */;\n  if (char >= 65 /* A_UP */ && char <= 70 /* F_UP */) return char - (65 /* A_UP */ - 10);\n  if (char >= 97 /* A_LO */ && char <= 102 /* F_LO */) return char - (97 /* A_LO */ - 10);\n}\nvar getBase16Encoder = () => createEncoder({\n  getSizeFromValue: value => Math.ceil(value.length / 2),\n  write(value, bytes, offset) {\n    const len = value.length;\n    const al = len / 2;\n    if (len === 1) {\n      const c = value.charCodeAt(0);\n      const n = charCodeToBase16(c);\n      if (n === void 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n          ...INVALID_STRING_ERROR_BASE_CONFIG,\n          value\n        });\n      }\n      bytes.set([n], offset);\n      return 1 + offset;\n    }\n    const hexBytes = new Uint8Array(al);\n    for (let i = 0, j = 0; i < al; i++) {\n      const c1 = value.charCodeAt(j++);\n      const c2 = value.charCodeAt(j++);\n      const n1 = charCodeToBase16(c1);\n      const n2 = charCodeToBase16(c2);\n      if (n1 === void 0 || n2 === void 0 && !Number.isNaN(c2)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n          ...INVALID_STRING_ERROR_BASE_CONFIG,\n          value\n        });\n      }\n      hexBytes[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;\n    }\n    bytes.set(hexBytes, offset);\n    return hexBytes.length + offset;\n  }\n});\nvar getBase16Decoder = () => createDecoder({\n  read(bytes, offset) {\n    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n    return [value, bytes.length];\n  }\n});\nvar getBase16Codec = () => combineCodec(getBase16Encoder(), getBase16Decoder());\n\n// src/base58.ts\nvar alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar getBase58Encoder = () => getBaseXEncoder(alphabet2);\nvar getBase58Decoder = () => getBaseXDecoder(alphabet2);\nvar getBase58Codec = () => getBaseXCodec(alphabet2);\nvar getBaseXResliceEncoder = (alphabet4, bits) => createEncoder({\n  getSizeFromValue: value => Math.floor(value.length * bits / 8),\n  write(value, bytes, offset) {\n    assertValidBaseString(alphabet4, value);\n    if (value === \"\") return offset;\n    const charIndices = [...value].map(c => alphabet4.indexOf(c));\n    const reslicedBytes = reslice(charIndices, bits, 8, false);\n    bytes.set(reslicedBytes, offset);\n    return reslicedBytes.length + offset;\n  }\n});\nvar getBaseXResliceDecoder = (alphabet4, bits) => createDecoder({\n  read(rawBytes, offset = 0) {\n    const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n    if (bytes.length === 0) return [\"\", rawBytes.length];\n    const charIndices = reslice([...bytes], 8, bits, true);\n    return [charIndices.map(i => alphabet4[i]).join(\"\"), rawBytes.length];\n  }\n});\nvar getBaseXResliceCodec = (alphabet4, bits) => combineCodec(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits));\nfunction reslice(input, inputBits, outputBits, useRemainder) {\n  const output = [];\n  let accumulator = 0;\n  let bitsInAccumulator = 0;\n  const mask = (1 << outputBits) - 1;\n  for (const value of input) {\n    accumulator = accumulator << inputBits | value;\n    bitsInAccumulator += inputBits;\n    while (bitsInAccumulator >= outputBits) {\n      bitsInAccumulator -= outputBits;\n      output.push(accumulator >> bitsInAccumulator & mask);\n    }\n  }\n  if (useRemainder && bitsInAccumulator > 0) {\n    output.push(accumulator << outputBits - bitsInAccumulator & mask);\n  }\n  return output;\n}\n\n// src/base64.ts\nvar alphabet3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar getBase64Encoder = () => {\n  {\n    return createEncoder({\n      getSizeFromValue: value => {\n        try {\n          return atob(value).length;\n        } catch (e2) {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      },\n      write(value, bytes, offset) {\n        try {\n          const bytesToAdd = atob(value).split(\"\").map(c => c.charCodeAt(0));\n          bytes.set(bytesToAdd, offset);\n          return bytesToAdd.length + offset;\n        } catch (e2) {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      }\n    });\n  }\n};\nvar getBase64Decoder = () => {\n  {\n    return createDecoder({\n      read(bytes, offset = 0) {\n        const slice = bytes.slice(offset);\n        const value = btoa(String.fromCharCode(...slice));\n        return [value, bytes.length];\n      }\n    });\n  }\n};\nvar getBase64Codec = () => combineCodec(getBase64Encoder(), getBase64Decoder());\n\n// src/null-characters.ts\nvar removeNullCharacters = value =>\n// eslint-disable-next-line no-control-regex\nvalue.replace(/\\u0000/g, \"\");\nvar padNullCharacters = (value, chars) => value.padEnd(chars, \"\\0\");\n\n// ../text-encoding-impl/dist/index.browser.mjs\nvar e = globalThis.TextDecoder;\nvar o = globalThis.TextEncoder;\n\n// src/utf8.ts\nvar getUtf8Encoder = () => {\n  let textEncoder;\n  return createEncoder({\n    getSizeFromValue: value => (textEncoder ||= new o()).encode(value).length,\n    write: (value, bytes, offset) => {\n      const bytesToAdd = (textEncoder ||= new o()).encode(value);\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getUtf8Decoder = () => {\n  let textDecoder;\n  return createDecoder({\n    read(bytes, offset) {\n      const value = (textDecoder ||= new e()).decode(bytes.slice(offset));\n      return [removeNullCharacters(value), bytes.length];\n    }\n  });\n};\nvar getUtf8Codec = () => combineCodec(getUtf8Encoder(), getUtf8Decoder());\nexport { assertValidBaseString, getBase10Codec, getBase10Decoder, getBase10Encoder, getBase16Codec, getBase16Decoder, getBase16Encoder, getBase58Codec, getBase58Decoder, getBase58Encoder, getBase64Codec, getBase64Decoder, getBase64Encoder, getBaseXCodec, getBaseXDecoder, getBaseXEncoder, getBaseXResliceCodec, getBaseXResliceDecoder, getBaseXResliceEncoder, getUtf8Codec, getUtf8Decoder, getUtf8Encoder, padNullCharacters, removeNullCharacters };\n\n//# sourceMappingURL=index.browser.mjs.map","map":{"version":3,"names":["assertValidBaseString","alphabet4","testValue","givenValue","match","RegExp","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","alphabet","base","length","value","getBaseXEncoder","createEncoder","getSizeFromValue","leadingZeroes","tailChars","partitionLeadingZeroes","base10Number","getBigIntFromBaseX","Math","ceil","toString","write","bytes","offset","set","Uint8Array","fill","tailBytes","unshift","Number","bytesToAdd","Array","getBaseXDecoder","createDecoder","read","rawBytes","slice","trailIndex","findIndex","n","repeat","reduce","sum","byte","BigInt","getBaseXFromBigInt","getBaseXCodec","combineCodec","zeroCharacter","leadingZeros","split","char","indexOf","join","getBase10Encoder","getBase10Decoder","getBase10Codec","INVALID_STRING_ERROR_BASE_CONFIG","charCodeToBase16","getBase16Encoder","len","al","c","charCodeAt","hexBytes","i","j","c1","c2","n1","n2","isNaN","getBase16Decoder","str","padStart","getBase16Codec","alphabet2","getBase58Encoder","getBase58Decoder","getBase58Codec","getBaseXResliceEncoder","bits","floor","charIndices","map","reslicedBytes","reslice","getBaseXResliceDecoder","getBaseXResliceCodec","input","inputBits","outputBits","useRemainder","output","accumulator","bitsInAccumulator","mask","push","alphabet3","getBase64Encoder","atob","e2","getBase64Decoder","btoa","String","fromCharCode","getBase64Codec","removeNullCharacters","replace","padNullCharacters","chars","padEnd","e","globalThis","TextDecoder","o","TextEncoder","getUtf8Encoder","textEncoder","encode","getUtf8Decoder","textDecoder","decode","getUtf8Codec"],"sources":["/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-strings/src/assertions.ts","/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-strings/src/baseX.ts","/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-strings/src/base10.ts","/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-strings/src/base16.ts","/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-strings/src/base58.ts","/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-strings/src/baseX-reslice.ts","/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-strings/src/base64.ts","/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-strings/src/null-characters.ts","/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token-metadata/node_modules/@solana/text-encoding-impl/src/index.browser.ts","/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-strings/src/utf8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string matches a given alphabet.\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Decodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * A string codec that requires a custom alphabet and uses\n * the length of that alphabet as the base. It then divides\n * the input by the base as many times as necessary to get\n * the output. It also supports leading zeroes by using the\n * first character of the alphabet as the zero character.\n *\n * This can be used to create codecs such as base10 or base58.\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/** Encodes strings in base10. */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base10. */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base10. */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** Encodes strings in base58. */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base58. */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base58. */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Decodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * A string serializer that reslices bytes into custom chunks\n * of bits that are then mapped to a custom alphabet.\n *\n * This can be used to create serializers whose alphabet\n * is a power of 2 such as base16 or base64.\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/** Encodes strings in base64. */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/** Decodes strings in base64. */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/** Encodes and decodes strings in base64. */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**Removes null characters from a string. */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/** Pads a string with null characters at the end. */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/** Encodes UTF-8 strings using the native `TextEncoder` API. */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/** Decodes UTF-8 strings using the native `TextDecoder` API. */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/** Encodes and decodes UTF-8 strings using the native `TextEncoder` and `TextDecoder` API. */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}