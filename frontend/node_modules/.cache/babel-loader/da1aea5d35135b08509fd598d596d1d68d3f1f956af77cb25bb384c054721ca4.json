{"ast":null,"code":"import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidMintError, TokenInvalidOwnerError } from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n/**\r\n * Retrieve the associated token account, or create it if it doesn't exist\r\n *\r\n * @param connection               Connection to use\r\n * @param payer                    Payer of the transaction and initialization fees\r\n * @param mint                     Mint associated with the account to set or verify\r\n * @param owner                    Owner of the account to set or verify\r\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\r\n * @param commitment               Desired level of commitment for querying the state\r\n * @param confirmOptions           Options for confirming the transaction\r\n * @param programId                SPL Token program account\r\n * @param associatedTokenProgramId SPL Associated Token program account\r\n *\r\n * @return Address of the new associated token account\r\n */\nexport async function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n  const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);\n  // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n  // Sadly we can't do this atomically.\n  let account;\n  try {\n    account = await getAccount(connection, associatedToken, commitment, programId);\n  } catch (error) {\n    // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n    // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n    // TokenInvalidAccountOwnerError in this code path.\n    if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n      // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n      try {\n        const transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));\n        await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n      } catch (error) {\n        // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n        // instruction error if the associated account exists already.\n      }\n      // Now this should always succeed\n      account = await getAccount(connection, associatedToken, commitment, programId);\n    } else {\n      throw error;\n    }\n  }\n  if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n  if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n  return account;\n}","map":{"version":3,"names":["sendAndConfirmTransaction","Transaction","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidMintError","TokenInvalidOwnerError","createAssociatedTokenAccountInstruction","getAccount","getAssociatedTokenAddressSync","getOrCreateAssociatedTokenAccount","connection","payer","mint","owner","allowOwnerOffCurve","commitment","confirmOptions","programId","associatedTokenProgramId","associatedToken","account","error","transaction","add","publicKey","equals"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token\\src\\actions\\getOrCreateAssociatedTokenAccount.ts"],"sourcesContent":["import type { Commitment, ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\r\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\r\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\r\nimport {\r\n    TokenAccountNotFoundError,\r\n    TokenInvalidAccountOwnerError,\r\n    TokenInvalidMintError,\r\n    TokenInvalidOwnerError,\r\n} from '../errors.js';\r\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\r\nimport type { Account } from '../state/account.js';\r\nimport { getAccount } from '../state/account.js';\r\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\r\n\r\n/**\r\n * Retrieve the associated token account, or create it if it doesn't exist\r\n *\r\n * @param connection               Connection to use\r\n * @param payer                    Payer of the transaction and initialization fees\r\n * @param mint                     Mint associated with the account to set or verify\r\n * @param owner                    Owner of the account to set or verify\r\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\r\n * @param commitment               Desired level of commitment for querying the state\r\n * @param confirmOptions           Options for confirming the transaction\r\n * @param programId                SPL Token program account\r\n * @param associatedTokenProgramId SPL Associated Token program account\r\n *\r\n * @return Address of the new associated token account\r\n */\r\nexport async function getOrCreateAssociatedTokenAccount(\r\n    connection: Connection,\r\n    payer: Signer,\r\n    mint: PublicKey,\r\n    owner: PublicKey,\r\n    allowOwnerOffCurve = false,\r\n    commitment?: Commitment,\r\n    confirmOptions?: ConfirmOptions,\r\n    programId = TOKEN_PROGRAM_ID,\r\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\r\n): Promise<Account> {\r\n    const associatedToken = getAssociatedTokenAddressSync(\r\n        mint,\r\n        owner,\r\n        allowOwnerOffCurve,\r\n        programId,\r\n        associatedTokenProgramId,\r\n    );\r\n\r\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\r\n    // Sadly we can't do this atomically.\r\n    let account: Account;\r\n    try {\r\n        account = await getAccount(connection, associatedToken, commitment, programId);\r\n    } catch (error: unknown) {\r\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\r\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\r\n        // TokenInvalidAccountOwnerError in this code path.\r\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\r\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\r\n            try {\r\n                const transaction = new Transaction().add(\r\n                    createAssociatedTokenAccountInstruction(\r\n                        payer.publicKey,\r\n                        associatedToken,\r\n                        owner,\r\n                        mint,\r\n                        programId,\r\n                        associatedTokenProgramId,\r\n                    ),\r\n                );\r\n\r\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\r\n            } catch (error: unknown) {\r\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\r\n                // instruction error if the associated account exists already.\r\n            }\r\n\r\n            // Now this should always succeed\r\n            account = await getAccount(connection, associatedToken, commitment, programId);\r\n        } else {\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\r\n    if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\r\n\r\n    return account;\r\n}\r\n"],"mappings":"AACA,SAASA,yBAAyB,EAAEC,WAAW,QAAQ,iBAAiB;AACxE,SAASC,2BAA2B,EAAEC,gBAAgB,QAAQ,iBAAiB;AAC/E,SACIC,yBAAyB,EACzBC,6BAA6B,EAC7BC,qBAAqB,EACrBC,sBAAsB,QACnB,cAAc;AACrB,SAASC,uCAAuC,QAAQ,2CAA2C;AAEnG,SAASC,UAAU,QAAQ,qBAAqB;AAChD,SAASC,6BAA6B,QAAQ,kBAAkB;AAEhE;;;;;;;;;;;;;;;AAeA,OAAO,eAAeC,iCAAiCA,CACnDC,UAAsB,EACtBC,KAAa,EACbC,IAAe,EACfC,KAAgB,EAChBC,kBAAkB,GAAG,KAAK,EAC1BC,UAAuB,EACvBC,cAA+B,EAC/BC,SAAS,GAAGhB,gBAAgB,EAC5BiB,wBAAwB,GAAGlB,2BAA2B;EAEtD,MAAMmB,eAAe,GAAGX,6BAA6B,CACjDI,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBG,SAAS,EACTC,wBAAwB,CAC3B;EAED;EACA;EACA,IAAIE,OAAgB;EACpB,IAAI;IACAA,OAAO,GAAG,MAAMb,UAAU,CAACG,UAAU,EAAES,eAAe,EAAEJ,UAAU,EAAEE,SAAS,CAAC;EAClF,CAAC,CAAC,OAAOI,KAAc,EAAE;IACrB;IACA;IACA;IACA,IAAIA,KAAK,YAAYnB,yBAAyB,IAAImB,KAAK,YAAYlB,6BAA6B,EAAE;MAC9F;MACA,IAAI;QACA,MAAMmB,WAAW,GAAG,IAAIvB,WAAW,EAAE,CAACwB,GAAG,CACrCjB,uCAAuC,CACnCK,KAAK,CAACa,SAAS,EACfL,eAAe,EACfN,KAAK,EACLD,IAAI,EACJK,SAAS,EACTC,wBAAwB,CAC3B,CACJ;QAED,MAAMpB,yBAAyB,CAACY,UAAU,EAAEY,WAAW,EAAE,CAACX,KAAK,CAAC,EAAEK,cAAc,CAAC;MACrF,CAAC,CAAC,OAAOK,KAAc,EAAE;QACrB;QACA;MAAA;MAGJ;MACAD,OAAO,GAAG,MAAMb,UAAU,CAACG,UAAU,EAAES,eAAe,EAAEJ,UAAU,EAAEE,SAAS,CAAC;IAClF,CAAC,MAAM;MACH,MAAMI,KAAK;IACf;EACJ;EAEA,IAAI,CAACD,OAAO,CAACR,IAAI,CAACa,MAAM,CAACb,IAAI,CAAC,EAAE,MAAM,IAAIR,qBAAqB,EAAE;EACjE,IAAI,CAACgB,OAAO,CAACP,KAAK,CAACY,MAAM,CAACZ,KAAK,CAAC,EAAE,MAAM,IAAIR,sBAAsB,EAAE;EAEpE,OAAOe,OAAO;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}