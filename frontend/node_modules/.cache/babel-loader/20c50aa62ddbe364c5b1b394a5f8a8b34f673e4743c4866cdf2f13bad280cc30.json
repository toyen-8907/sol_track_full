{"ast":null,"code":"import { PublicKey } from '@solana/web3.js';\nimport { addCodecSizePrefix, fixCodecSize, getArrayCodec, getBytesCodec, getUtf8Codec, getU32Codec, getStructCodec, getTupleCodec } from '@solana/codecs';\nexport const TOKEN_METADATA_DISCRIMINATOR = Buffer.from([112, 132, 90, 90, 11, 88, 157, 87]);\nfunction getStringCodec() {\n  return addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n}\nconst tokenMetadataCodec = getStructCodec([['updateAuthority', fixCodecSize(getBytesCodec(), 32)], ['mint', fixCodecSize(getBytesCodec(), 32)], ['name', getStringCodec()], ['symbol', getStringCodec()], ['uri', getStringCodec()], ['additionalMetadata', getArrayCodec(getTupleCodec([getStringCodec(), getStringCodec()]))]]);\n// Checks if all elements in the array are 0\nfunction isNonePubkey(buffer) {\n  for (let i = 0; i < buffer.length; i++) {\n    if (buffer[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n// Pack TokenMetadata into byte slab\nexport function pack(meta) {\n  // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\n  const updateAuthority = meta.updateAuthority ?? PublicKey.default;\n  return tokenMetadataCodec.encode({\n    ...meta,\n    updateAuthority: updateAuthority.toBuffer(),\n    mint: meta.mint.toBuffer()\n  });\n}\n// unpack byte slab into TokenMetadata\nexport function unpack(buffer) {\n  const data = tokenMetadataCodec.decode(buffer);\n  return isNonePubkey(data.updateAuthority) ? {\n    mint: new PublicKey(data.mint),\n    name: data.name,\n    symbol: data.symbol,\n    uri: data.uri,\n    additionalMetadata: data.additionalMetadata\n  } : {\n    updateAuthority: new PublicKey(data.updateAuthority),\n    mint: new PublicKey(data.mint),\n    name: data.name,\n    symbol: data.symbol,\n    uri: data.uri,\n    additionalMetadata: data.additionalMetadata\n  };\n}","map":{"version":3,"names":["PublicKey","addCodecSizePrefix","fixCodecSize","getArrayCodec","getBytesCodec","getUtf8Codec","getU32Codec","getStructCodec","getTupleCodec","TOKEN_METADATA_DISCRIMINATOR","Buffer","from","getStringCodec","tokenMetadataCodec","isNonePubkey","buffer","i","length","pack","meta","updateAuthority","default","encode","toBuffer","mint","unpack","data","decode","name","symbol","uri","additionalMetadata"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\src\\state.ts"],"sourcesContent":["import { PublicKey } from '@solana/web3.js';\r\nimport {\r\n    addCodecSizePrefix,\r\n    fixCodecSize,\r\n    getArrayCodec,\r\n    getBytesCodec,\r\n    getUtf8Codec,\r\n    getU32Codec,\r\n    getStructCodec,\r\n    getTupleCodec,\r\n} from '@solana/codecs';\r\nimport type { ReadonlyUint8Array, VariableSizeCodec } from '@solana/codecs';\r\n\r\nexport const TOKEN_METADATA_DISCRIMINATOR = Buffer.from([112, 132, 90, 90, 11, 88, 157, 87]);\r\n\r\nfunction getStringCodec(): VariableSizeCodec<string> {\r\n    return addCodecSizePrefix(getUtf8Codec(), getU32Codec());\r\n}\r\n\r\nconst tokenMetadataCodec = getStructCodec([\r\n    ['updateAuthority', fixCodecSize(getBytesCodec(), 32)],\r\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\r\n    ['name', getStringCodec()],\r\n    ['symbol', getStringCodec()],\r\n    ['uri', getStringCodec()],\r\n    ['additionalMetadata', getArrayCodec(getTupleCodec([getStringCodec(), getStringCodec()]))],\r\n]);\r\n\r\nexport interface TokenMetadata {\r\n    // The authority that can sign to update the metadata\r\n    updateAuthority?: PublicKey;\r\n    // The associated mint, used to counter spoofing to be sure that metadata belongs to a particular mint\r\n    mint: PublicKey;\r\n    // The longer name of the token\r\n    name: string;\r\n    // The shortened symbol for the token\r\n    symbol: string;\r\n    // The URI pointing to richer metadata\r\n    uri: string;\r\n    // Any additional metadata about the token as key-value pairs\r\n    additionalMetadata: (readonly [string, string])[];\r\n}\r\n\r\n// Checks if all elements in the array are 0\r\nfunction isNonePubkey(buffer: ReadonlyUint8Array): boolean {\r\n    for (let i = 0; i < buffer.length; i++) {\r\n        if (buffer[i] !== 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// Pack TokenMetadata into byte slab\r\nexport function pack(meta: TokenMetadata): ReadonlyUint8Array {\r\n    // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\r\n    const updateAuthority = meta.updateAuthority ?? PublicKey.default;\r\n    return tokenMetadataCodec.encode({\r\n        ...meta,\r\n        updateAuthority: updateAuthority.toBuffer(),\r\n        mint: meta.mint.toBuffer(),\r\n    });\r\n}\r\n\r\n// unpack byte slab into TokenMetadata\r\nexport function unpack(buffer: Buffer | Uint8Array | ReadonlyUint8Array): TokenMetadata {\r\n    const data = tokenMetadataCodec.decode(buffer);\r\n\r\n    return isNonePubkey(data.updateAuthority)\r\n        ? {\r\n              mint: new PublicKey(data.mint),\r\n              name: data.name,\r\n              symbol: data.symbol,\r\n              uri: data.uri,\r\n              additionalMetadata: data.additionalMetadata,\r\n          }\r\n        : {\r\n              updateAuthority: new PublicKey(data.updateAuthority),\r\n              mint: new PublicKey(data.mint),\r\n              name: data.name,\r\n              symbol: data.symbol,\r\n              uri: data.uri,\r\n              additionalMetadata: data.additionalMetadata,\r\n          };\r\n}\r\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,iBAAiB;AAC3C,SACIC,kBAAkB,EAClBC,YAAY,EACZC,aAAa,EACbC,aAAa,EACbC,YAAY,EACZC,WAAW,EACXC,cAAc,EACdC,aAAa,QACV,gBAAgB;AAGvB,OAAO,MAAMC,4BAA4B,GAAGC,MAAM,CAACC,IAAI,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;AAE5F,SAASC,cAAcA,CAAA;EACnB,OAAOX,kBAAkB,CAACI,YAAY,EAAE,EAAEC,WAAW,EAAE,CAAC;AAC5D;AAEA,MAAMO,kBAAkB,GAAGN,cAAc,CAAC,CACtC,CAAC,iBAAiB,EAAEL,YAAY,CAACE,aAAa,EAAE,EAAE,EAAE,CAAC,CAAC,EACtD,CAAC,MAAM,EAAEF,YAAY,CAACE,aAAa,EAAE,EAAE,EAAE,CAAC,CAAC,EAC3C,CAAC,MAAM,EAAEQ,cAAc,EAAE,CAAC,EAC1B,CAAC,QAAQ,EAAEA,cAAc,EAAE,CAAC,EAC5B,CAAC,KAAK,EAAEA,cAAc,EAAE,CAAC,EACzB,CAAC,oBAAoB,EAAET,aAAa,CAACK,aAAa,CAAC,CAACI,cAAc,EAAE,EAAEA,cAAc,EAAE,CAAC,CAAC,CAAC,CAAC,CAC7F,CAAC;AAiBF;AACA,SAASE,YAAYA,CAACC,MAA0B;EAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IACpC,IAAID,MAAM,CAACC,CAAC,CAAC,KAAK,CAAC,EAAE;MACjB,OAAO,KAAK;IAChB;EACJ;EACA,OAAO,IAAI;AACf;AAEA;AACA,OAAM,SAAUE,IAAIA,CAACC,IAAmB;EACpC;EACA,MAAMC,eAAe,GAAGD,IAAI,CAACC,eAAe,IAAIpB,SAAS,CAACqB,OAAO;EACjE,OAAOR,kBAAkB,CAACS,MAAM,CAAC;IAC7B,GAAGH,IAAI;IACPC,eAAe,EAAEA,eAAe,CAACG,QAAQ,EAAE;IAC3CC,IAAI,EAAEL,IAAI,CAACK,IAAI,CAACD,QAAQ;GAC3B,CAAC;AACN;AAEA;AACA,OAAM,SAAUE,MAAMA,CAACV,MAAgD;EACnE,MAAMW,IAAI,GAAGb,kBAAkB,CAACc,MAAM,CAACZ,MAAM,CAAC;EAE9C,OAAOD,YAAY,CAACY,IAAI,CAACN,eAAe,CAAC,GACnC;IACII,IAAI,EAAE,IAAIxB,SAAS,CAAC0B,IAAI,CAACF,IAAI,CAAC;IAC9BI,IAAI,EAAEF,IAAI,CAACE,IAAI;IACfC,MAAM,EAAEH,IAAI,CAACG,MAAM;IACnBC,GAAG,EAAEJ,IAAI,CAACI,GAAG;IACbC,kBAAkB,EAAEL,IAAI,CAACK;GAC5B,GACD;IACIX,eAAe,EAAE,IAAIpB,SAAS,CAAC0B,IAAI,CAACN,eAAe,CAAC;IACpDI,IAAI,EAAE,IAAIxB,SAAS,CAAC0B,IAAI,CAACF,IAAI,CAAC;IAC9BI,IAAI,EAAEF,IAAI,CAACE,IAAI;IACfC,MAAM,EAAEH,IAAI,CAACG,MAAM;IACnBC,GAAG,EAAEJ,IAAI,CAACI,GAAG;IACbC,kBAAkB,EAAEL,IAAI,CAACK;GAC5B;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}