{"ast":null,"code":"import { transformEncoder, assertIsFixedSize, fixEncoderSize, transformDecoder, fixDecoderSize, containsBytes, combineCodec } from '@solana/codecs-core';\nimport { getUnitEncoder, getBooleanEncoder, getConstantEncoder, getUnionEncoder, getTupleEncoder, getUnitDecoder, getBooleanDecoder, getConstantDecoder, getUnionDecoder, getTupleDecoder } from '@solana/codecs-data-structures';\nimport { getU8Encoder, getU8Decoder } from '@solana/codecs-numbers';\n\n// src/option.ts\nvar some = value => ({\n  __option: \"Some\",\n  value\n});\nvar none = () => ({\n  __option: \"None\"\n});\nvar isOption = input => !!(input && typeof input === \"object\" && \"__option\" in input && (input.__option === \"Some\" && \"value\" in input || input.__option === \"None\"));\nvar isSome = option => option.__option === \"Some\";\nvar isNone = option => option.__option === \"None\";\n\n// src/unwrap-option.ts\nfunction unwrapOption(option, fallback) {\n  if (isSome(option)) return option.value;\n  return fallback ? fallback() : null;\n}\nvar wrapNullable = nullable => nullable !== null ? some(nullable) : none();\n\n// src/option-codec.ts\nfunction getOptionEncoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformEncoder(getUnitEncoder(), _boolean => void 0);\n    }\n    return getBooleanEncoder({\n      size: config.prefix ?? getU8Encoder()\n    });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitEncoder();\n    }\n    return getConstantEncoder(config.noneValue);\n  })();\n  return getUnionEncoder([transformEncoder(getTupleEncoder([prefix, noneValue]), _value => [false, void 0]), transformEncoder(getTupleEncoder([prefix, item]), value => [true, isOption(value) && isSome(value) ? value.value : value])], variant => {\n    const option = isOption(variant) ? variant : wrapNullable(variant);\n    return Number(isSome(option));\n  });\n}\nfunction getOptionDecoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformDecoder(getUnitDecoder(), () => false);\n    }\n    return getBooleanDecoder({\n      size: config.prefix ?? getU8Decoder()\n    });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitDecoder();\n    }\n    return getConstantDecoder(config.noneValue);\n  })();\n  return getUnionDecoder([transformDecoder(getTupleDecoder([prefix, noneValue]), () => none()), transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value))], (bytes, offset) => {\n    if (config.prefix === null && !config.noneValue) {\n      return Number(offset < bytes.length);\n    }\n    if (config.prefix === null && config.noneValue != null) {\n      const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n      return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n    }\n    return Number(prefix.read(bytes, offset)[0]);\n  });\n}\nfunction getOptionCodec(item, config = {}) {\n  return combineCodec(getOptionEncoder(item, config), getOptionDecoder(item, config));\n}\n\n// src/unwrap-option-recursively.ts\nfunction unwrapOptionRecursively(input, fallback) {\n  if (!input || ArrayBuffer.isView(input)) {\n    return input;\n  }\n  const next = x => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);\n  if (isOption(input)) {\n    if (isSome(input)) return next(input.value);\n    return fallback ? fallback() : null;\n  }\n  if (Array.isArray(input)) {\n    return input.map(next);\n  }\n  if (typeof input === \"object\") {\n    return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));\n  }\n  return input;\n}\nexport { getOptionCodec, getOptionDecoder, getOptionEncoder, isNone, isOption, isSome, none, some, unwrapOption, unwrapOptionRecursively, wrapNullable };\n\n//# sourceMappingURL=index.browser.mjs.map","map":{"version":3,"names":["some","value","__option","none","isOption","input","isSome","option","isNone","unwrapOption","fallback","wrapNullable","nullable","getOptionEncoder","item","config","prefix","transformEncoder","getUnitEncoder","_boolean","getBooleanEncoder","size","getU8Encoder","noneValue","assertIsFixedSize","fixEncoderSize","fixedSize","getConstantEncoder","getUnionEncoder","getTupleEncoder","_value","variant","Number","getOptionDecoder","transformDecoder","getUnitDecoder","getBooleanDecoder","getU8Decoder","fixDecoderSize","getConstantDecoder","getUnionDecoder","getTupleDecoder","bytes","offset","length","zeroValue","Uint8Array","fill","containsBytes","read","getOptionCodec","combineCodec","unwrapOptionRecursively","ArrayBuffer","isView","next","x","Array","isArray","map","Object","fromEntries","entries","k","v"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-group\\node_modules\\@solana\\options\\src\\option.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-group\\node_modules\\@solana\\options\\src\\unwrap-option.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-group\\node_modules\\@solana\\options\\src\\option-codec.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-group\\node_modules\\@solana\\options\\src\\unwrap-option-recursively.ts"],"sourcesContent":["/**\n * An implementation of the Rust Option type in JavaScript.\n * It can be one of the following:\n * - <code>{@link Some}<T></code>: Meaning there is a value of type T.\n * - <code>{@link None}</code>: Meaning there is no value.\n */\nexport type Option<T> = None | Some<T>;\n\n/**\n * Defines a looser type that can be used when serializing an {@link Option}.\n * This allows us to pass null or the Option value directly whilst still\n * supporting the Option type for use-cases that need more type safety.\n */\nexport type OptionOrNullable<T> = Option<T> | T | null;\n\n/**\n * Represents an option of type `T` that has a value.\n *\n * @see {@link Option}\n */\nexport type Some<T> = Readonly<{ __option: 'Some'; value: T }>;\n\n/**\n * Represents an option of type `T` that has no value.\n *\n * @see {@link Option}\n */\nexport type None = Readonly<{ __option: 'None' }>;\n\n/**\n * Creates a new {@link Option} of type `T` that has a value.\n *\n * @see {@link Option}\n */\nexport const some = <T>(value: T): Option<T> => ({ __option: 'Some', value });\n\n/**\n * Creates a new {@link Option} of type `T` that has no value.\n *\n * @see {@link Option}\n */\nexport const none = <T>(): Option<T> => ({ __option: 'None' });\n\n/**\n * Whether the given data is an {@link Option}.\n */\nexport const isOption = <T = unknown>(input: unknown): input is Option<T> =>\n    !!(\n        input &&\n        typeof input === 'object' &&\n        '__option' in input &&\n        ((input.__option === 'Some' && 'value' in input) || input.__option === 'None')\n    );\n\n/**\n * Whether the given {@link Option} is a {@link Some}.\n */\nexport const isSome = <T>(option: Option<T>): option is Some<T> => option.__option === 'Some';\n\n/**\n * Whether the given {@link Option} is a {@link None}.\n */\nexport const isNone = <T>(option: Option<T>): option is None => option.__option === 'None';\n","import { isSome, none, Option, some } from './option';\n\n/**\n * Unwraps the value of an {@link Option} of type `T`\n * or returns a fallback value that defaults to `null`.\n */\nexport function unwrapOption<T>(option: Option<T>): T | null;\nexport function unwrapOption<T, U>(option: Option<T>, fallback: () => U): T | U;\nexport function unwrapOption<T, U = null>(option: Option<T>, fallback?: () => U): T | U {\n    if (isSome(option)) return option.value;\n    return fallback ? fallback() : (null as U);\n}\n\n/**\n * Wraps a nullable value into an {@link Option}.\n */\nexport const wrapNullable = <T>(nullable: T | null): Option<T> => (nullable !== null ? some(nullable) : none<T>());\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getConstantDecoder,\n    getConstantEncoder,\n    getTupleDecoder,\n    getTupleEncoder,\n    getUnionDecoder,\n    getUnionEncoder,\n    getUnitDecoder,\n    getUnitEncoder,\n} from '@solana/codecs-data-structures';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { isOption, isSome, None, none, Option, OptionOrNullable, Some, some } from './option';\nimport { wrapNullable } from './unwrap-option';\n\n/** Defines the config for Option codecs. */\nexport type OptionCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Defines how the `None` value should be represented.\n     *\n     * By default, no none value is used. This means a `None` value will be\n     * represented by the absence of the item.\n     *\n     * When `'zeroes'` is provided, a `None` value will skip the bytes that would\n     * have been used for the item. Note that this returns a fixed-size codec\n     * and thus will only work if the item codec is of fixed size.\n     *\n     * When a custom byte array is provided, a `None` value will be represented\n     * by the provided byte array. Note that this returns a variable-size codec\n     * since the byte array representing `None` does not need to match the size\n     * of the item codec.\n     *\n     * @defaultValue No none value is used.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The codec to use for the boolean prefix, if any.\n     *\n     * By default a `u8` number is used as a prefix to determine if the value is `None`.\n     * The value `0` is encoded for `None` and `1` if the value is present.\n     * This can be set to any number codec to customize the prefix.\n     *\n     * When `null` is provided, no prefix is used and the `noneValue` is used to\n     * determine if the value is `None`. If no `noneValue` is provided, then the\n     * absence of any bytes is used to determine if the value is `None`.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Creates a encoder for an optional value using the `Option<T>` type.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getOptionEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<OptionOrNullable<TFrom>, TSize>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: OptionCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> = {},\n): Encoder<OptionOrNullable<TFrom>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: None | null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: Some<TFrom> | TFrom): [boolean, TFrom] => [\n                true,\n                isOption(value) && isSome(value) ? value.value : value,\n            ]),\n        ],\n        variant => {\n            const option = isOption<TFrom>(variant) ? variant : wrapNullable(variant);\n            return Number(isSome(option));\n        },\n    );\n}\n\n/**\n * Creates a decoder for an optional value using the `Option<T>` type.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getOptionDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<Option<TTo>, TSize>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: OptionCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> = {},\n): Decoder<Option<TTo>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => none<TTo>()),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value)),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Creates a codec for an optional value using the `Option<T>` type.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getOptionCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>, TSize>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> = {},\n): Codec<OptionOrNullable<TFrom>, Option<TTo>> {\n    type ConfigCast = OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getOptionEncoder<TFrom>(item, config as ConfigCast),\n        getOptionDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import { isOption, isSome, None, Some } from './option';\n\n/**\n * Lists all types that should not be recursively unwrapped.\n *\n * @see {@link UnwrappedOption}\n */\ntype UnUnwrappables =\n    | Date\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | bigint\n    | boolean\n    | number\n    | string\n    | symbol\n    | null\n    | undefined;\n\n/**\n * A type that defines the recursive unwrapping of a type `T`\n * such that all nested {@link Option} types are unwrapped.\n *\n * For each nested {@link Option} type, if the option is a {@link Some},\n * it returns the type of its value, otherwise, it returns the provided\n * fallback type `U` which defaults to `null`.\n */\nexport type UnwrappedOption<T, U = null> =\n    T extends Some<infer TValue>\n        ? UnwrappedOption<TValue, U>\n        : T extends None\n          ? U\n          : T extends UnUnwrappables\n            ? T\n            : T extends object\n              ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n              : T extends Array<infer TItem>\n                ? Array<UnwrappedOption<TItem, U>>\n                : T;\n\n/**\n * Recursively go through a type `T` such that all\n * nested {@link Option} types are unwrapped.\n *\n * For each nested {@link Option} type, if the option is a {@link Some},\n * it returns its value, otherwise, it returns the provided fallback value\n * which defaults to `null`.\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(input: T, fallback: () => U): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(input: T, fallback?: () => U): UnwrappedOption<T, U> {\n    // Types to bypass.\n    if (!input || ArrayBuffer.isView(input)) {\n        return input as UnwrappedOption<T, U>;\n    }\n\n    const next = <X>(x: X) =>\n        (fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n    // Handle Option.\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n        return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n    }\n\n    // Walk.\n    if (Array.isArray(input)) {\n        return input.map(next) as UnwrappedOption<T, U>;\n    }\n    if (typeof input === 'object') {\n        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)])) as UnwrappedOption<T, U>;\n    }\n    return input as UnwrappedOption<T, U>;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}