{"ast":null,"code":"import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError, TokenInvalidMintError, TokenOwnerOffCurveError } from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport { getMintLen } from '../extensions/extensionType.js';\nimport { ACCOUNT_SIZE } from './account.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n/** Buffer layout for de/serializing a mint */\nexport const MintLayout = struct([u32('mintAuthorityOption'), publicKey('mintAuthority'), u64('supply'), u8('decimals'), bool('isInitialized'), u32('freezeAuthorityOption'), publicKey('freezeAuthority')]);\n/** Byte length of a mint */\nexport const MINT_SIZE = MintLayout.span;\n/**\r\n * Retrieve information about a mint\r\n *\r\n * @param connection Connection to use\r\n * @param address    Mint account\r\n * @param commitment Desired level of commitment for querying the state\r\n * @param programId  SPL Token program account\r\n *\r\n * @return Mint information\r\n */\nexport async function getMint(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {\n  const info = await connection.getAccountInfo(address, commitment);\n  return unpackMint(address, info, programId);\n}\n/**\r\n * Unpack a mint\r\n *\r\n * @param address   Mint account\r\n * @param info      Mint account data\r\n * @param programId SPL Token program account\r\n *\r\n * @return Unpacked mint\r\n */\nexport function unpackMint(address, info, programId = TOKEN_PROGRAM_ID) {\n  if (!info) throw new TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n  if (info.data.length < MINT_SIZE) throw new TokenInvalidAccountSizeError();\n  const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));\n  let tlvData = Buffer.alloc(0);\n  if (info.data.length > MINT_SIZE) {\n    if (info.data.length <= ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n    if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n    if (info.data[ACCOUNT_SIZE] != AccountType.Mint) throw new TokenInvalidMintError();\n    tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n  }\n  return {\n    address,\n    mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n    supply: rawMint.supply,\n    decimals: rawMint.decimals,\n    isInitialized: rawMint.isInitialized,\n    freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n    tlvData\n  };\n}\n/** Get the minimum lamport balance for a mint to be rent exempt\r\n *\r\n * @param connection Connection to use\r\n * @param commitment Desired level of commitment for querying the state\r\n *\r\n * @return Amount of lamports required\r\n */\nexport async function getMinimumBalanceForRentExemptMint(connection, commitment) {\n  return await getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);\n}\n/** Get the minimum lamport balance for a rent-exempt mint with extensions\r\n *\r\n * @param connection Connection to use\r\n * @param extensions Extension types included in the mint\r\n * @param commitment Desired level of commitment for querying the state\r\n *\r\n * @return Amount of lamports required\r\n */\nexport async function getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {\n  const mintLen = getMintLen(extensions);\n  return await connection.getMinimumBalanceForRentExemption(mintLen, commitment);\n}\n/**\r\n * Async version of getAssociatedTokenAddressSync\r\n * For backwards compatibility\r\n *\r\n * @param mint                     Token mint account\r\n * @param owner                    Owner of the new account\r\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\r\n * @param programId                SPL Token program account\r\n * @param associatedTokenProgramId SPL Associated Token program account\r\n *\r\n * @return Promise containing the address of the associated token account\r\n */\nexport async function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n  if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n  const [address] = await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n  return address;\n}\n/**\r\n * Get the address of the associated token account for a given mint and owner\r\n *\r\n * @param mint                     Token mint account\r\n * @param owner                    Owner of the new account\r\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\r\n * @param programId                SPL Token program account\r\n * @param associatedTokenProgramId SPL Associated Token program account\r\n *\r\n * @return Address of the associated token account\r\n */\nexport function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n  if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n  const [address] = PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n  return address;\n}","map":{"version":3,"names":["struct","u32","u8","bool","publicKey","u64","PublicKey","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidAccountSizeError","TokenInvalidMintError","TokenOwnerOffCurveError","ACCOUNT_TYPE_SIZE","AccountType","getMintLen","ACCOUNT_SIZE","MULTISIG_SIZE","MintLayout","MINT_SIZE","span","getMint","connection","address","commitment","programId","info","getAccountInfo","unpackMint","owner","equals","data","length","rawMint","decode","slice","tlvData","Buffer","alloc","Mint","mintAuthority","mintAuthorityOption","supply","decimals","isInitialized","freezeAuthority","freezeAuthorityOption","getMinimumBalanceForRentExemptMint","getMinimumBalanceForRentExemptMintWithExtensions","extensions","mintLen","getMinimumBalanceForRentExemption","getAssociatedTokenAddress","mint","allowOwnerOffCurve","associatedTokenProgramId","isOnCurve","toBuffer","findProgramAddress","getAssociatedTokenAddressSync","findProgramAddressSync"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token\\src\\state\\mint.ts"],"sourcesContent":["import { struct, u32, u8 } from '@solana/buffer-layout';\r\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\r\nimport type { AccountInfo, Commitment, Connection } from '@solana/web3.js';\r\nimport { PublicKey } from '@solana/web3.js';\r\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\r\nimport {\r\n    TokenAccountNotFoundError,\r\n    TokenInvalidAccountOwnerError,\r\n    TokenInvalidAccountSizeError,\r\n    TokenInvalidMintError,\r\n    TokenOwnerOffCurveError,\r\n} from '../errors.js';\r\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\r\nimport type { ExtensionType } from '../extensions/extensionType.js';\r\nimport { getMintLen } from '../extensions/extensionType.js';\r\nimport { ACCOUNT_SIZE } from './account.js';\r\nimport { MULTISIG_SIZE } from './multisig.js';\r\n\r\n/** Information about a mint */\r\nexport interface Mint {\r\n    /** Address of the mint */\r\n    address: PublicKey;\r\n    /**\r\n     * Optional authority used to mint new tokens. The mint authority may only be provided during mint creation.\r\n     * If no mint authority is present then the mint has a fixed supply and no further tokens may be minted.\r\n     */\r\n    mintAuthority: PublicKey | null;\r\n    /** Total supply of tokens */\r\n    supply: bigint;\r\n    /** Number of base 10 digits to the right of the decimal place */\r\n    decimals: number;\r\n    /** Is this mint initialized */\r\n    isInitialized: boolean;\r\n    /** Optional authority to freeze token accounts */\r\n    freezeAuthority: PublicKey | null;\r\n    /** Additional data for extension */\r\n    tlvData: Buffer;\r\n}\r\n\r\n/** Mint as stored by the program */\r\nexport interface RawMint {\r\n    mintAuthorityOption: 1 | 0;\r\n    mintAuthority: PublicKey;\r\n    supply: bigint;\r\n    decimals: number;\r\n    isInitialized: boolean;\r\n    freezeAuthorityOption: 1 | 0;\r\n    freezeAuthority: PublicKey;\r\n}\r\n\r\n/** Buffer layout for de/serializing a mint */\r\nexport const MintLayout = struct<RawMint>([\r\n    u32('mintAuthorityOption'),\r\n    publicKey('mintAuthority'),\r\n    u64('supply'),\r\n    u8('decimals'),\r\n    bool('isInitialized'),\r\n    u32('freezeAuthorityOption'),\r\n    publicKey('freezeAuthority'),\r\n]);\r\n\r\n/** Byte length of a mint */\r\nexport const MINT_SIZE = MintLayout.span;\r\n\r\n/**\r\n * Retrieve information about a mint\r\n *\r\n * @param connection Connection to use\r\n * @param address    Mint account\r\n * @param commitment Desired level of commitment for querying the state\r\n * @param programId  SPL Token program account\r\n *\r\n * @return Mint information\r\n */\r\nexport async function getMint(\r\n    connection: Connection,\r\n    address: PublicKey,\r\n    commitment?: Commitment,\r\n    programId = TOKEN_PROGRAM_ID,\r\n): Promise<Mint> {\r\n    const info = await connection.getAccountInfo(address, commitment);\r\n    return unpackMint(address, info, programId);\r\n}\r\n\r\n/**\r\n * Unpack a mint\r\n *\r\n * @param address   Mint account\r\n * @param info      Mint account data\r\n * @param programId SPL Token program account\r\n *\r\n * @return Unpacked mint\r\n */\r\nexport function unpackMint(address: PublicKey, info: AccountInfo<Buffer> | null, programId = TOKEN_PROGRAM_ID): Mint {\r\n    if (!info) throw new TokenAccountNotFoundError();\r\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\r\n    if (info.data.length < MINT_SIZE) throw new TokenInvalidAccountSizeError();\r\n\r\n    const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));\r\n    let tlvData = Buffer.alloc(0);\r\n    if (info.data.length > MINT_SIZE) {\r\n        if (info.data.length <= ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\r\n        if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\r\n        if (info.data[ACCOUNT_SIZE] != AccountType.Mint) throw new TokenInvalidMintError();\r\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\r\n    }\r\n\r\n    return {\r\n        address,\r\n        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\r\n        supply: rawMint.supply,\r\n        decimals: rawMint.decimals,\r\n        isInitialized: rawMint.isInitialized,\r\n        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\r\n        tlvData,\r\n    };\r\n}\r\n\r\n/** Get the minimum lamport balance for a mint to be rent exempt\r\n *\r\n * @param connection Connection to use\r\n * @param commitment Desired level of commitment for querying the state\r\n *\r\n * @return Amount of lamports required\r\n */\r\nexport async function getMinimumBalanceForRentExemptMint(\r\n    connection: Connection,\r\n    commitment?: Commitment,\r\n): Promise<number> {\r\n    return await getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);\r\n}\r\n\r\n/** Get the minimum lamport balance for a rent-exempt mint with extensions\r\n *\r\n * @param connection Connection to use\r\n * @param extensions Extension types included in the mint\r\n * @param commitment Desired level of commitment for querying the state\r\n *\r\n * @return Amount of lamports required\r\n */\r\nexport async function getMinimumBalanceForRentExemptMintWithExtensions(\r\n    connection: Connection,\r\n    extensions: ExtensionType[],\r\n    commitment?: Commitment,\r\n): Promise<number> {\r\n    const mintLen = getMintLen(extensions);\r\n    return await connection.getMinimumBalanceForRentExemption(mintLen, commitment);\r\n}\r\n\r\n/**\r\n * Async version of getAssociatedTokenAddressSync\r\n * For backwards compatibility\r\n *\r\n * @param mint                     Token mint account\r\n * @param owner                    Owner of the new account\r\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\r\n * @param programId                SPL Token program account\r\n * @param associatedTokenProgramId SPL Associated Token program account\r\n *\r\n * @return Promise containing the address of the associated token account\r\n */\r\nexport async function getAssociatedTokenAddress(\r\n    mint: PublicKey,\r\n    owner: PublicKey,\r\n    allowOwnerOffCurve = false,\r\n    programId = TOKEN_PROGRAM_ID,\r\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\r\n): Promise<PublicKey> {\r\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\r\n\r\n    const [address] = await PublicKey.findProgramAddress(\r\n        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],\r\n        associatedTokenProgramId,\r\n    );\r\n\r\n    return address;\r\n}\r\n\r\n/**\r\n * Get the address of the associated token account for a given mint and owner\r\n *\r\n * @param mint                     Token mint account\r\n * @param owner                    Owner of the new account\r\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\r\n * @param programId                SPL Token program account\r\n * @param associatedTokenProgramId SPL Associated Token program account\r\n *\r\n * @return Address of the associated token account\r\n */\r\nexport function getAssociatedTokenAddressSync(\r\n    mint: PublicKey,\r\n    owner: PublicKey,\r\n    allowOwnerOffCurve = false,\r\n    programId = TOKEN_PROGRAM_ID,\r\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\r\n): PublicKey {\r\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\r\n\r\n    const [address] = PublicKey.findProgramAddressSync(\r\n        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],\r\n        associatedTokenProgramId,\r\n    );\r\n\r\n    return address;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}