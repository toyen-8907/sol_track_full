{"ast":null,"code":"import { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { createInitializeInstruction, createRemoveKeyInstruction, createUpdateAuthorityInstruction, createUpdateFieldInstruction, pack, unpack } from '@solana/spl-token-metadata';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { ExtensionType, getExtensionData, getNewAccountLenForExtensionLen } from '../extensionType.js';\nimport { updateTokenMetadata } from './state.js';\nimport { TokenAccountNotFoundError } from '../../errors.js';\nimport { unpackMint } from '../../state/index.js';\nasync function getAdditionalRentForNewMetadata(connection, address, tokenMetadata, programId = TOKEN_2022_PROGRAM_ID) {\n  const info = await connection.getAccountInfo(address);\n  if (!info) {\n    throw new TokenAccountNotFoundError();\n  }\n  const extensionLen = pack(tokenMetadata).length;\n  const newAccountLen = getNewAccountLenForExtensionLen(info, address, ExtensionType.TokenMetadata, extensionLen, programId);\n  if (newAccountLen <= info.data.length) {\n    return 0;\n  }\n  const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n  return newRentExemptMinimum - info.lamports;\n}\nasync function getAdditionalRentForUpdatedMetadata(connection, address, field, value, programId = TOKEN_2022_PROGRAM_ID) {\n  const info = await connection.getAccountInfo(address);\n  if (!info) {\n    throw new TokenAccountNotFoundError();\n  }\n  const mint = unpackMint(address, info, programId);\n  const extensionData = getExtensionData(ExtensionType.TokenMetadata, mint.tlvData);\n  if (extensionData === null) {\n    throw new Error('TokenMetadata extension not initialized');\n  }\n  const updatedTokenMetadata = updateTokenMetadata(unpack(extensionData), field, value);\n  const extensionLen = pack(updatedTokenMetadata).length;\n  const newAccountLen = getNewAccountLenForExtensionLen(info, address, ExtensionType.TokenMetadata, extensionLen, programId);\n  if (newAccountLen <= info.data.length) {\n    return 0;\n  }\n  const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n  return newRentExemptMinimum - info.lamports;\n}\n/**\r\n * Initializes a TLV entry with the basic token-metadata fields.\r\n *\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param mintAuthority    Mint Authority\r\n * @param name             Longer name of token\r\n * @param symbol           Shortened symbol of token\r\n * @param uri              URI pointing to more metadata (image, video, etc)\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\nexport async function tokenMetadataInitialize(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n  const transaction = new Transaction().add(createInitializeInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority,\n    mint,\n    mintAuthority: mintAuthorityPublicKey,\n    name,\n    symbol,\n    uri\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\r\n * Initializes a TLV entry with the basic token-metadata fields,\r\n * Includes a transfer for any additional rent-exempt SOL if required.\r\n *\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param mintAuthority    Mint Authority\r\n * @param name             Longer name of token\r\n * @param symbol           Shortened symbol of token\r\n * @param uri              URI pointing to more metadata (image, video, etc)\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\nexport async function tokenMetadataInitializeWithRentTransfer(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n  const transaction = new Transaction();\n  const lamports = await getAdditionalRentForNewMetadata(connection, mint, {\n    updateAuthority,\n    mint,\n    name,\n    symbol,\n    uri,\n    additionalMetadata: []\n  }, programId);\n  if (lamports > 0) {\n    transaction.add(SystemProgram.transfer({\n      fromPubkey: payer.publicKey,\n      toPubkey: mint,\n      lamports: lamports\n    }));\n  }\n  transaction.add(createInitializeInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority,\n    mint,\n    mintAuthority: mintAuthorityPublicKey,\n    name,\n    symbol,\n    uri\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\r\n * Updates a field in a token-metadata account.\r\n * If the field does not exist on the account, it will be created.\r\n * If the field does exist, it will be overwritten.\r\n *\r\n * The field can be one of the required fields (name, symbol, URI), or a\r\n * totally new field denoted by a \"key\" string.\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param field            Field to update in the metadata\r\n * @param value            Value to write for the field\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\nexport async function tokenMetadataUpdateField(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction().add(createUpdateFieldInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority: updateAuthorityPublicKey,\n    field,\n    value\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\r\n * Updates a field in a token-metadata account.\r\n * If the field does not exist on the account, it will be created.\r\n * If the field does exist, it will be overwritten.\r\n * Includes a transfer for any additional rent-exempt SOL if required.\r\n *\r\n * The field can be one of the required fields (name, symbol, URI), or a\r\n * totally new field denoted by a \"key\" string.\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param field            Field to update in the metadata\r\n * @param value            Value to write for the field\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\nexport async function tokenMetadataUpdateFieldWithRentTransfer(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction();\n  const lamports = await getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);\n  if (lamports > 0) {\n    transaction.add(SystemProgram.transfer({\n      fromPubkey: payer.publicKey,\n      toPubkey: mint,\n      lamports: lamports\n    }));\n  }\n  transaction.add(createUpdateFieldInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority: updateAuthorityPublicKey,\n    field,\n    value\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\r\n * Remove a field in a token-metadata account.\r\n *\r\n * The field can be one of the required fields (name, symbol, URI), or a\r\n * totally new field denoted by a \"key\" string.\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param key              Key to remove in the additional metadata portion\r\n * @param idempotent       When true, instruction will not error if the key does not exist\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\nexport async function tokenMetadataRemoveKey(connection, payer, mint, updateAuthority, key, idempotent, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction().add(createRemoveKeyInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority: updateAuthorityPublicKey,\n    key,\n    idempotent\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\r\n *  Update authority\r\n *\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param newAuthority     New authority for the token metadata, or unset\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\nexport async function tokenMetadataUpdateAuthority(connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction().add(createUpdateAuthorityInstruction({\n    programId,\n    metadata: mint,\n    oldAuthority: updateAuthorityPublicKey,\n    newAuthority\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}","map":{"version":3,"names":["sendAndConfirmTransaction","SystemProgram","Transaction","createInitializeInstruction","createRemoveKeyInstruction","createUpdateAuthorityInstruction","createUpdateFieldInstruction","pack","unpack","TOKEN_2022_PROGRAM_ID","getSigners","ExtensionType","getExtensionData","getNewAccountLenForExtensionLen","updateTokenMetadata","TokenAccountNotFoundError","unpackMint","getAdditionalRentForNewMetadata","connection","address","tokenMetadata","programId","info","getAccountInfo","extensionLen","length","newAccountLen","TokenMetadata","data","newRentExemptMinimum","getMinimumBalanceForRentExemption","lamports","getAdditionalRentForUpdatedMetadata","field","value","mint","extensionData","tlvData","Error","updatedTokenMetadata","tokenMetadataInitialize","payer","updateAuthority","mintAuthority","name","symbol","uri","multiSigners","confirmOptions","mintAuthorityPublicKey","signers","transaction","add","metadata","tokenMetadataInitializeWithRentTransfer","additionalMetadata","transfer","fromPubkey","publicKey","toPubkey","tokenMetadataUpdateField","updateAuthorityPublicKey","tokenMetadataUpdateFieldWithRentTransfer","tokenMetadataRemoveKey","key","idempotent","tokenMetadataUpdateAuthority","newAuthority","oldAuthority"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token\\src\\extensions\\tokenMetadata\\actions.ts"],"sourcesContent":["import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\r\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\r\nimport type { Field, TokenMetadata } from '@solana/spl-token-metadata';\r\nimport {\r\n    createInitializeInstruction,\r\n    createRemoveKeyInstruction,\r\n    createUpdateAuthorityInstruction,\r\n    createUpdateFieldInstruction,\r\n    pack,\r\n    unpack,\r\n} from '@solana/spl-token-metadata';\r\n\r\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\r\nimport { getSigners } from '../../actions/internal.js';\r\nimport { ExtensionType, getExtensionData, getNewAccountLenForExtensionLen } from '../extensionType.js';\r\nimport { updateTokenMetadata } from './state.js';\r\nimport { TokenAccountNotFoundError } from '../../errors.js';\r\nimport { unpackMint } from '../../state/index.js';\r\n\r\nasync function getAdditionalRentForNewMetadata(\r\n    connection: Connection,\r\n    address: PublicKey,\r\n    tokenMetadata: TokenMetadata,\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): Promise<number> {\r\n    const info = await connection.getAccountInfo(address);\r\n    if (!info) {\r\n        throw new TokenAccountNotFoundError();\r\n    }\r\n\r\n    const extensionLen = pack(tokenMetadata).length;\r\n    const newAccountLen = getNewAccountLenForExtensionLen(\r\n        info,\r\n        address,\r\n        ExtensionType.TokenMetadata,\r\n        extensionLen,\r\n        programId,\r\n    );\r\n\r\n    if (newAccountLen <= info.data.length) {\r\n        return 0;\r\n    }\r\n\r\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\r\n\r\n    return newRentExemptMinimum - info.lamports;\r\n}\r\n\r\nasync function getAdditionalRentForUpdatedMetadata(\r\n    connection: Connection,\r\n    address: PublicKey,\r\n    field: string | Field,\r\n    value: string,\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): Promise<number> {\r\n    const info = await connection.getAccountInfo(address);\r\n    if (!info) {\r\n        throw new TokenAccountNotFoundError();\r\n    }\r\n\r\n    const mint = unpackMint(address, info, programId);\r\n    const extensionData = getExtensionData(ExtensionType.TokenMetadata, mint.tlvData);\r\n    if (extensionData === null) {\r\n        throw new Error('TokenMetadata extension not initialized');\r\n    }\r\n\r\n    const updatedTokenMetadata = updateTokenMetadata(unpack(extensionData), field, value);\r\n    const extensionLen = pack(updatedTokenMetadata).length;\r\n\r\n    const newAccountLen = getNewAccountLenForExtensionLen(\r\n        info,\r\n        address,\r\n        ExtensionType.TokenMetadata,\r\n        extensionLen,\r\n        programId,\r\n    );\r\n\r\n    if (newAccountLen <= info.data.length) {\r\n        return 0;\r\n    }\r\n\r\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\r\n\r\n    return newRentExemptMinimum - info.lamports;\r\n}\r\n\r\n/**\r\n * Initializes a TLV entry with the basic token-metadata fields.\r\n *\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param mintAuthority    Mint Authority\r\n * @param name             Longer name of token\r\n * @param symbol           Shortened symbol of token\r\n * @param uri              URI pointing to more metadata (image, video, etc)\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\r\nexport async function tokenMetadataInitialize(\r\n    connection: Connection,\r\n    payer: Signer,\r\n    mint: PublicKey,\r\n    updateAuthority: PublicKey,\r\n    mintAuthority: PublicKey | Signer,\r\n    name: string,\r\n    symbol: string,\r\n    uri: string,\r\n    multiSigners: Signer[] = [],\r\n    confirmOptions?: ConfirmOptions,\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): Promise<TransactionSignature> {\r\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\r\n\r\n    const transaction = new Transaction().add(\r\n        createInitializeInstruction({\r\n            programId,\r\n            metadata: mint,\r\n            updateAuthority,\r\n            mint,\r\n            mintAuthority: mintAuthorityPublicKey,\r\n            name,\r\n            symbol,\r\n            uri,\r\n        }),\r\n    );\r\n\r\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\r\n}\r\n\r\n/**\r\n * Initializes a TLV entry with the basic token-metadata fields,\r\n * Includes a transfer for any additional rent-exempt SOL if required.\r\n *\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param mintAuthority    Mint Authority\r\n * @param name             Longer name of token\r\n * @param symbol           Shortened symbol of token\r\n * @param uri              URI pointing to more metadata (image, video, etc)\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\r\nexport async function tokenMetadataInitializeWithRentTransfer(\r\n    connection: Connection,\r\n    payer: Signer,\r\n    mint: PublicKey,\r\n    updateAuthority: PublicKey,\r\n    mintAuthority: PublicKey | Signer,\r\n    name: string,\r\n    symbol: string,\r\n    uri: string,\r\n    multiSigners: Signer[] = [],\r\n    confirmOptions?: ConfirmOptions,\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): Promise<TransactionSignature> {\r\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\r\n\r\n    const transaction = new Transaction();\r\n\r\n    const lamports = await getAdditionalRentForNewMetadata(\r\n        connection,\r\n        mint,\r\n        {\r\n            updateAuthority,\r\n            mint,\r\n            name,\r\n            symbol,\r\n            uri,\r\n            additionalMetadata: [],\r\n        },\r\n        programId,\r\n    );\r\n\r\n    if (lamports > 0) {\r\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\r\n    }\r\n\r\n    transaction.add(\r\n        createInitializeInstruction({\r\n            programId,\r\n            metadata: mint,\r\n            updateAuthority,\r\n            mint,\r\n            mintAuthority: mintAuthorityPublicKey,\r\n            name,\r\n            symbol,\r\n            uri,\r\n        }),\r\n    );\r\n\r\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\r\n}\r\n\r\n/**\r\n * Updates a field in a token-metadata account.\r\n * If the field does not exist on the account, it will be created.\r\n * If the field does exist, it will be overwritten.\r\n *\r\n * The field can be one of the required fields (name, symbol, URI), or a\r\n * totally new field denoted by a \"key\" string.\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param field            Field to update in the metadata\r\n * @param value            Value to write for the field\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\r\nexport async function tokenMetadataUpdateField(\r\n    connection: Connection,\r\n    payer: Signer,\r\n    mint: PublicKey,\r\n    updateAuthority: PublicKey | Signer,\r\n    field: string | Field,\r\n    value: string,\r\n    multiSigners: Signer[] = [],\r\n    confirmOptions?: ConfirmOptions,\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): Promise<TransactionSignature> {\r\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\r\n\r\n    const transaction = new Transaction().add(\r\n        createUpdateFieldInstruction({\r\n            programId,\r\n            metadata: mint,\r\n            updateAuthority: updateAuthorityPublicKey,\r\n            field,\r\n            value,\r\n        }),\r\n    );\r\n\r\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\r\n}\r\n\r\n/**\r\n * Updates a field in a token-metadata account.\r\n * If the field does not exist on the account, it will be created.\r\n * If the field does exist, it will be overwritten.\r\n * Includes a transfer for any additional rent-exempt SOL if required.\r\n *\r\n * The field can be one of the required fields (name, symbol, URI), or a\r\n * totally new field denoted by a \"key\" string.\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param field            Field to update in the metadata\r\n * @param value            Value to write for the field\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\r\nexport async function tokenMetadataUpdateFieldWithRentTransfer(\r\n    connection: Connection,\r\n    payer: Signer,\r\n    mint: PublicKey,\r\n    updateAuthority: PublicKey | Signer,\r\n    field: string | Field,\r\n    value: string,\r\n    multiSigners: Signer[] = [],\r\n    confirmOptions?: ConfirmOptions,\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): Promise<TransactionSignature> {\r\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\r\n\r\n    const transaction = new Transaction();\r\n\r\n    const lamports = await getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);\r\n\r\n    if (lamports > 0) {\r\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\r\n    }\r\n\r\n    transaction.add(\r\n        createUpdateFieldInstruction({\r\n            programId,\r\n            metadata: mint,\r\n            updateAuthority: updateAuthorityPublicKey,\r\n            field,\r\n            value,\r\n        }),\r\n    );\r\n\r\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\r\n}\r\n\r\n/**\r\n * Remove a field in a token-metadata account.\r\n *\r\n * The field can be one of the required fields (name, symbol, URI), or a\r\n * totally new field denoted by a \"key\" string.\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param key              Key to remove in the additional metadata portion\r\n * @param idempotent       When true, instruction will not error if the key does not exist\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\r\nexport async function tokenMetadataRemoveKey(\r\n    connection: Connection,\r\n    payer: Signer,\r\n    mint: PublicKey,\r\n    updateAuthority: PublicKey | Signer,\r\n    key: string,\r\n    idempotent: boolean,\r\n    multiSigners: Signer[] = [],\r\n    confirmOptions?: ConfirmOptions,\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): Promise<TransactionSignature> {\r\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\r\n\r\n    const transaction = new Transaction().add(\r\n        createRemoveKeyInstruction({\r\n            programId,\r\n            metadata: mint,\r\n            updateAuthority: updateAuthorityPublicKey,\r\n            key,\r\n            idempotent,\r\n        }),\r\n    );\r\n\r\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\r\n}\r\n\r\n/**\r\n *  Update authority\r\n *\r\n * @param connection       Connection to use\r\n * @param payer            Payer of the transaction fees\r\n * @param mint             Mint Account\r\n * @param updateAuthority  Update Authority\r\n * @param newAuthority     New authority for the token metadata, or unset\r\n * @param multiSigners     Signing accounts if `authority` is a multisig\r\n * @param confirmOptions   Options for confirming the transaction\r\n * @param programId        SPL Token program account\r\n *\r\n * @return Signature of the confirmed transaction\r\n */\r\nexport async function tokenMetadataUpdateAuthority(\r\n    connection: Connection,\r\n    payer: Signer,\r\n    mint: PublicKey,\r\n    updateAuthority: PublicKey | Signer,\r\n    newAuthority: PublicKey | null,\r\n    multiSigners: Signer[] = [],\r\n    confirmOptions?: ConfirmOptions,\r\n    programId = TOKEN_2022_PROGRAM_ID,\r\n): Promise<TransactionSignature> {\r\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\r\n\r\n    const transaction = new Transaction().add(\r\n        createUpdateAuthorityInstruction({\r\n            programId,\r\n            metadata: mint,\r\n            oldAuthority: updateAuthorityPublicKey,\r\n            newAuthority,\r\n        }),\r\n    );\r\n\r\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}