{"ast":null,"code":"import { blob, greedy, seq, struct, u32, u8 } from '@solana/buffer-layout';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { TokenTransferHookAccountNotFound } from '../../errors.js';\nimport { unpackSeeds } from './seeds.js';\n/** Buffer layout for de/serializing a transfer hook extension */\nexport const TransferHookLayout = struct([publicKey('authority'), publicKey('programId')]);\nexport const TRANSFER_HOOK_SIZE = TransferHookLayout.span;\nexport function getTransferHook(mint) {\n  const extensionData = getExtensionData(ExtensionType.TransferHook, mint.tlvData);\n  if (extensionData !== null) {\n    return TransferHookLayout.decode(extensionData);\n  } else {\n    return null;\n  }\n}\n/** Buffer layout for de/serializing a transfer hook account extension */\nexport const TransferHookAccountLayout = struct([bool('transferring')]);\nexport const TRANSFER_HOOK_ACCOUNT_SIZE = TransferHookAccountLayout.span;\nexport function getTransferHookAccount(account) {\n  const extensionData = getExtensionData(ExtensionType.TransferHookAccount, account.tlvData);\n  if (extensionData !== null) {\n    return TransferHookAccountLayout.decode(extensionData);\n  } else {\n    return null;\n  }\n}\nexport function getExtraAccountMetaAddress(mint, programId) {\n  const seeds = [Buffer.from('extra-account-metas'), mint.toBuffer()];\n  return PublicKey.findProgramAddressSync(seeds, programId)[0];\n}\n/** Buffer layout for de/serializing an ExtraAccountMeta */\nexport const ExtraAccountMetaLayout = struct([u8('discriminator'), blob(32, 'addressConfig'), bool('isSigner'), bool('isWritable')]);\n/** Buffer layout for de/serializing a list of ExtraAccountMeta prefixed by a u32 length */\nexport const ExtraAccountMetaListLayout = struct([u32('count'), seq(ExtraAccountMetaLayout, greedy(ExtraAccountMetaLayout.span), 'extraAccounts')]);\n/** Buffer layout for de/serializing an ExtraAccountMetaAccountData */\nexport const ExtraAccountMetaAccountDataLayout = struct([u64('instructionDiscriminator'), u32('length'), ExtraAccountMetaListLayout.replicate('extraAccountsList')]);\n/** Unpack an extra account metas account and parse the data into a list of ExtraAccountMetas */\nexport function getExtraAccountMetas(account) {\n  const extraAccountsList = ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;\n  return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);\n}\n/** Take an ExtraAccountMeta and construct that into an actual AccountMeta */\nexport async function resolveExtraAccountMeta(connection, extraMeta, previousMetas, instructionData, transferHookProgramId) {\n  if (extraMeta.discriminator === 0) {\n    return {\n      pubkey: new PublicKey(extraMeta.addressConfig),\n      isSigner: extraMeta.isSigner,\n      isWritable: extraMeta.isWritable\n    };\n  }\n  let programId = PublicKey.default;\n  if (extraMeta.discriminator === 1) {\n    programId = transferHookProgramId;\n  } else {\n    const accountIndex = extraMeta.discriminator - (1 << 7);\n    if (previousMetas.length <= accountIndex) {\n      throw new TokenTransferHookAccountNotFound();\n    }\n    programId = previousMetas[accountIndex].pubkey;\n  }\n  const seeds = await unpackSeeds(extraMeta.addressConfig, previousMetas, instructionData, connection);\n  const pubkey = PublicKey.findProgramAddressSync(seeds, programId)[0];\n  return {\n    pubkey,\n    isSigner: extraMeta.isSigner,\n    isWritable: extraMeta.isWritable\n  };\n}","map":{"version":3,"names":["blob","greedy","seq","struct","u32","u8","ExtensionType","getExtensionData","PublicKey","bool","publicKey","u64","TokenTransferHookAccountNotFound","unpackSeeds","TransferHookLayout","TRANSFER_HOOK_SIZE","span","getTransferHook","mint","extensionData","TransferHook","tlvData","decode","TransferHookAccountLayout","TRANSFER_HOOK_ACCOUNT_SIZE","getTransferHookAccount","account","TransferHookAccount","getExtraAccountMetaAddress","programId","seeds","Buffer","from","toBuffer","findProgramAddressSync","ExtraAccountMetaLayout","ExtraAccountMetaListLayout","ExtraAccountMetaAccountDataLayout","replicate","getExtraAccountMetas","extraAccountsList","data","extraAccounts","slice","count","resolveExtraAccountMeta","connection","extraMeta","previousMetas","instructionData","transferHookProgramId","discriminator","pubkey","addressConfig","isSigner","isWritable","default","accountIndex","length"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token\\src\\extensions\\transferHook\\state.ts"],"sourcesContent":["import { blob, greedy, seq, struct, u32, u8 } from '@solana/buffer-layout';\r\nimport type { Mint } from '../../state/mint.js';\r\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\r\nimport type { AccountInfo, AccountMeta, Connection } from '@solana/web3.js';\r\nimport { PublicKey } from '@solana/web3.js';\r\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\r\nimport type { Account } from '../../state/account.js';\r\nimport { TokenTransferHookAccountNotFound } from '../../errors.js';\r\nimport { unpackSeeds } from './seeds.js';\r\n\r\n/** TransferHook as stored by the program */\r\nexport interface TransferHook {\r\n    /** The transfer hook update authority */\r\n    authority: PublicKey;\r\n    /** The transfer hook program account */\r\n    programId: PublicKey;\r\n}\r\n\r\n/** Buffer layout for de/serializing a transfer hook extension */\r\nexport const TransferHookLayout = struct<TransferHook>([publicKey('authority'), publicKey('programId')]);\r\n\r\nexport const TRANSFER_HOOK_SIZE = TransferHookLayout.span;\r\n\r\nexport function getTransferHook(mint: Mint): TransferHook | null {\r\n    const extensionData = getExtensionData(ExtensionType.TransferHook, mint.tlvData);\r\n    if (extensionData !== null) {\r\n        return TransferHookLayout.decode(extensionData);\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/** TransferHookAccount as stored by the program */\r\nexport interface TransferHookAccount {\r\n    /**\r\n     * Whether or not this account is currently transferring tokens\r\n     * True during the transfer hook cpi, otherwise false\r\n     */\r\n    transferring: boolean;\r\n}\r\n\r\n/** Buffer layout for de/serializing a transfer hook account extension */\r\nexport const TransferHookAccountLayout = struct<TransferHookAccount>([bool('transferring')]);\r\n\r\nexport const TRANSFER_HOOK_ACCOUNT_SIZE = TransferHookAccountLayout.span;\r\n\r\nexport function getTransferHookAccount(account: Account): TransferHookAccount | null {\r\n    const extensionData = getExtensionData(ExtensionType.TransferHookAccount, account.tlvData);\r\n    if (extensionData !== null) {\r\n        return TransferHookAccountLayout.decode(extensionData);\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function getExtraAccountMetaAddress(mint: PublicKey, programId: PublicKey): PublicKey {\r\n    const seeds = [Buffer.from('extra-account-metas'), mint.toBuffer()];\r\n    return PublicKey.findProgramAddressSync(seeds, programId)[0];\r\n}\r\n\r\n/** ExtraAccountMeta as stored by the transfer hook program */\r\nexport interface ExtraAccountMeta {\r\n    discriminator: number;\r\n    addressConfig: Uint8Array;\r\n    isSigner: boolean;\r\n    isWritable: boolean;\r\n}\r\n\r\n/** Buffer layout for de/serializing an ExtraAccountMeta */\r\nexport const ExtraAccountMetaLayout = struct<ExtraAccountMeta>([\r\n    u8('discriminator'),\r\n    blob(32, 'addressConfig'),\r\n    bool('isSigner'),\r\n    bool('isWritable'),\r\n]);\r\n\r\nexport interface ExtraAccountMetaList {\r\n    count: number;\r\n    extraAccounts: ExtraAccountMeta[];\r\n}\r\n\r\n/** Buffer layout for de/serializing a list of ExtraAccountMeta prefixed by a u32 length */\r\nexport const ExtraAccountMetaListLayout = struct<ExtraAccountMetaList>([\r\n    u32('count'),\r\n    seq<ExtraAccountMeta>(ExtraAccountMetaLayout, greedy(ExtraAccountMetaLayout.span), 'extraAccounts'),\r\n]);\r\n\r\n/** Buffer layout for de/serializing a list of ExtraAccountMetaAccountData prefixed by a u32 length */\r\nexport interface ExtraAccountMetaAccountData {\r\n    instructionDiscriminator: bigint;\r\n    length: number;\r\n    extraAccountsList: ExtraAccountMetaList;\r\n}\r\n\r\n/** Buffer layout for de/serializing an ExtraAccountMetaAccountData */\r\nexport const ExtraAccountMetaAccountDataLayout = struct<ExtraAccountMetaAccountData>([\r\n    u64('instructionDiscriminator'),\r\n    u32('length'),\r\n    ExtraAccountMetaListLayout.replicate('extraAccountsList'),\r\n]);\r\n\r\n/** Unpack an extra account metas account and parse the data into a list of ExtraAccountMetas */\r\nexport function getExtraAccountMetas(account: AccountInfo<Buffer>): ExtraAccountMeta[] {\r\n    const extraAccountsList = ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;\r\n    return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);\r\n}\r\n\r\n/** Take an ExtraAccountMeta and construct that into an actual AccountMeta */\r\nexport async function resolveExtraAccountMeta(\r\n    connection: Connection,\r\n    extraMeta: ExtraAccountMeta,\r\n    previousMetas: AccountMeta[],\r\n    instructionData: Buffer,\r\n    transferHookProgramId: PublicKey,\r\n): Promise<AccountMeta> {\r\n    if (extraMeta.discriminator === 0) {\r\n        return {\r\n            pubkey: new PublicKey(extraMeta.addressConfig),\r\n            isSigner: extraMeta.isSigner,\r\n            isWritable: extraMeta.isWritable,\r\n        };\r\n    }\r\n\r\n    let programId = PublicKey.default;\r\n\r\n    if (extraMeta.discriminator === 1) {\r\n        programId = transferHookProgramId;\r\n    } else {\r\n        const accountIndex = extraMeta.discriminator - (1 << 7);\r\n        if (previousMetas.length <= accountIndex) {\r\n            throw new TokenTransferHookAccountNotFound();\r\n        }\r\n        programId = previousMetas[accountIndex].pubkey;\r\n    }\r\n\r\n    const seeds = await unpackSeeds(extraMeta.addressConfig, previousMetas, instructionData, connection);\r\n    const pubkey = PublicKey.findProgramAddressSync(seeds, programId)[0];\r\n\r\n    return { pubkey, isSigner: extraMeta.isSigner, isWritable: extraMeta.isWritable };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}