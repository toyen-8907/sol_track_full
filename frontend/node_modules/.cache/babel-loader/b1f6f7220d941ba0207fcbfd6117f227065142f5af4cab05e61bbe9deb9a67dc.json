{"ast":null,"code":"import { struct, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey } from '@solana/buffer-layout-utils';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors.js';\n/** Buffer layout for de/serializing a multisig */\nexport const MultisigLayout = struct([u8('m'), u8('n'), bool('isInitialized'), publicKey('signer1'), publicKey('signer2'), publicKey('signer3'), publicKey('signer4'), publicKey('signer5'), publicKey('signer6'), publicKey('signer7'), publicKey('signer8'), publicKey('signer9'), publicKey('signer10'), publicKey('signer11')]);\n/** Byte length of a multisig */\nexport const MULTISIG_SIZE = MultisigLayout.span;\n/**\r\n * Retrieve information about a multisig\r\n *\r\n * @param connection Connection to use\r\n * @param address    Multisig account\r\n * @param commitment Desired level of commitment for querying the state\r\n * @param programId  SPL Token program account\r\n *\r\n * @return Multisig information\r\n */\nexport async function getMultisig(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {\n  const info = await connection.getAccountInfo(address, commitment);\n  return unpackMultisig(address, info, programId);\n}\n/**\r\n * Unpack a multisig\r\n *\r\n * @param address   Multisig account\r\n * @param info      Multisig account data\r\n * @param programId SPL Token program account\r\n *\r\n * @return Unpacked multisig\r\n */\nexport function unpackMultisig(address, info, programId = TOKEN_PROGRAM_ID) {\n  if (!info) throw new TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n  if (info.data.length != MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n  const multisig = MultisigLayout.decode(info.data);\n  return {\n    address,\n    ...multisig\n  };\n}\n/** Get the minimum lamport balance for a multisig to be rent exempt\r\n *\r\n * @param connection Connection to use\r\n * @param commitment Desired level of commitment for querying the state\r\n *\r\n * @return Amount of lamports required\r\n */\nexport async function getMinimumBalanceForRentExemptMultisig(connection, commitment) {\n  return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);\n}","map":{"version":3,"names":["struct","u8","bool","publicKey","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidAccountSizeError","MultisigLayout","MULTISIG_SIZE","span","getMultisig","connection","address","commitment","programId","info","getAccountInfo","unpackMultisig","owner","equals","data","length","multisig","decode","getMinimumBalanceForRentExemptMultisig","getMinimumBalanceForRentExemption"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token\\src\\state\\multisig.ts"],"sourcesContent":["import { struct, u8 } from '@solana/buffer-layout';\r\nimport { bool, publicKey } from '@solana/buffer-layout-utils';\r\nimport type { AccountInfo, Commitment, Connection, PublicKey } from '@solana/web3.js';\r\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\r\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors.js';\r\n\r\n/** Information about a multisig */\r\nexport interface Multisig {\r\n    /** Address of the multisig */\r\n    address: PublicKey;\r\n    /** Number of signers required */\r\n    m: number;\r\n    /** Number of possible signers, corresponds to the number of `signers` that are valid */\r\n    n: number;\r\n    /** Is this mint initialized */\r\n    isInitialized: boolean;\r\n    /** Full set of signers, of which `n` are valid */\r\n    signer1: PublicKey;\r\n    signer2: PublicKey;\r\n    signer3: PublicKey;\r\n    signer4: PublicKey;\r\n    signer5: PublicKey;\r\n    signer6: PublicKey;\r\n    signer7: PublicKey;\r\n    signer8: PublicKey;\r\n    signer9: PublicKey;\r\n    signer10: PublicKey;\r\n    signer11: PublicKey;\r\n}\r\n\r\n/** Multisig as stored by the program */\r\nexport type RawMultisig = Omit<Multisig, 'address'>;\r\n\r\n/** Buffer layout for de/serializing a multisig */\r\nexport const MultisigLayout = struct<RawMultisig>([\r\n    u8('m'),\r\n    u8('n'),\r\n    bool('isInitialized'),\r\n    publicKey('signer1'),\r\n    publicKey('signer2'),\r\n    publicKey('signer3'),\r\n    publicKey('signer4'),\r\n    publicKey('signer5'),\r\n    publicKey('signer6'),\r\n    publicKey('signer7'),\r\n    publicKey('signer8'),\r\n    publicKey('signer9'),\r\n    publicKey('signer10'),\r\n    publicKey('signer11'),\r\n]);\r\n\r\n/** Byte length of a multisig */\r\nexport const MULTISIG_SIZE = MultisigLayout.span;\r\n\r\n/**\r\n * Retrieve information about a multisig\r\n *\r\n * @param connection Connection to use\r\n * @param address    Multisig account\r\n * @param commitment Desired level of commitment for querying the state\r\n * @param programId  SPL Token program account\r\n *\r\n * @return Multisig information\r\n */\r\nexport async function getMultisig(\r\n    connection: Connection,\r\n    address: PublicKey,\r\n    commitment?: Commitment,\r\n    programId = TOKEN_PROGRAM_ID,\r\n): Promise<Multisig> {\r\n    const info = await connection.getAccountInfo(address, commitment);\r\n    return unpackMultisig(address, info, programId);\r\n}\r\n\r\n/**\r\n * Unpack a multisig\r\n *\r\n * @param address   Multisig account\r\n * @param info      Multisig account data\r\n * @param programId SPL Token program account\r\n *\r\n * @return Unpacked multisig\r\n */\r\nexport function unpackMultisig(\r\n    address: PublicKey,\r\n    info: AccountInfo<Buffer> | null,\r\n    programId = TOKEN_PROGRAM_ID,\r\n): Multisig {\r\n    if (!info) throw new TokenAccountNotFoundError();\r\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\r\n    if (info.data.length != MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\r\n\r\n    const multisig = MultisigLayout.decode(info.data);\r\n\r\n    return { address, ...multisig };\r\n}\r\n\r\n/** Get the minimum lamport balance for a multisig to be rent exempt\r\n *\r\n * @param connection Connection to use\r\n * @param commitment Desired level of commitment for querying the state\r\n *\r\n * @return Amount of lamports required\r\n */\r\nexport async function getMinimumBalanceForRentExemptMultisig(\r\n    connection: Connection,\r\n    commitment?: Commitment,\r\n): Promise<number> {\r\n    return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);\r\n}\r\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,EAAE,QAAQ,uBAAuB;AAClD,SAASC,IAAI,EAAEC,SAAS,QAAQ,6BAA6B;AAE7D,SAASC,gBAAgB,QAAQ,iBAAiB;AAClD,SAASC,yBAAyB,EAAEC,6BAA6B,EAAEC,4BAA4B,QAAQ,cAAc;AA6BrH;AACA,OAAO,MAAMC,cAAc,GAAGR,MAAM,CAAc,CAC9CC,EAAE,CAAC,GAAG,CAAC,EACPA,EAAE,CAAC,GAAG,CAAC,EACPC,IAAI,CAAC,eAAe,CAAC,EACrBC,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,UAAU,CAAC,EACrBA,SAAS,CAAC,UAAU,CAAC,CACxB,CAAC;AAEF;AACA,OAAO,MAAMM,aAAa,GAAGD,cAAc,CAACE,IAAI;AAEhD;;;;;;;;;;AAUA,OAAO,eAAeC,WAAWA,CAC7BC,UAAsB,EACtBC,OAAkB,EAClBC,UAAuB,EACvBC,SAAS,GAAGX,gBAAgB;EAE5B,MAAMY,IAAI,GAAG,MAAMJ,UAAU,CAACK,cAAc,CAACJ,OAAO,EAAEC,UAAU,CAAC;EACjE,OAAOI,cAAc,CAACL,OAAO,EAAEG,IAAI,EAAED,SAAS,CAAC;AACnD;AAEA;;;;;;;;;AASA,OAAM,SAAUG,cAAcA,CAC1BL,OAAkB,EAClBG,IAAgC,EAChCD,SAAS,GAAGX,gBAAgB;EAE5B,IAAI,CAACY,IAAI,EAAE,MAAM,IAAIX,yBAAyB,EAAE;EAChD,IAAI,CAACW,IAAI,CAACG,KAAK,CAACC,MAAM,CAACL,SAAS,CAAC,EAAE,MAAM,IAAIT,6BAA6B,EAAE;EAC5E,IAAIU,IAAI,CAACK,IAAI,CAACC,MAAM,IAAIb,aAAa,EAAE,MAAM,IAAIF,4BAA4B,EAAE;EAE/E,MAAMgB,QAAQ,GAAGf,cAAc,CAACgB,MAAM,CAACR,IAAI,CAACK,IAAI,CAAC;EAEjD,OAAO;IAAER,OAAO;IAAE,GAAGU;EAAQ,CAAE;AACnC;AAEA;;;;;;;AAOA,OAAO,eAAeE,sCAAsCA,CACxDb,UAAsB,EACtBE,UAAuB;EAEvB,OAAO,MAAMF,UAAU,CAACc,iCAAiC,CAACjB,aAAa,EAAEK,UAAU,CAAC;AACxF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}