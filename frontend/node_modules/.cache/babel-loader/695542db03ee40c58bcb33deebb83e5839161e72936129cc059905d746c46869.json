{"ast":null,"code":"import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport { getAccountLen } from '../extensions/extensionType.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n/** Token account state as stored by the program */\nexport var AccountState;\n(function (AccountState) {\n  AccountState[AccountState[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  AccountState[AccountState[\"Initialized\"] = 1] = \"Initialized\";\n  AccountState[AccountState[\"Frozen\"] = 2] = \"Frozen\";\n})(AccountState || (AccountState = {}));\n/** Buffer layout for de/serializing a token account */\nexport const AccountLayout = struct([publicKey('mint'), publicKey('owner'), u64('amount'), u32('delegateOption'), publicKey('delegate'), u8('state'), u32('isNativeOption'), u64('isNative'), u64('delegatedAmount'), u32('closeAuthorityOption'), publicKey('closeAuthority')]);\n/** Byte length of a token account */\nexport const ACCOUNT_SIZE = AccountLayout.span;\n/**\r\n * Retrieve information about a token account\r\n *\r\n * @param connection Connection to use\r\n * @param address    Token account\r\n * @param commitment Desired level of commitment for querying the state\r\n * @param programId  SPL Token program account\r\n *\r\n * @return Token account information\r\n */\nexport async function getAccount(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {\n  const info = await connection.getAccountInfo(address, commitment);\n  return unpackAccount(address, info, programId);\n}\n/**\r\n * Retrieve information about multiple token accounts in a single RPC call\r\n *\r\n * @param connection Connection to use\r\n * @param addresses  Token accounts\r\n * @param commitment Desired level of commitment for querying the state\r\n * @param programId  SPL Token program account\r\n *\r\n * @return Token account information\r\n */\nexport async function getMultipleAccounts(connection, addresses, commitment, programId = TOKEN_PROGRAM_ID) {\n  const infos = await connection.getMultipleAccountsInfo(addresses, commitment);\n  return addresses.map((address, i) => unpackAccount(address, infos[i], programId));\n}\n/** Get the minimum lamport balance for a base token account to be rent exempt\r\n *\r\n * @param connection Connection to use\r\n * @param commitment Desired level of commitment for querying the state\r\n *\r\n * @return Amount of lamports required\r\n */\nexport async function getMinimumBalanceForRentExemptAccount(connection, commitment) {\n  return await getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);\n}\n/** Get the minimum lamport balance for a rent-exempt token account with extensions\r\n *\r\n * @param connection Connection to use\r\n * @param commitment Desired level of commitment for querying the state\r\n *\r\n * @return Amount of lamports required\r\n */\nexport async function getMinimumBalanceForRentExemptAccountWithExtensions(connection, extensions, commitment) {\n  const accountLen = getAccountLen(extensions);\n  return await connection.getMinimumBalanceForRentExemption(accountLen, commitment);\n}\n/**\r\n * Unpack a token account\r\n *\r\n * @param address   Token account\r\n * @param info      Token account data\r\n * @param programId SPL Token program account\r\n *\r\n * @return Unpacked token account\r\n */\nexport function unpackAccount(address, info, programId = TOKEN_PROGRAM_ID) {\n  if (!info) throw new TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n  if (info.data.length < ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n  const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));\n  let tlvData = Buffer.alloc(0);\n  if (info.data.length > ACCOUNT_SIZE) {\n    if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n    if (info.data[ACCOUNT_SIZE] != AccountType.Account) throw new TokenInvalidAccountError();\n    tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n  }\n  return {\n    address,\n    mint: rawAccount.mint,\n    owner: rawAccount.owner,\n    amount: rawAccount.amount,\n    delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n    delegatedAmount: rawAccount.delegatedAmount,\n    isInitialized: rawAccount.state !== AccountState.Uninitialized,\n    isFrozen: rawAccount.state === AccountState.Frozen,\n    isNative: !!rawAccount.isNativeOption,\n    rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n    closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n    tlvData\n  };\n}","map":{"version":3,"names":["struct","u32","u8","publicKey","u64","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountError","TokenInvalidAccountOwnerError","TokenInvalidAccountSizeError","ACCOUNT_TYPE_SIZE","AccountType","getAccountLen","MULTISIG_SIZE","AccountState","AccountLayout","ACCOUNT_SIZE","span","getAccount","connection","address","commitment","programId","info","getAccountInfo","unpackAccount","getMultipleAccounts","addresses","infos","getMultipleAccountsInfo","map","i","getMinimumBalanceForRentExemptAccount","getMinimumBalanceForRentExemptAccountWithExtensions","extensions","accountLen","getMinimumBalanceForRentExemption","owner","equals","data","length","rawAccount","decode","slice","tlvData","Buffer","alloc","Account","mint","amount","delegate","delegateOption","delegatedAmount","isInitialized","state","Uninitialized","isFrozen","Frozen","isNative","isNativeOption","rentExemptReserve","closeAuthority","closeAuthorityOption"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token\\src\\state\\account.ts"],"sourcesContent":["import { struct, u32, u8 } from '@solana/buffer-layout';\r\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\r\nimport type { AccountInfo, Commitment, Connection, PublicKey } from '@solana/web3.js';\r\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\r\nimport {\r\n    TokenAccountNotFoundError,\r\n    TokenInvalidAccountError,\r\n    TokenInvalidAccountOwnerError,\r\n    TokenInvalidAccountSizeError,\r\n} from '../errors.js';\r\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\r\nimport type { ExtensionType } from '../extensions/extensionType.js';\r\nimport { getAccountLen } from '../extensions/extensionType.js';\r\nimport { MULTISIG_SIZE } from './multisig.js';\r\n\r\n/** Information about a token account */\r\nexport interface Account {\r\n    /** Address of the account */\r\n    address: PublicKey;\r\n    /** Mint associated with the account */\r\n    mint: PublicKey;\r\n    /** Owner of the account */\r\n    owner: PublicKey;\r\n    /** Number of tokens the account holds */\r\n    amount: bigint;\r\n    /** Authority that can transfer tokens from the account */\r\n    delegate: PublicKey | null;\r\n    /** Number of tokens the delegate is authorized to transfer */\r\n    delegatedAmount: bigint;\r\n    /** True if the account is initialized */\r\n    isInitialized: boolean;\r\n    /** True if the account is frozen */\r\n    isFrozen: boolean;\r\n    /** True if the account is a native token account */\r\n    isNative: boolean;\r\n    /**\r\n     * If the account is a native token account, it must be rent-exempt. The rent-exempt reserve is the amount that must\r\n     * remain in the balance until the account is closed.\r\n     */\r\n    rentExemptReserve: bigint | null;\r\n    /** Optional authority to close the account */\r\n    closeAuthority: PublicKey | null;\r\n    tlvData: Buffer;\r\n}\r\n\r\n/** Token account state as stored by the program */\r\nexport enum AccountState {\r\n    Uninitialized = 0,\r\n    Initialized = 1,\r\n    Frozen = 2,\r\n}\r\n\r\n/** Token account as stored by the program */\r\nexport interface RawAccount {\r\n    mint: PublicKey;\r\n    owner: PublicKey;\r\n    amount: bigint;\r\n    delegateOption: 1 | 0;\r\n    delegate: PublicKey;\r\n    state: AccountState;\r\n    isNativeOption: 1 | 0;\r\n    isNative: bigint;\r\n    delegatedAmount: bigint;\r\n    closeAuthorityOption: 1 | 0;\r\n    closeAuthority: PublicKey;\r\n}\r\n\r\n/** Buffer layout for de/serializing a token account */\r\nexport const AccountLayout = struct<RawAccount>([\r\n    publicKey('mint'),\r\n    publicKey('owner'),\r\n    u64('amount'),\r\n    u32('delegateOption'),\r\n    publicKey('delegate'),\r\n    u8('state'),\r\n    u32('isNativeOption'),\r\n    u64('isNative'),\r\n    u64('delegatedAmount'),\r\n    u32('closeAuthorityOption'),\r\n    publicKey('closeAuthority'),\r\n]);\r\n\r\n/** Byte length of a token account */\r\nexport const ACCOUNT_SIZE = AccountLayout.span;\r\n\r\n/**\r\n * Retrieve information about a token account\r\n *\r\n * @param connection Connection to use\r\n * @param address    Token account\r\n * @param commitment Desired level of commitment for querying the state\r\n * @param programId  SPL Token program account\r\n *\r\n * @return Token account information\r\n */\r\nexport async function getAccount(\r\n    connection: Connection,\r\n    address: PublicKey,\r\n    commitment?: Commitment,\r\n    programId = TOKEN_PROGRAM_ID,\r\n): Promise<Account> {\r\n    const info = await connection.getAccountInfo(address, commitment);\r\n    return unpackAccount(address, info, programId);\r\n}\r\n\r\n/**\r\n * Retrieve information about multiple token accounts in a single RPC call\r\n *\r\n * @param connection Connection to use\r\n * @param addresses  Token accounts\r\n * @param commitment Desired level of commitment for querying the state\r\n * @param programId  SPL Token program account\r\n *\r\n * @return Token account information\r\n */\r\nexport async function getMultipleAccounts(\r\n    connection: Connection,\r\n    addresses: PublicKey[],\r\n    commitment?: Commitment,\r\n    programId = TOKEN_PROGRAM_ID,\r\n): Promise<Account[]> {\r\n    const infos = await connection.getMultipleAccountsInfo(addresses, commitment);\r\n    return addresses.map((address, i) => unpackAccount(address, infos[i], programId));\r\n}\r\n\r\n/** Get the minimum lamport balance for a base token account to be rent exempt\r\n *\r\n * @param connection Connection to use\r\n * @param commitment Desired level of commitment for querying the state\r\n *\r\n * @return Amount of lamports required\r\n */\r\nexport async function getMinimumBalanceForRentExemptAccount(\r\n    connection: Connection,\r\n    commitment?: Commitment,\r\n): Promise<number> {\r\n    return await getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);\r\n}\r\n\r\n/** Get the minimum lamport balance for a rent-exempt token account with extensions\r\n *\r\n * @param connection Connection to use\r\n * @param commitment Desired level of commitment for querying the state\r\n *\r\n * @return Amount of lamports required\r\n */\r\nexport async function getMinimumBalanceForRentExemptAccountWithExtensions(\r\n    connection: Connection,\r\n    extensions: ExtensionType[],\r\n    commitment?: Commitment,\r\n): Promise<number> {\r\n    const accountLen = getAccountLen(extensions);\r\n    return await connection.getMinimumBalanceForRentExemption(accountLen, commitment);\r\n}\r\n\r\n/**\r\n * Unpack a token account\r\n *\r\n * @param address   Token account\r\n * @param info      Token account data\r\n * @param programId SPL Token program account\r\n *\r\n * @return Unpacked token account\r\n */\r\nexport function unpackAccount(\r\n    address: PublicKey,\r\n    info: AccountInfo<Buffer> | null,\r\n    programId = TOKEN_PROGRAM_ID,\r\n): Account {\r\n    if (!info) throw new TokenAccountNotFoundError();\r\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\r\n    if (info.data.length < ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\r\n\r\n    const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));\r\n    let tlvData = Buffer.alloc(0);\r\n    if (info.data.length > ACCOUNT_SIZE) {\r\n        if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\r\n        if (info.data[ACCOUNT_SIZE] != AccountType.Account) throw new TokenInvalidAccountError();\r\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\r\n    }\r\n\r\n    return {\r\n        address,\r\n        mint: rawAccount.mint,\r\n        owner: rawAccount.owner,\r\n        amount: rawAccount.amount,\r\n        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\r\n        delegatedAmount: rawAccount.delegatedAmount,\r\n        isInitialized: rawAccount.state !== AccountState.Uninitialized,\r\n        isFrozen: rawAccount.state === AccountState.Frozen,\r\n        isNative: !!rawAccount.isNativeOption,\r\n        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\r\n        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\r\n        tlvData,\r\n    };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}