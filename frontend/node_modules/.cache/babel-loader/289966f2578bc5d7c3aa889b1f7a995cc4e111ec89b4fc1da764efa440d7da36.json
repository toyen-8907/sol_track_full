{"ast":null,"code":"import { SolanaError, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE } from '@solana/errors';\nimport { combineCodec, createEncoder, createDecoder, assertByteArrayIsNotEmptyForCodec, assertByteArrayHasEnoughBytesForCodec } from '@solana/codecs-core';\n\n// src/assertions.ts\nfunction assertNumberIsBetweenForCodec(codecDescription, min, max, value) {\n  if (value < min || value > max) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n      codecDescription,\n      max,\n      min,\n      value\n    });\n  }\n}\n\n// src/common.ts\nvar Endian = /* @__PURE__ */(Endian2 => {\n  Endian2[Endian2[\"Little\"] = 0] = \"Little\";\n  Endian2[Endian2[\"Big\"] = 1] = \"Big\";\n  return Endian2;\n})(Endian || {});\nfunction isLittleEndian(config) {\n  return config?.endian === 1 /* Big */ ? false : true;\n}\nfunction numberEncoderFactory(input) {\n  return createEncoder({\n    fixedSize: input.size,\n    write(value, bytes, offset) {\n      if (input.range) {\n        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n      }\n      const arrayBuffer = new ArrayBuffer(input.size);\n      input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n      bytes.set(new Uint8Array(arrayBuffer), offset);\n      return offset + input.size;\n    }\n  });\n}\nfunction numberDecoderFactory(input) {\n  return createDecoder({\n    fixedSize: input.size,\n    read(bytes, offset = 0) {\n      assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n      const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n      return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n    }\n  });\n}\nfunction toArrayBuffer(bytes, offset, length) {\n  const bytesOffset = bytes.byteOffset + (offset ?? 0);\n  const bytesLength = length ?? bytes.byteLength;\n  return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n\n// src/f32.ts\nvar getF32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"f32\",\n  set: (view, value, le) => view.setFloat32(0, Number(value), le),\n  size: 4\n});\nvar getF32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getFloat32(0, le),\n  name: \"f32\",\n  size: 4\n});\nvar getF32Codec = (config = {}) => combineCodec(getF32Encoder(config), getF32Decoder(config));\nvar getF64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"f64\",\n  set: (view, value, le) => view.setFloat64(0, Number(value), le),\n  size: 8\n});\nvar getF64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getFloat64(0, le),\n  name: \"f64\",\n  size: 8\n});\nvar getF64Codec = (config = {}) => combineCodec(getF64Encoder(config), getF64Decoder(config));\nvar getI128Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i128\",\n  range: [-BigInt(\"0x7fffffffffffffffffffffffffffffff\") - 1n, BigInt(\"0x7fffffffffffffffffffffffffffffff\")],\n  set: (view, value, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const rightMask = 0xffffffffffffffffn;\n    view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n  },\n  size: 16\n});\nvar getI128Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const left = view.getBigInt64(leftOffset, le);\n    const right = view.getBigUint64(rightOffset, le);\n    return (left << 64n) + right;\n  },\n  name: \"i128\",\n  size: 16\n});\nvar getI128Codec = (config = {}) => combineCodec(getI128Encoder(config), getI128Decoder(config));\nvar getI16Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i16\",\n  range: [-Number(\"0x7fff\") - 1, Number(\"0x7fff\")],\n  set: (view, value, le) => view.setInt16(0, Number(value), le),\n  size: 2\n});\nvar getI16Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getInt16(0, le),\n  name: \"i16\",\n  size: 2\n});\nvar getI16Codec = (config = {}) => combineCodec(getI16Encoder(config), getI16Decoder(config));\nvar getI32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i32\",\n  range: [-Number(\"0x7fffffff\") - 1, Number(\"0x7fffffff\")],\n  set: (view, value, le) => view.setInt32(0, Number(value), le),\n  size: 4\n});\nvar getI32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getInt32(0, le),\n  name: \"i32\",\n  size: 4\n});\nvar getI32Codec = (config = {}) => combineCodec(getI32Encoder(config), getI32Decoder(config));\nvar getI64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i64\",\n  range: [-BigInt(\"0x7fffffffffffffff\") - 1n, BigInt(\"0x7fffffffffffffff\")],\n  set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n  size: 8\n});\nvar getI64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getBigInt64(0, le),\n  name: \"i64\",\n  size: 8\n});\nvar getI64Codec = (config = {}) => combineCodec(getI64Encoder(config), getI64Decoder(config));\nvar getI8Encoder = () => numberEncoderFactory({\n  name: \"i8\",\n  range: [-Number(\"0x7f\") - 1, Number(\"0x7f\")],\n  set: (view, value) => view.setInt8(0, Number(value)),\n  size: 1\n});\nvar getI8Decoder = () => numberDecoderFactory({\n  get: view => view.getInt8(0),\n  name: \"i8\",\n  size: 1\n});\nvar getI8Codec = () => combineCodec(getI8Encoder(), getI8Decoder());\nvar getShortU16Encoder = () => createEncoder({\n  getSizeFromValue: value => {\n    if (value <= 127) return 1;\n    if (value <= 16383) return 2;\n    return 3;\n  },\n  maxSize: 3,\n  write: (value, bytes, offset) => {\n    assertNumberIsBetweenForCodec(\"shortU16\", 0, 65535, value);\n    const shortU16Bytes = [0];\n    for (let ii = 0;; ii += 1) {\n      const alignedValue = Number(value) >> ii * 7;\n      if (alignedValue === 0) {\n        break;\n      }\n      const nextSevenBits = 127 & alignedValue;\n      shortU16Bytes[ii] = nextSevenBits;\n      if (ii > 0) {\n        shortU16Bytes[ii - 1] |= 128;\n      }\n    }\n    bytes.set(shortU16Bytes, offset);\n    return offset + shortU16Bytes.length;\n  }\n});\nvar getShortU16Decoder = () => createDecoder({\n  maxSize: 3,\n  read: (bytes, offset) => {\n    let value = 0;\n    let byteCount = 0;\n    while (++byteCount) {\n      const byteIndex = byteCount - 1;\n      const currentByte = bytes[offset + byteIndex];\n      const nextSevenBits = 127 & currentByte;\n      value |= nextSevenBits << byteIndex * 7;\n      if ((currentByte & 128) === 0) {\n        break;\n      }\n    }\n    return [value, offset + byteCount];\n  }\n});\nvar getShortU16Codec = () => combineCodec(getShortU16Encoder(), getShortU16Decoder());\nvar getU128Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u128\",\n  range: [0n, BigInt(\"0xffffffffffffffffffffffffffffffff\")],\n  set: (view, value, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const rightMask = 0xffffffffffffffffn;\n    view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n  },\n  size: 16\n});\nvar getU128Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const left = view.getBigUint64(leftOffset, le);\n    const right = view.getBigUint64(rightOffset, le);\n    return (left << 64n) + right;\n  },\n  name: \"u128\",\n  size: 16\n});\nvar getU128Codec = (config = {}) => combineCodec(getU128Encoder(config), getU128Decoder(config));\nvar getU16Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u16\",\n  range: [0, Number(\"0xffff\")],\n  set: (view, value, le) => view.setUint16(0, Number(value), le),\n  size: 2\n});\nvar getU16Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getUint16(0, le),\n  name: \"u16\",\n  size: 2\n});\nvar getU16Codec = (config = {}) => combineCodec(getU16Encoder(config), getU16Decoder(config));\nvar getU32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u32\",\n  range: [0, Number(\"0xffffffff\")],\n  set: (view, value, le) => view.setUint32(0, Number(value), le),\n  size: 4\n});\nvar getU32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getUint32(0, le),\n  name: \"u32\",\n  size: 4\n});\nvar getU32Codec = (config = {}) => combineCodec(getU32Encoder(config), getU32Decoder(config));\nvar getU64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u64\",\n  range: [0n, BigInt(\"0xffffffffffffffff\")],\n  set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n  size: 8\n});\nvar getU64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getBigUint64(0, le),\n  name: \"u64\",\n  size: 8\n});\nvar getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config));\nvar getU8Encoder = () => numberEncoderFactory({\n  name: \"u8\",\n  range: [0, Number(\"0xff\")],\n  set: (view, value) => view.setUint8(0, Number(value)),\n  size: 1\n});\nvar getU8Decoder = () => numberDecoderFactory({\n  get: view => view.getUint8(0),\n  name: \"u8\",\n  size: 1\n});\nvar getU8Codec = () => combineCodec(getU8Encoder(), getU8Decoder());\nexport { Endian, assertNumberIsBetweenForCodec, getF32Codec, getF32Decoder, getF32Encoder, getF64Codec, getF64Decoder, getF64Encoder, getI128Codec, getI128Decoder, getI128Encoder, getI16Codec, getI16Decoder, getI16Encoder, getI32Codec, getI32Decoder, getI32Encoder, getI64Codec, getI64Decoder, getI64Encoder, getI8Codec, getI8Decoder, getI8Encoder, getShortU16Codec, getShortU16Decoder, getShortU16Encoder, getU128Codec, getU128Decoder, getU128Encoder, getU16Codec, getU16Decoder, getU16Encoder, getU32Codec, getU32Decoder, getU32Encoder, getU64Codec, getU64Decoder, getU64Encoder, getU8Codec, getU8Decoder, getU8Encoder };\n\n//# sourceMappingURL=index.browser.mjs.map","map":{"version":3,"names":["assertNumberIsBetweenForCodec","codecDescription","min","max","value","SolanaError","SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE","Endian","Endian2","isLittleEndian","config","endian","numberEncoderFactory","input","createEncoder","fixedSize","size","write","bytes","offset","range","name","arrayBuffer","ArrayBuffer","set","DataView","Uint8Array","numberDecoderFactory","createDecoder","read","assertByteArrayIsNotEmptyForCodec","assertByteArrayHasEnoughBytesForCodec","view","toArrayBuffer","get","length","bytesOffset","byteOffset","bytesLength","byteLength","buffer","slice","getF32Encoder","le","setFloat32","Number","getF32Decoder","getFloat32","getF32Codec","combineCodec","getF64Encoder","setFloat64","getF64Decoder","getFloat64","getF64Codec","getI128Encoder","BigInt","leftOffset","rightOffset","rightMask","setBigInt64","setBigUint64","getI128Decoder","left","getBigInt64","right","getBigUint64","getI128Codec","getI16Encoder","setInt16","getI16Decoder","getInt16","getI16Codec","getI32Encoder","setInt32","getI32Decoder","getInt32","getI32Codec","getI64Encoder","getI64Decoder","getI64Codec","getI8Encoder","setInt8","getI8Decoder","getInt8","getI8Codec","getShortU16Encoder","getSizeFromValue","maxSize","shortU16Bytes","ii","alignedValue","nextSevenBits","getShortU16Decoder","byteCount","byteIndex","currentByte","getShortU16Codec","getU128Encoder","getU128Decoder","getU128Codec","getU16Encoder","setUint16","getU16Decoder","getUint16","getU16Codec","getU32Encoder","setUint32","getU32Decoder","getUint32","getU32Codec","getU64Encoder","getU64Decoder","getU64Codec","getU8Encoder","setUint8","getU8Decoder","getUint8","getU8Codec"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\assertions.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\common.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\utils.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\f32.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\f64.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\i128.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\i16.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\i32.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\i64.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\i8.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\short-u16.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\u128.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\u16.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\u32.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\u64.ts","C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-metadata\\node_modules\\@solana\\codecs-numbers\\src\\u8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given number is between a given range.\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\n/** Defines a encoder for numbers and bigints. */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/** Defines a fixed-size encoder for numbers and bigints. */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/** Defines a decoder for numbers and bigints. */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/** Defines a fixed-size decoder for numbers and bigints. */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/** Defines a codec for numbers and bigints. */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/** Defines a fixed-size codec for numbers and bigints. */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/** Defines the config for number codecs that use more than one byte. */\nexport type NumberCodecConfig = {\n    /**\n     * Whether the serializer should use little-endian or big-endian encoding.\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/** Defines the endianness of a number serializer. */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Encodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Decodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Encodes and decodes short u16 numbers.\n *\n * Short u16 numbers are the same as u16, but serialized with 1 to 3 bytes.\n * If the value is above 0x7f, the top bit is set and the remaining\n * value is stored in the next bytes. Each byte follows the same\n * pattern until the 3rd byte. The 3rd byte, if needed, uses\n * all 8 bits to store the last byte of the original value.\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}