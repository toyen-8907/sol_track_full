{"ast":null,"code":"import { TokenTransferHookAccountDataNotFound, TokenTransferHookInvalidSeed } from '../../errors.js';\nconst DISCRIMINATOR_SPAN = 1;\nconst LITERAL_LENGTH_SPAN = 1;\nconst INSTRUCTION_ARG_OFFSET_SPAN = 1;\nconst INSTRUCTION_ARG_LENGTH_SPAN = 1;\nconst ACCOUNT_KEY_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_OFFSET_SPAN = 1;\nconst ACCOUNT_DATA_LENGTH_SPAN = 1;\nfunction unpackSeedLiteral(seeds) {\n  if (seeds.length < 1) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  const [length, ...rest] = seeds;\n  if (rest.length < length) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  return {\n    data: Buffer.from(rest.slice(0, length)),\n    packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length\n  };\n}\nfunction unpackSeedInstructionArg(seeds, instructionData) {\n  if (seeds.length < 2) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  const [index, length] = seeds;\n  if (instructionData.length < length + index) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  return {\n    data: instructionData.subarray(index, index + length),\n    packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN\n  };\n}\nfunction unpackSeedAccountKey(seeds, previousMetas) {\n  if (seeds.length < 1) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  const [index] = seeds;\n  if (previousMetas.length <= index) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  return {\n    data: previousMetas[index].pubkey.toBuffer(),\n    packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN\n  };\n}\nasync function unpackSeedAccountData(seeds, previousMetas, connection) {\n  if (seeds.length < 3) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  const [accountIndex, dataIndex, length] = seeds;\n  if (previousMetas.length <= accountIndex) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);\n  if (accountInfo == null) {\n    throw new TokenTransferHookAccountDataNotFound();\n  }\n  if (accountInfo.data.length < dataIndex + length) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  return {\n    data: accountInfo.data.subarray(dataIndex, dataIndex + length),\n    packedLength: DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN\n  };\n}\nasync function unpackFirstSeed(seeds, previousMetas, instructionData, connection) {\n  const [discriminator, ...rest] = seeds;\n  const remaining = new Uint8Array(rest);\n  switch (discriminator) {\n    case 0:\n      return null;\n    case 1:\n      return unpackSeedLiteral(remaining);\n    case 2:\n      return unpackSeedInstructionArg(remaining, instructionData);\n    case 3:\n      return unpackSeedAccountKey(remaining, previousMetas);\n    case 4:\n      return unpackSeedAccountData(remaining, previousMetas, connection);\n    default:\n      throw new TokenTransferHookInvalidSeed();\n  }\n}\nexport async function unpackSeeds(seeds, previousMetas, instructionData, connection) {\n  const unpackedSeeds = [];\n  let i = 0;\n  while (i < 32) {\n    const seed = await unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);\n    if (seed == null) {\n      break;\n    }\n    unpackedSeeds.push(seed.data);\n    i += seed.packedLength;\n  }\n  return unpackedSeeds;\n}","map":{"version":3,"names":["TokenTransferHookAccountDataNotFound","TokenTransferHookInvalidSeed","DISCRIMINATOR_SPAN","LITERAL_LENGTH_SPAN","INSTRUCTION_ARG_OFFSET_SPAN","INSTRUCTION_ARG_LENGTH_SPAN","ACCOUNT_KEY_INDEX_SPAN","ACCOUNT_DATA_ACCOUNT_INDEX_SPAN","ACCOUNT_DATA_OFFSET_SPAN","ACCOUNT_DATA_LENGTH_SPAN","unpackSeedLiteral","seeds","length","rest","data","Buffer","from","slice","packedLength","unpackSeedInstructionArg","instructionData","index","subarray","unpackSeedAccountKey","previousMetas","pubkey","toBuffer","unpackSeedAccountData","connection","accountIndex","dataIndex","accountInfo","getAccountInfo","unpackFirstSeed","discriminator","remaining","Uint8Array","unpackSeeds","unpackedSeeds","i","seed","push"],"sources":["/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token/src/extensions/transferHook/seeds.ts"],"sourcesContent":["import type { AccountMeta, Connection } from '@solana/web3.js';\nimport { TokenTransferHookAccountDataNotFound, TokenTransferHookInvalidSeed } from '../../errors.js';\n\ninterface Seed {\n    data: Buffer;\n    packedLength: number;\n}\n\nconst DISCRIMINATOR_SPAN = 1;\nconst LITERAL_LENGTH_SPAN = 1;\nconst INSTRUCTION_ARG_OFFSET_SPAN = 1;\nconst INSTRUCTION_ARG_LENGTH_SPAN = 1;\nconst ACCOUNT_KEY_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_OFFSET_SPAN = 1;\nconst ACCOUNT_DATA_LENGTH_SPAN = 1;\n\nfunction unpackSeedLiteral(seeds: Uint8Array): Seed {\n    if (seeds.length < 1) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [length, ...rest] = seeds;\n    if (rest.length < length) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: Buffer.from(rest.slice(0, length)),\n        packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length,\n    };\n}\n\nfunction unpackSeedInstructionArg(seeds: Uint8Array, instructionData: Buffer): Seed {\n    if (seeds.length < 2) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [index, length] = seeds;\n    if (instructionData.length < length + index) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: instructionData.subarray(index, index + length),\n        packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN,\n    };\n}\n\nfunction unpackSeedAccountKey(seeds: Uint8Array, previousMetas: AccountMeta[]): Seed {\n    if (seeds.length < 1) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [index] = seeds;\n    if (previousMetas.length <= index) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: previousMetas[index].pubkey.toBuffer(),\n        packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN,\n    };\n}\n\nasync function unpackSeedAccountData(\n    seeds: Uint8Array,\n    previousMetas: AccountMeta[],\n    connection: Connection,\n): Promise<Seed> {\n    if (seeds.length < 3) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [accountIndex, dataIndex, length] = seeds;\n    if (previousMetas.length <= accountIndex) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);\n    if (accountInfo == null) {\n        throw new TokenTransferHookAccountDataNotFound();\n    }\n    if (accountInfo.data.length < dataIndex + length) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: accountInfo.data.subarray(dataIndex, dataIndex + length),\n        packedLength:\n            DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN,\n    };\n}\n\nasync function unpackFirstSeed(\n    seeds: Uint8Array,\n    previousMetas: AccountMeta[],\n    instructionData: Buffer,\n    connection: Connection,\n): Promise<Seed | null> {\n    const [discriminator, ...rest] = seeds;\n    const remaining = new Uint8Array(rest);\n    switch (discriminator) {\n        case 0:\n            return null;\n        case 1:\n            return unpackSeedLiteral(remaining);\n        case 2:\n            return unpackSeedInstructionArg(remaining, instructionData);\n        case 3:\n            return unpackSeedAccountKey(remaining, previousMetas);\n        case 4:\n            return unpackSeedAccountData(remaining, previousMetas, connection);\n        default:\n            throw new TokenTransferHookInvalidSeed();\n    }\n}\n\nexport async function unpackSeeds(\n    seeds: Uint8Array,\n    previousMetas: AccountMeta[],\n    instructionData: Buffer,\n    connection: Connection,\n): Promise<Buffer[]> {\n    const unpackedSeeds: Buffer[] = [];\n    let i = 0;\n    while (i < 32) {\n        const seed = await unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);\n        if (seed == null) {\n            break;\n        }\n        unpackedSeeds.push(seed.data);\n        i += seed.packedLength;\n    }\n    return unpackedSeeds;\n}\n"],"mappings":"AACA,SAASA,oCAAoC,EAAEC,4BAA4B,QAAQ,iBAAiB;AAOpG,MAAMC,kBAAkB,GAAG,CAAC;AAC5B,MAAMC,mBAAmB,GAAG,CAAC;AAC7B,MAAMC,2BAA2B,GAAG,CAAC;AACrC,MAAMC,2BAA2B,GAAG,CAAC;AACrC,MAAMC,sBAAsB,GAAG,CAAC;AAChC,MAAMC,+BAA+B,GAAG,CAAC;AACzC,MAAMC,wBAAwB,GAAG,CAAC;AAClC,MAAMC,wBAAwB,GAAG,CAAC;AAElC,SAASC,iBAAiBA,CAACC,KAAiB;EACxC,IAAIA,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;IAClB,MAAM,IAAIX,4BAA4B,EAAE;EAC5C;EACA,MAAM,CAACW,MAAM,EAAE,GAAGC,IAAI,CAAC,GAAGF,KAAK;EAC/B,IAAIE,IAAI,CAACD,MAAM,GAAGA,MAAM,EAAE;IACtB,MAAM,IAAIX,4BAA4B,EAAE;EAC5C;EACA,OAAO;IACHa,IAAI,EAAEC,MAAM,CAACC,IAAI,CAACH,IAAI,CAACI,KAAK,CAAC,CAAC,EAAEL,MAAM,CAAC,CAAC;IACxCM,YAAY,EAAEhB,kBAAkB,GAAGC,mBAAmB,GAAGS;GAC5D;AACL;AAEA,SAASO,wBAAwBA,CAACR,KAAiB,EAAES,eAAuB;EACxE,IAAIT,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;IAClB,MAAM,IAAIX,4BAA4B,EAAE;EAC5C;EACA,MAAM,CAACoB,KAAK,EAAET,MAAM,CAAC,GAAGD,KAAK;EAC7B,IAAIS,eAAe,CAACR,MAAM,GAAGA,MAAM,GAAGS,KAAK,EAAE;IACzC,MAAM,IAAIpB,4BAA4B,EAAE;EAC5C;EACA,OAAO;IACHa,IAAI,EAAEM,eAAe,CAACE,QAAQ,CAACD,KAAK,EAAEA,KAAK,GAAGT,MAAM,CAAC;IACrDM,YAAY,EAAEhB,kBAAkB,GAAGE,2BAA2B,GAAGC;GACpE;AACL;AAEA,SAASkB,oBAAoBA,CAACZ,KAAiB,EAAEa,aAA4B;EACzE,IAAIb,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;IAClB,MAAM,IAAIX,4BAA4B,EAAE;EAC5C;EACA,MAAM,CAACoB,KAAK,CAAC,GAAGV,KAAK;EACrB,IAAIa,aAAa,CAACZ,MAAM,IAAIS,KAAK,EAAE;IAC/B,MAAM,IAAIpB,4BAA4B,EAAE;EAC5C;EACA,OAAO;IACHa,IAAI,EAAEU,aAAa,CAACH,KAAK,CAAC,CAACI,MAAM,CAACC,QAAQ,EAAE;IAC5CR,YAAY,EAAEhB,kBAAkB,GAAGI;GACtC;AACL;AAEA,eAAeqB,qBAAqBA,CAChChB,KAAiB,EACjBa,aAA4B,EAC5BI,UAAsB;EAEtB,IAAIjB,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;IAClB,MAAM,IAAIX,4BAA4B,EAAE;EAC5C;EACA,MAAM,CAAC4B,YAAY,EAAEC,SAAS,EAAElB,MAAM,CAAC,GAAGD,KAAK;EAC/C,IAAIa,aAAa,CAACZ,MAAM,IAAIiB,YAAY,EAAE;IACtC,MAAM,IAAI5B,4BAA4B,EAAE;EAC5C;EACA,MAAM8B,WAAW,GAAG,MAAMH,UAAU,CAACI,cAAc,CAACR,aAAa,CAACK,YAAY,CAAC,CAACJ,MAAM,CAAC;EACvF,IAAIM,WAAW,IAAI,IAAI,EAAE;IACrB,MAAM,IAAI/B,oCAAoC,EAAE;EACpD;EACA,IAAI+B,WAAW,CAACjB,IAAI,CAACF,MAAM,GAAGkB,SAAS,GAAGlB,MAAM,EAAE;IAC9C,MAAM,IAAIX,4BAA4B,EAAE;EAC5C;EACA,OAAO;IACHa,IAAI,EAAEiB,WAAW,CAACjB,IAAI,CAACQ,QAAQ,CAACQ,SAAS,EAAEA,SAAS,GAAGlB,MAAM,CAAC;IAC9DM,YAAY,EACRhB,kBAAkB,GAAGK,+BAA+B,GAAGC,wBAAwB,GAAGC;GACzF;AACL;AAEA,eAAewB,eAAeA,CAC1BtB,KAAiB,EACjBa,aAA4B,EAC5BJ,eAAuB,EACvBQ,UAAsB;EAEtB,MAAM,CAACM,aAAa,EAAE,GAAGrB,IAAI,CAAC,GAAGF,KAAK;EACtC,MAAMwB,SAAS,GAAG,IAAIC,UAAU,CAACvB,IAAI,CAAC;EACtC,QAAQqB,aAAa;IACjB,KAAK,CAAC;MACF,OAAO,IAAI;IACf,KAAK,CAAC;MACF,OAAOxB,iBAAiB,CAACyB,SAAS,CAAC;IACvC,KAAK,CAAC;MACF,OAAOhB,wBAAwB,CAACgB,SAAS,EAAEf,eAAe,CAAC;IAC/D,KAAK,CAAC;MACF,OAAOG,oBAAoB,CAACY,SAAS,EAAEX,aAAa,CAAC;IACzD,KAAK,CAAC;MACF,OAAOG,qBAAqB,CAACQ,SAAS,EAAEX,aAAa,EAAEI,UAAU,CAAC;IACtE;MACI,MAAM,IAAI3B,4BAA4B,EAAE;EAChD;AACJ;AAEA,OAAO,eAAeoC,WAAWA,CAC7B1B,KAAiB,EACjBa,aAA4B,EAC5BJ,eAAuB,EACvBQ,UAAsB;EAEtB,MAAMU,aAAa,GAAa,EAAE;EAClC,IAAIC,CAAC,GAAG,CAAC;EACT,OAAOA,CAAC,GAAG,EAAE,EAAE;IACX,MAAMC,IAAI,GAAG,MAAMP,eAAe,CAACtB,KAAK,CAACM,KAAK,CAACsB,CAAC,CAAC,EAAEf,aAAa,EAAEJ,eAAe,EAAEQ,UAAU,CAAC;IAC9F,IAAIY,IAAI,IAAI,IAAI,EAAE;MACd;IACJ;IACAF,aAAa,CAACG,IAAI,CAACD,IAAI,CAAC1B,IAAI,CAAC;IAC7ByB,CAAC,IAAIC,IAAI,CAACtB,YAAY;EAC1B;EACA,OAAOoB,aAAa;AACxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}