{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst bs58_1 = __importDefault(require(\"bs58\"));\n// TODO: Make sure this polyfill not included when not required\nconst encoding = __importStar(require(\"text-encoding-utf-8\"));\nconst ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\nconst textDecoder = new ResolvedTextDecoder(\"utf-8\", {\n  fatal: true\n});\nfunction baseEncode(value) {\n  if (typeof value === \"string\") {\n    value = Buffer.from(value, \"utf8\");\n  }\n  return bs58_1.default.encode(Buffer.from(value));\n}\nexports.baseEncode = baseEncode;\nfunction baseDecode(value) {\n  return Buffer.from(bs58_1.default.decode(value));\n}\nexports.baseDecode = baseDecode;\nconst INITIAL_LENGTH = 1024;\nclass BorshError extends Error {\n  constructor(message) {\n    super(message);\n    this.fieldPath = [];\n    this.originalMessage = message;\n  }\n  addToFieldPath(fieldName) {\n    this.fieldPath.splice(0, 0, fieldName);\n    // NOTE: Modifying message directly as jest doesn't use .toString()\n    this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n  }\n}\nexports.BorshError = BorshError;\n/// Binary encoder.\nclass BinaryWriter {\n  constructor() {\n    this.buf = Buffer.alloc(INITIAL_LENGTH);\n    this.length = 0;\n  }\n  maybeResize() {\n    if (this.buf.length < 16 + this.length) {\n      this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\n    }\n  }\n  writeU8(value) {\n    this.maybeResize();\n    this.buf.writeUInt8(value, this.length);\n    this.length += 1;\n  }\n  writeU16(value) {\n    this.maybeResize();\n    this.buf.writeUInt16LE(value, this.length);\n    this.length += 2;\n  }\n  writeU32(value) {\n    this.maybeResize();\n    this.buf.writeUInt32LE(value, this.length);\n    this.length += 4;\n  }\n  writeU64(value) {\n    this.maybeResize();\n    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 8)));\n  }\n  writeU128(value) {\n    this.maybeResize();\n    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 16)));\n  }\n  writeU256(value) {\n    this.maybeResize();\n    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 32)));\n  }\n  writeU512(value) {\n    this.maybeResize();\n    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 64)));\n  }\n  writeBuffer(buffer) {\n    // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n    this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), buffer, Buffer.alloc(INITIAL_LENGTH)]);\n    this.length += buffer.length;\n  }\n  writeString(str) {\n    this.maybeResize();\n    const b = Buffer.from(str, \"utf8\");\n    this.writeU32(b.length);\n    this.writeBuffer(b);\n  }\n  writeFixedArray(array) {\n    this.writeBuffer(Buffer.from(array));\n  }\n  writeArray(array, fn) {\n    this.maybeResize();\n    this.writeU32(array.length);\n    for (const elem of array) {\n      this.maybeResize();\n      fn(elem);\n    }\n  }\n  toArray() {\n    return this.buf.subarray(0, this.length);\n  }\n}\nexports.BinaryWriter = BinaryWriter;\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n  const originalMethod = propertyDescriptor.value;\n  propertyDescriptor.value = function (...args) {\n    try {\n      return originalMethod.apply(this, args);\n    } catch (e) {\n      if (e instanceof RangeError) {\n        const code = e.code;\n        if ([\"ERR_BUFFER_OUT_OF_BOUNDS\", \"ERR_OUT_OF_RANGE\"].indexOf(code) >= 0) {\n          throw new BorshError(\"Reached the end of buffer when deserializing\");\n        }\n      }\n      throw e;\n    }\n  };\n}\nclass BinaryReader {\n  constructor(buf) {\n    this.buf = buf;\n    this.offset = 0;\n  }\n  readU8() {\n    const value = this.buf.readUInt8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n  readU16() {\n    const value = this.buf.readUInt16LE(this.offset);\n    this.offset += 2;\n    return value;\n  }\n  readU32() {\n    const value = this.buf.readUInt32LE(this.offset);\n    this.offset += 4;\n    return value;\n  }\n  readU64() {\n    const buf = this.readBuffer(8);\n    return new bn_js_1.default(buf, \"le\");\n  }\n  readU128() {\n    const buf = this.readBuffer(16);\n    return new bn_js_1.default(buf, \"le\");\n  }\n  readU256() {\n    const buf = this.readBuffer(32);\n    return new bn_js_1.default(buf, \"le\");\n  }\n  readU512() {\n    const buf = this.readBuffer(64);\n    return new bn_js_1.default(buf, \"le\");\n  }\n  readBuffer(len) {\n    if (this.offset + len > this.buf.length) {\n      throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n    }\n    const result = this.buf.slice(this.offset, this.offset + len);\n    this.offset += len;\n    return result;\n  }\n  readString() {\n    const len = this.readU32();\n    const buf = this.readBuffer(len);\n    try {\n      // NOTE: Using TextDecoder to fail on invalid UTF-8\n      return textDecoder.decode(buf);\n    } catch (e) {\n      throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n    }\n  }\n  readFixedArray(len) {\n    return new Uint8Array(this.readBuffer(len));\n  }\n  readArray(fn) {\n    const len = this.readU32();\n    const result = Array();\n    for (let i = 0; i < len; ++i) {\n      result.push(fn());\n    }\n    return result;\n  }\n}\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU8\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU16\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU32\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU64\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU128\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU256\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU512\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readString\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readFixedArray\", null);\n__decorate([handlingRangeError], BinaryReader.prototype, \"readArray\", null);\nexports.BinaryReader = BinaryReader;\nfunction capitalizeFirstLetter(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n  try {\n    // TODO: Handle missing values properly (make sure they never result in just skipped write)\n    if (typeof fieldType === \"string\") {\n      writer[`write${capitalizeFirstLetter(fieldType)}`](value);\n    } else if (fieldType instanceof Array) {\n      if (typeof fieldType[0] === \"number\") {\n        if (value.length !== fieldType[0]) {\n          throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n        }\n        writer.writeFixedArray(value);\n      } else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\n        if (value.length !== fieldType[1]) {\n          throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);\n        }\n        for (let i = 0; i < fieldType[1]; i++) {\n          serializeField(schema, null, value[i], fieldType[0], writer);\n        }\n      } else {\n        writer.writeArray(value, item => {\n          serializeField(schema, fieldName, item, fieldType[0], writer);\n        });\n      }\n    } else if (fieldType.kind !== undefined) {\n      switch (fieldType.kind) {\n        case \"option\":\n          {\n            if (value === null || value === undefined) {\n              writer.writeU8(0);\n            } else {\n              writer.writeU8(1);\n              serializeField(schema, fieldName, value, fieldType.type, writer);\n            }\n            break;\n          }\n        case \"map\":\n          {\n            writer.writeU32(value.size);\n            value.forEach((val, key) => {\n              serializeField(schema, fieldName, key, fieldType.key, writer);\n              serializeField(schema, fieldName, val, fieldType.value, writer);\n            });\n            break;\n          }\n        default:\n          throw new BorshError(`FieldType ${fieldType} unrecognized`);\n      }\n    } else {\n      serializeStruct(schema, value, writer);\n    }\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n    throw error;\n  }\n}\nfunction serializeStruct(schema, obj, writer) {\n  if (typeof obj.borshSerialize === \"function\") {\n    obj.borshSerialize(writer);\n    return;\n  }\n  const structSchema = schema.get(obj.constructor);\n  if (!structSchema) {\n    throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n  }\n  if (structSchema.kind === \"struct\") {\n    structSchema.fields.map(([fieldName, fieldType]) => {\n      serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n    });\n  } else if (structSchema.kind === \"enum\") {\n    const name = obj[structSchema.field];\n    for (let idx = 0; idx < structSchema.values.length; ++idx) {\n      const [fieldName, fieldType] = structSchema.values[idx];\n      if (fieldName === name) {\n        writer.writeU8(idx);\n        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        break;\n      }\n    }\n  } else {\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n  }\n}\n/// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\nfunction serialize(schema, obj, Writer = BinaryWriter) {\n  const writer = new Writer();\n  serializeStruct(schema, obj, writer);\n  return writer.toArray();\n}\nexports.serialize = serialize;\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n  try {\n    if (typeof fieldType === \"string\") {\n      return reader[`read${capitalizeFirstLetter(fieldType)}`]();\n    }\n    if (fieldType instanceof Array) {\n      if (typeof fieldType[0] === \"number\") {\n        return reader.readFixedArray(fieldType[0]);\n      } else if (typeof fieldType[1] === \"number\") {\n        const arr = [];\n        for (let i = 0; i < fieldType[1]; i++) {\n          arr.push(deserializeField(schema, null, fieldType[0], reader));\n        }\n        return arr;\n      } else {\n        return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));\n      }\n    }\n    if (fieldType.kind === \"option\") {\n      const option = reader.readU8();\n      if (option) {\n        return deserializeField(schema, fieldName, fieldType.type, reader);\n      }\n      return undefined;\n    }\n    if (fieldType.kind === \"map\") {\n      let map = new Map();\n      const length = reader.readU32();\n      for (let i = 0; i < length; i++) {\n        const key = deserializeField(schema, fieldName, fieldType.key, reader);\n        const val = deserializeField(schema, fieldName, fieldType.value, reader);\n        map.set(key, val);\n      }\n      return map;\n    }\n    return deserializeStruct(schema, fieldType, reader);\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n    throw error;\n  }\n}\nfunction deserializeStruct(schema, classType, reader) {\n  if (typeof classType.borshDeserialize === \"function\") {\n    return classType.borshDeserialize(reader);\n  }\n  const structSchema = schema.get(classType);\n  if (!structSchema) {\n    throw new BorshError(`Class ${classType.name} is missing in schema`);\n  }\n  if (structSchema.kind === \"struct\") {\n    const result = {};\n    for (const [fieldName, fieldType] of schema.get(classType).fields) {\n      result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n    }\n    return new classType(result);\n  }\n  if (structSchema.kind === \"enum\") {\n    const idx = reader.readU8();\n    if (idx >= structSchema.values.length) {\n      throw new BorshError(`Enum index: ${idx} is out of range`);\n    }\n    const [fieldName, fieldType] = structSchema.values[idx];\n    const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n    return new classType({\n      [fieldName]: fieldValue\n    });\n  }\n  throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n}\n/// Deserializes object from bytes using schema.\nfunction deserialize(schema, classType, buffer, Reader = BinaryReader) {\n  const reader = new Reader(buffer);\n  const result = deserializeStruct(schema, classType, reader);\n  if (reader.offset < buffer.length) {\n    throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n  }\n  return result;\n}\nexports.deserialize = deserialize;\n/// Deserializes object from bytes using schema, without checking the length read\nfunction deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {\n  const reader = new Reader(buffer);\n  return deserializeStruct(schema, classType, reader);\n}\nexports.deserializeUnchecked = deserializeUnchecked;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","d","Reflect","decorate","i","__importStar","mod","__esModule","result","hasOwnProperty","call","__importDefault","exports","deserializeUnchecked","deserialize","serialize","BinaryReader","BinaryWriter","BorshError","baseDecode","baseEncode","bn_js_1","require","bs58_1","encoding","ResolvedTextDecoder","TextDecoder","textDecoder","fatal","Buffer","from","default","encode","decode","INITIAL_LENGTH","Error","constructor","message","fieldPath","originalMessage","addToFieldPath","fieldName","splice","join","buf","alloc","maybeResize","concat","writeU8","writeUInt8","writeU16","writeUInt16LE","writeU32","writeUInt32LE","writeU64","writeBuffer","toArray","writeU128","writeU256","writeU512","buffer","subarray","writeString","str","b","writeFixedArray","array","writeArray","fn","elem","handlingRangeError","propertyKey","propertyDescriptor","originalMethod","args","apply","e","RangeError","code","indexOf","offset","readU8","readUInt8","readU16","readUInt16LE","readU32","readUInt32LE","readU64","readBuffer","readU128","readU256","readU512","len","slice","readString","readFixedArray","Uint8Array","readArray","Array","push","prototype","capitalizeFirstLetter","string","charAt","toUpperCase","serializeField","schema","fieldType","writer","item","kind","type","size","forEach","val","serializeStruct","error","obj","borshSerialize","structSchema","name","fields","map","field","idx","values","Writer","deserializeField","reader","arr","option","Map","set","deserializeStruct","classType","borshDeserialize","fieldValue","Reader"],"sources":["C:/monitor_sol_web/solactrackmap/node_modules/borsh/lib/index.js"],"sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\r\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\r\nconst bs58_1 = __importDefault(require(\"bs58\"));\r\n// TODO: Make sure this polyfill not included when not required\r\nconst encoding = __importStar(require(\"text-encoding-utf-8\"));\r\nconst ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\r\nconst textDecoder = new ResolvedTextDecoder(\"utf-8\", { fatal: true });\r\nfunction baseEncode(value) {\r\n    if (typeof value === \"string\") {\r\n        value = Buffer.from(value, \"utf8\");\r\n    }\r\n    return bs58_1.default.encode(Buffer.from(value));\r\n}\r\nexports.baseEncode = baseEncode;\r\nfunction baseDecode(value) {\r\n    return Buffer.from(bs58_1.default.decode(value));\r\n}\r\nexports.baseDecode = baseDecode;\r\nconst INITIAL_LENGTH = 1024;\r\nclass BorshError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.fieldPath = [];\r\n        this.originalMessage = message;\r\n    }\r\n    addToFieldPath(fieldName) {\r\n        this.fieldPath.splice(0, 0, fieldName);\r\n        // NOTE: Modifying message directly as jest doesn't use .toString()\r\n        this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\r\n    }\r\n}\r\nexports.BorshError = BorshError;\r\n/// Binary encoder.\r\nclass BinaryWriter {\r\n    constructor() {\r\n        this.buf = Buffer.alloc(INITIAL_LENGTH);\r\n        this.length = 0;\r\n    }\r\n    maybeResize() {\r\n        if (this.buf.length < 16 + this.length) {\r\n            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\r\n        }\r\n    }\r\n    writeU8(value) {\r\n        this.maybeResize();\r\n        this.buf.writeUInt8(value, this.length);\r\n        this.length += 1;\r\n    }\r\n    writeU16(value) {\r\n        this.maybeResize();\r\n        this.buf.writeUInt16LE(value, this.length);\r\n        this.length += 2;\r\n    }\r\n    writeU32(value) {\r\n        this.maybeResize();\r\n        this.buf.writeUInt32LE(value, this.length);\r\n        this.length += 4;\r\n    }\r\n    writeU64(value) {\r\n        this.maybeResize();\r\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 8)));\r\n    }\r\n    writeU128(value) {\r\n        this.maybeResize();\r\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 16)));\r\n    }\r\n    writeU256(value) {\r\n        this.maybeResize();\r\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 32)));\r\n    }\r\n    writeU512(value) {\r\n        this.maybeResize();\r\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 64)));\r\n    }\r\n    writeBuffer(buffer) {\r\n        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\r\n        this.buf = Buffer.concat([\r\n            Buffer.from(this.buf.subarray(0, this.length)),\r\n            buffer,\r\n            Buffer.alloc(INITIAL_LENGTH),\r\n        ]);\r\n        this.length += buffer.length;\r\n    }\r\n    writeString(str) {\r\n        this.maybeResize();\r\n        const b = Buffer.from(str, \"utf8\");\r\n        this.writeU32(b.length);\r\n        this.writeBuffer(b);\r\n    }\r\n    writeFixedArray(array) {\r\n        this.writeBuffer(Buffer.from(array));\r\n    }\r\n    writeArray(array, fn) {\r\n        this.maybeResize();\r\n        this.writeU32(array.length);\r\n        for (const elem of array) {\r\n            this.maybeResize();\r\n            fn(elem);\r\n        }\r\n    }\r\n    toArray() {\r\n        return this.buf.subarray(0, this.length);\r\n    }\r\n}\r\nexports.BinaryWriter = BinaryWriter;\r\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\r\n    const originalMethod = propertyDescriptor.value;\r\n    propertyDescriptor.value = function (...args) {\r\n        try {\r\n            return originalMethod.apply(this, args);\r\n        }\r\n        catch (e) {\r\n            if (e instanceof RangeError) {\r\n                const code = e.code;\r\n                if ([\"ERR_BUFFER_OUT_OF_BOUNDS\", \"ERR_OUT_OF_RANGE\"].indexOf(code) >= 0) {\r\n                    throw new BorshError(\"Reached the end of buffer when deserializing\");\r\n                }\r\n            }\r\n            throw e;\r\n        }\r\n    };\r\n}\r\nclass BinaryReader {\r\n    constructor(buf) {\r\n        this.buf = buf;\r\n        this.offset = 0;\r\n    }\r\n    readU8() {\r\n        const value = this.buf.readUInt8(this.offset);\r\n        this.offset += 1;\r\n        return value;\r\n    }\r\n    readU16() {\r\n        const value = this.buf.readUInt16LE(this.offset);\r\n        this.offset += 2;\r\n        return value;\r\n    }\r\n    readU32() {\r\n        const value = this.buf.readUInt32LE(this.offset);\r\n        this.offset += 4;\r\n        return value;\r\n    }\r\n    readU64() {\r\n        const buf = this.readBuffer(8);\r\n        return new bn_js_1.default(buf, \"le\");\r\n    }\r\n    readU128() {\r\n        const buf = this.readBuffer(16);\r\n        return new bn_js_1.default(buf, \"le\");\r\n    }\r\n    readU256() {\r\n        const buf = this.readBuffer(32);\r\n        return new bn_js_1.default(buf, \"le\");\r\n    }\r\n    readU512() {\r\n        const buf = this.readBuffer(64);\r\n        return new bn_js_1.default(buf, \"le\");\r\n    }\r\n    readBuffer(len) {\r\n        if (this.offset + len > this.buf.length) {\r\n            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\r\n        }\r\n        const result = this.buf.slice(this.offset, this.offset + len);\r\n        this.offset += len;\r\n        return result;\r\n    }\r\n    readString() {\r\n        const len = this.readU32();\r\n        const buf = this.readBuffer(len);\r\n        try {\r\n            // NOTE: Using TextDecoder to fail on invalid UTF-8\r\n            return textDecoder.decode(buf);\r\n        }\r\n        catch (e) {\r\n            throw new BorshError(`Error decoding UTF-8 string: ${e}`);\r\n        }\r\n    }\r\n    readFixedArray(len) {\r\n        return new Uint8Array(this.readBuffer(len));\r\n    }\r\n    readArray(fn) {\r\n        const len = this.readU32();\r\n        const result = Array();\r\n        for (let i = 0; i < len; ++i) {\r\n            result.push(fn());\r\n        }\r\n        return result;\r\n    }\r\n}\r\n__decorate([\r\n    handlingRangeError\r\n], BinaryReader.prototype, \"readU8\", null);\r\n__decorate([\r\n    handlingRangeError\r\n], BinaryReader.prototype, \"readU16\", null);\r\n__decorate([\r\n    handlingRangeError\r\n], BinaryReader.prototype, \"readU32\", null);\r\n__decorate([\r\n    handlingRangeError\r\n], BinaryReader.prototype, \"readU64\", null);\r\n__decorate([\r\n    handlingRangeError\r\n], BinaryReader.prototype, \"readU128\", null);\r\n__decorate([\r\n    handlingRangeError\r\n], BinaryReader.prototype, \"readU256\", null);\r\n__decorate([\r\n    handlingRangeError\r\n], BinaryReader.prototype, \"readU512\", null);\r\n__decorate([\r\n    handlingRangeError\r\n], BinaryReader.prototype, \"readString\", null);\r\n__decorate([\r\n    handlingRangeError\r\n], BinaryReader.prototype, \"readFixedArray\", null);\r\n__decorate([\r\n    handlingRangeError\r\n], BinaryReader.prototype, \"readArray\", null);\r\nexports.BinaryReader = BinaryReader;\r\nfunction capitalizeFirstLetter(string) {\r\n    return string.charAt(0).toUpperCase() + string.slice(1);\r\n}\r\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\r\n    try {\r\n        // TODO: Handle missing values properly (make sure they never result in just skipped write)\r\n        if (typeof fieldType === \"string\") {\r\n            writer[`write${capitalizeFirstLetter(fieldType)}`](value);\r\n        }\r\n        else if (fieldType instanceof Array) {\r\n            if (typeof fieldType[0] === \"number\") {\r\n                if (value.length !== fieldType[0]) {\r\n                    throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\r\n                }\r\n                writer.writeFixedArray(value);\r\n            }\r\n            else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\r\n                if (value.length !== fieldType[1]) {\r\n                    throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);\r\n                }\r\n                for (let i = 0; i < fieldType[1]; i++) {\r\n                    serializeField(schema, null, value[i], fieldType[0], writer);\r\n                }\r\n            }\r\n            else {\r\n                writer.writeArray(value, (item) => {\r\n                    serializeField(schema, fieldName, item, fieldType[0], writer);\r\n                });\r\n            }\r\n        }\r\n        else if (fieldType.kind !== undefined) {\r\n            switch (fieldType.kind) {\r\n                case \"option\": {\r\n                    if (value === null || value === undefined) {\r\n                        writer.writeU8(0);\r\n                    }\r\n                    else {\r\n                        writer.writeU8(1);\r\n                        serializeField(schema, fieldName, value, fieldType.type, writer);\r\n                    }\r\n                    break;\r\n                }\r\n                case \"map\": {\r\n                    writer.writeU32(value.size);\r\n                    value.forEach((val, key) => {\r\n                        serializeField(schema, fieldName, key, fieldType.key, writer);\r\n                        serializeField(schema, fieldName, val, fieldType.value, writer);\r\n                    });\r\n                    break;\r\n                }\r\n                default:\r\n                    throw new BorshError(`FieldType ${fieldType} unrecognized`);\r\n            }\r\n        }\r\n        else {\r\n            serializeStruct(schema, value, writer);\r\n        }\r\n    }\r\n    catch (error) {\r\n        if (error instanceof BorshError) {\r\n            error.addToFieldPath(fieldName);\r\n        }\r\n        throw error;\r\n    }\r\n}\r\nfunction serializeStruct(schema, obj, writer) {\r\n    if (typeof obj.borshSerialize === \"function\") {\r\n        obj.borshSerialize(writer);\r\n        return;\r\n    }\r\n    const structSchema = schema.get(obj.constructor);\r\n    if (!structSchema) {\r\n        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\r\n    }\r\n    if (structSchema.kind === \"struct\") {\r\n        structSchema.fields.map(([fieldName, fieldType]) => {\r\n            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\r\n        });\r\n    }\r\n    else if (structSchema.kind === \"enum\") {\r\n        const name = obj[structSchema.field];\r\n        for (let idx = 0; idx < structSchema.values.length; ++idx) {\r\n            const [fieldName, fieldType] = structSchema.values[idx];\r\n            if (fieldName === name) {\r\n                writer.writeU8(idx);\r\n                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\r\n    }\r\n}\r\n/// Serialize given object using schema of the form:\r\n/// { class_name -> [ [field_name, field_type], .. ], .. }\r\nfunction serialize(schema, obj, Writer = BinaryWriter) {\r\n    const writer = new Writer();\r\n    serializeStruct(schema, obj, writer);\r\n    return writer.toArray();\r\n}\r\nexports.serialize = serialize;\r\nfunction deserializeField(schema, fieldName, fieldType, reader) {\r\n    try {\r\n        if (typeof fieldType === \"string\") {\r\n            return reader[`read${capitalizeFirstLetter(fieldType)}`]();\r\n        }\r\n        if (fieldType instanceof Array) {\r\n            if (typeof fieldType[0] === \"number\") {\r\n                return reader.readFixedArray(fieldType[0]);\r\n            }\r\n            else if (typeof fieldType[1] === \"number\") {\r\n                const arr = [];\r\n                for (let i = 0; i < fieldType[1]; i++) {\r\n                    arr.push(deserializeField(schema, null, fieldType[0], reader));\r\n                }\r\n                return arr;\r\n            }\r\n            else {\r\n                return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));\r\n            }\r\n        }\r\n        if (fieldType.kind === \"option\") {\r\n            const option = reader.readU8();\r\n            if (option) {\r\n                return deserializeField(schema, fieldName, fieldType.type, reader);\r\n            }\r\n            return undefined;\r\n        }\r\n        if (fieldType.kind === \"map\") {\r\n            let map = new Map();\r\n            const length = reader.readU32();\r\n            for (let i = 0; i < length; i++) {\r\n                const key = deserializeField(schema, fieldName, fieldType.key, reader);\r\n                const val = deserializeField(schema, fieldName, fieldType.value, reader);\r\n                map.set(key, val);\r\n            }\r\n            return map;\r\n        }\r\n        return deserializeStruct(schema, fieldType, reader);\r\n    }\r\n    catch (error) {\r\n        if (error instanceof BorshError) {\r\n            error.addToFieldPath(fieldName);\r\n        }\r\n        throw error;\r\n    }\r\n}\r\nfunction deserializeStruct(schema, classType, reader) {\r\n    if (typeof classType.borshDeserialize === \"function\") {\r\n        return classType.borshDeserialize(reader);\r\n    }\r\n    const structSchema = schema.get(classType);\r\n    if (!structSchema) {\r\n        throw new BorshError(`Class ${classType.name} is missing in schema`);\r\n    }\r\n    if (structSchema.kind === \"struct\") {\r\n        const result = {};\r\n        for (const [fieldName, fieldType] of schema.get(classType).fields) {\r\n            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\r\n        }\r\n        return new classType(result);\r\n    }\r\n    if (structSchema.kind === \"enum\") {\r\n        const idx = reader.readU8();\r\n        if (idx >= structSchema.values.length) {\r\n            throw new BorshError(`Enum index: ${idx} is out of range`);\r\n        }\r\n        const [fieldName, fieldType] = structSchema.values[idx];\r\n        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\r\n        return new classType({ [fieldName]: fieldValue });\r\n    }\r\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\r\n}\r\n/// Deserializes object from bytes using schema.\r\nfunction deserialize(schema, classType, buffer, Reader = BinaryReader) {\r\n    const reader = new Reader(buffer);\r\n    const result = deserializeStruct(schema, classType, reader);\r\n    if (reader.offset < buffer.length) {\r\n        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\r\n    }\r\n    return result;\r\n}\r\nexports.deserialize = deserialize;\r\n/// Deserializes object from bytes using schema, without checking the length read\r\nfunction deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {\r\n    const reader = new Reader(buffer);\r\n    return deserializeStruct(schema, classType, reader);\r\n}\r\nexports.deserializeUnchecked = deserializeUnchecked;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}