{"ast":null,"code":"/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.js';\nimport { aInRange, bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n  validateObject(curve, {\n    a: 'bigint'\n  }, {\n    montgomeryBits: 'isSafeInteger',\n    nByteLength: 'isSafeInteger',\n    adjustScalarBytes: 'function',\n    domain: 'function',\n    powPminus2: 'function',\n    Gu: 'bigint'\n  });\n  // Set defaults\n  return Object.freeze({\n    ...curve\n  });\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef) {\n  const CURVE = validateOpts(curveDef);\n  const {\n    P\n  } = CURVE;\n  const modP = n => mod(n, P);\n  const montgomeryBits = CURVE.montgomeryBits;\n  const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n  const fieldLen = CURVE.nByteLength;\n  const adjustScalarBytes = CURVE.adjustScalarBytes || (bytes => bytes);\n  const powPminus2 = CURVE.powPminus2 || (x => pow(x, P - BigInt(2), P));\n  // cswap from RFC7748. But it is not from RFC7748!\n  /*\r\n    cswap(swap, x_2, x_3):\r\n         dummy = mask(swap) AND (x_2 XOR x_3)\r\n         x_2 = x_2 XOR dummy\r\n         x_3 = x_3 XOR dummy\r\n         Return (x_2, x_3)\r\n  Where mask(swap) is the all-1 or all-0 word of the same length as x_2\r\n   and x_3, computed, e.g., as mask(swap) = 0 - swap.\r\n  */\n  function cswap(swap, x_2, x_3) {\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy);\n    x_3 = modP(x_3 + dummy);\n    return [x_2, x_3];\n  }\n  // x25519 from 4\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n  /**\r\n   *\r\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\r\n   * @param scalar by which the point would be multiplied\r\n   * @returns new Point on Montgomery curve\r\n   */\n  function montgomeryLadder(u, scalar) {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, _0n, P);\n    // Section 5: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = k >> t & _1n;\n      swap ^= k_t;\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      swap = k_t;\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    // (x_2, x_3) = cswap(swap, x_2, x_3)\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    // (z_2, z_3) = cswap(swap, z_2, z_3)\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    // z_2^(p - 2)\n    const z2 = powPminus2(z_2);\n    // Return x_2 * (z_2^(p - 2))\n    return modP(x_2 * z2);\n  }\n  function encodeUCoordinate(u) {\n    return numberToBytesLE(modP(u), montgomeryBytes);\n  }\n  function decodeUCoordinate(uEnc) {\n    // Section 5: When receiving such an array, implementations of X25519\n    // MUST mask the most significant bit in the final byte.\n    const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n    if (fieldLen === 32) u[31] &= 127; // 0b0111_1111\n    return bytesToNumberLE(u);\n  }\n  function decodeScalar(n) {\n    const bytes = ensureBytes('scalar', n);\n    const len = bytes.length;\n    if (len !== montgomeryBytes && len !== fieldLen) throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);\n    return bytesToNumberLE(adjustScalarBytes(bytes));\n  }\n  function scalarMult(scalar, u) {\n    const pointU = decodeUCoordinate(u);\n    const _scalar = decodeScalar(scalar);\n    const pu = montgomeryLadder(pointU, _scalar);\n    // The result was not contributory\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('Invalid private or public key received');\n    return encodeUCoordinate(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  const GuBytes = encodeUCoordinate(CURVE.Gu);\n  function scalarMultBase(scalar) {\n    return scalarMult(scalar, GuBytes);\n  }\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n    getPublicKey: privateKey => scalarMultBase(privateKey),\n    utils: {\n      randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength)\n    },\n    GuBytes: GuBytes\n  };\n}","map":{"version":3,"names":["mod","pow","aInRange","bytesToNumberLE","ensureBytes","numberToBytesLE","validateObject","_0n","BigInt","_1n","validateOpts","curve","a","montgomeryBits","nByteLength","adjustScalarBytes","domain","powPminus2","Gu","Object","freeze","montgomery","curveDef","CURVE","P","modP","n","montgomeryBytes","Math","ceil","fieldLen","bytes","x","cswap","swap","x_2","x_3","dummy","a24","montgomeryLadder","u","scalar","k","x_1","z_2","z_3","sw","t","k_t","A","AA","B","BB","E","C","D","DA","CB","dacb","da_cb","z2","encodeUCoordinate","decodeUCoordinate","uEnc","decodeScalar","len","length","Error","scalarMult","pointU","_scalar","pu","GuBytes","scalarMultBase","getSharedSecret","privateKey","publicKey","getPublicKey","utils","randomPrivateKey","randomBytes"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@noble\\curves\\src\\abstract\\montgomery.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nimport { mod, pow } from './modular.js';\r\nimport {\r\n  aInRange,\r\n  bytesToNumberLE,\r\n  ensureBytes,\r\n  numberToBytesLE,\r\n  validateObject,\r\n} from './utils.js';\r\n\r\nconst _0n = BigInt(0);\r\nconst _1n = BigInt(1);\r\ntype Hex = string | Uint8Array;\r\n\r\nexport type CurveType = {\r\n  P: bigint; // finite field prime\r\n  nByteLength: number;\r\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array;\r\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\r\n  a: bigint;\r\n  montgomeryBits: number;\r\n  powPminus2?: (x: bigint) => bigint;\r\n  xyToU?: (x: bigint, y: bigint) => bigint;\r\n  Gu: bigint;\r\n  randomBytes?: (bytesLength?: number) => Uint8Array;\r\n};\r\nexport type CurveFn = {\r\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\r\n  scalarMultBase: (scalar: Hex) => Uint8Array;\r\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\r\n  getPublicKey: (privateKey: Hex) => Uint8Array;\r\n  utils: { randomPrivateKey: () => Uint8Array };\r\n  GuBytes: Uint8Array;\r\n};\r\n\r\nfunction validateOpts(curve: CurveType) {\r\n  validateObject(\r\n    curve,\r\n    {\r\n      a: 'bigint',\r\n    },\r\n    {\r\n      montgomeryBits: 'isSafeInteger',\r\n      nByteLength: 'isSafeInteger',\r\n      adjustScalarBytes: 'function',\r\n      domain: 'function',\r\n      powPminus2: 'function',\r\n      Gu: 'bigint',\r\n    }\r\n  );\r\n  // Set defaults\r\n  return Object.freeze({ ...curve } as const);\r\n}\r\n\r\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\r\n// Uses only one coordinate instead of two\r\nexport function montgomery(curveDef: CurveType): CurveFn {\r\n  const CURVE = validateOpts(curveDef);\r\n  const { P } = CURVE;\r\n  const modP = (n: bigint) => mod(n, P);\r\n  const montgomeryBits = CURVE.montgomeryBits;\r\n  const montgomeryBytes = Math.ceil(montgomeryBits / 8);\r\n  const fieldLen = CURVE.nByteLength;\r\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\r\n  const powPminus2 = CURVE.powPminus2 || ((x: bigint) => pow(x, P - BigInt(2), P));\r\n\r\n  // cswap from RFC7748. But it is not from RFC7748!\r\n  /*\r\n    cswap(swap, x_2, x_3):\r\n         dummy = mask(swap) AND (x_2 XOR x_3)\r\n         x_2 = x_2 XOR dummy\r\n         x_3 = x_3 XOR dummy\r\n         Return (x_2, x_3)\r\n  Where mask(swap) is the all-1 or all-0 word of the same length as x_2\r\n   and x_3, computed, e.g., as mask(swap) = 0 - swap.\r\n  */\r\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): [bigint, bigint] {\r\n    const dummy = modP(swap * (x_2 - x_3));\r\n    x_2 = modP(x_2 - dummy);\r\n    x_3 = modP(x_3 + dummy);\r\n    return [x_2, x_3];\r\n  }\r\n\r\n  // x25519 from 4\r\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\r\n  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\r\n  /**\r\n   *\r\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\r\n   * @param scalar by which the point would be multiplied\r\n   * @returns new Point on Montgomery curve\r\n   */\r\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\r\n    aInRange('u', u, _0n, P);\r\n    aInRange('scalar', scalar, _0n, P);\r\n    // Section 5: Implementations MUST accept non-canonical values and process them as\r\n    // if they had been reduced modulo the field prime.\r\n    const k = scalar;\r\n    const x_1 = u;\r\n    let x_2 = _1n;\r\n    let z_2 = _0n;\r\n    let x_3 = u;\r\n    let z_3 = _1n;\r\n    let swap = _0n;\r\n    let sw: [bigint, bigint];\r\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\r\n      const k_t = (k >> t) & _1n;\r\n      swap ^= k_t;\r\n      sw = cswap(swap, x_2, x_3);\r\n      x_2 = sw[0];\r\n      x_3 = sw[1];\r\n      sw = cswap(swap, z_2, z_3);\r\n      z_2 = sw[0];\r\n      z_3 = sw[1];\r\n      swap = k_t;\r\n\r\n      const A = x_2 + z_2;\r\n      const AA = modP(A * A);\r\n      const B = x_2 - z_2;\r\n      const BB = modP(B * B);\r\n      const E = AA - BB;\r\n      const C = x_3 + z_3;\r\n      const D = x_3 - z_3;\r\n      const DA = modP(D * A);\r\n      const CB = modP(C * B);\r\n      const dacb = DA + CB;\r\n      const da_cb = DA - CB;\r\n      x_3 = modP(dacb * dacb);\r\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\r\n      x_2 = modP(AA * BB);\r\n      z_2 = modP(E * (AA + modP(a24 * E)));\r\n    }\r\n    // (x_2, x_3) = cswap(swap, x_2, x_3)\r\n    sw = cswap(swap, x_2, x_3);\r\n    x_2 = sw[0];\r\n    x_3 = sw[1];\r\n    // (z_2, z_3) = cswap(swap, z_2, z_3)\r\n    sw = cswap(swap, z_2, z_3);\r\n    z_2 = sw[0];\r\n    z_3 = sw[1];\r\n    // z_2^(p - 2)\r\n    const z2 = powPminus2(z_2);\r\n    // Return x_2 * (z_2^(p - 2))\r\n    return modP(x_2 * z2);\r\n  }\r\n\r\n  function encodeUCoordinate(u: bigint): Uint8Array {\r\n    return numberToBytesLE(modP(u), montgomeryBytes);\r\n  }\r\n\r\n  function decodeUCoordinate(uEnc: Hex): bigint {\r\n    // Section 5: When receiving such an array, implementations of X25519\r\n    // MUST mask the most significant bit in the final byte.\r\n    const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\r\n    if (fieldLen === 32) u[31] &= 127; // 0b0111_1111\r\n    return bytesToNumberLE(u);\r\n  }\r\n  function decodeScalar(n: Hex): bigint {\r\n    const bytes = ensureBytes('scalar', n);\r\n    const len = bytes.length;\r\n    if (len !== montgomeryBytes && len !== fieldLen)\r\n      throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);\r\n    return bytesToNumberLE(adjustScalarBytes(bytes));\r\n  }\r\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\r\n    const pointU = decodeUCoordinate(u);\r\n    const _scalar = decodeScalar(scalar);\r\n    const pu = montgomeryLadder(pointU, _scalar);\r\n    // The result was not contributory\r\n    // https://cr.yp.to/ecdh.html#validate\r\n    if (pu === _0n) throw new Error('Invalid private or public key received');\r\n    return encodeUCoordinate(pu);\r\n  }\r\n  // Computes public key from private. By doing scalar multiplication of base point.\r\n  const GuBytes = encodeUCoordinate(CURVE.Gu);\r\n  function scalarMultBase(scalar: Hex): Uint8Array {\r\n    return scalarMult(scalar, GuBytes);\r\n  }\r\n\r\n  return {\r\n    scalarMult,\r\n    scalarMultBase,\r\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\r\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\r\n    utils: { randomPrivateKey: () => CURVE.randomBytes!(CURVE.nByteLength) },\r\n    GuBytes: GuBytes,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}