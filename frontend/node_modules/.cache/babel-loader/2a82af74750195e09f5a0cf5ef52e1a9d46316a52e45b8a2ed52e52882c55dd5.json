{"ast":null,"code":"import { PublicKey } from '@solana/web3.js';\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\nconst tokenGroupCodec = getStructCodec([['updateAuthority', fixCodecSize(getBytesCodec(), 32)], ['mint', fixCodecSize(getBytesCodec(), 32)], ['size', getU64Codec()], ['maxSize', getU64Codec()]]);\nexport const TOKEN_GROUP_SIZE = tokenGroupCodec.fixedSize;\n// Checks if all elements in the array are 0\nfunction isNonePubkey(buffer) {\n  for (let i = 0; i < buffer.length; i++) {\n    if (buffer[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n// Pack TokenGroup into byte slab\nexport function packTokenGroup(group) {\n  // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\n  const updateAuthority = group.updateAuthority ?? PublicKey.default;\n  return tokenGroupCodec.encode({\n    updateAuthority: updateAuthority.toBuffer(),\n    mint: group.mint.toBuffer(),\n    size: group.size,\n    maxSize: group.maxSize\n  });\n}\n// unpack byte slab into TokenGroup\nexport function unpackTokenGroup(buffer) {\n  const data = tokenGroupCodec.decode(buffer);\n  return isNonePubkey(data.updateAuthority) ? {\n    mint: new PublicKey(data.mint),\n    size: data.size,\n    maxSize: data.maxSize\n  } : {\n    updateAuthority: new PublicKey(data.updateAuthority),\n    mint: new PublicKey(data.mint),\n    size: data.size,\n    maxSize: data.maxSize\n  };\n}","map":{"version":3,"names":["PublicKey","fixCodecSize","getBytesCodec","getStructCodec","getU64Codec","tokenGroupCodec","TOKEN_GROUP_SIZE","fixedSize","isNonePubkey","buffer","i","length","packTokenGroup","group","updateAuthority","default","encode","toBuffer","mint","size","maxSize","unpackTokenGroup","data","decode"],"sources":["/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token-group/src/state/tokenGroup.ts"],"sourcesContent":["import { PublicKey } from '@solana/web3.js';\nimport type { ReadonlyUint8Array } from '@solana/codecs';\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\n\nconst tokenGroupCodec = getStructCodec([\n    ['updateAuthority', fixCodecSize(getBytesCodec(), 32)],\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\n    ['size', getU64Codec()],\n    ['maxSize', getU64Codec()],\n]);\n\nexport const TOKEN_GROUP_SIZE = tokenGroupCodec.fixedSize;\n\nexport interface TokenGroup {\n    /** The authority that can sign to update the group */\n    updateAuthority?: PublicKey;\n    /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint */\n    mint: PublicKey;\n    /** The current number of group members */\n    size: bigint;\n    /** The maximum number of group members */\n    maxSize: bigint;\n}\n\n// Checks if all elements in the array are 0\nfunction isNonePubkey(buffer: ReadonlyUint8Array): boolean {\n    for (let i = 0; i < buffer.length; i++) {\n        if (buffer[i] !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Pack TokenGroup into byte slab\nexport function packTokenGroup(group: TokenGroup): ReadonlyUint8Array {\n    // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\n    const updateAuthority = group.updateAuthority ?? PublicKey.default;\n    return tokenGroupCodec.encode({\n        updateAuthority: updateAuthority.toBuffer(),\n        mint: group.mint.toBuffer(),\n        size: group.size,\n        maxSize: group.maxSize,\n    });\n}\n\n// unpack byte slab into TokenGroup\nexport function unpackTokenGroup(buffer: Buffer | Uint8Array | ReadonlyUint8Array): TokenGroup {\n    const data = tokenGroupCodec.decode(buffer);\n\n    return isNonePubkey(data.updateAuthority)\n        ? {\n              mint: new PublicKey(data.mint),\n              size: data.size,\n              maxSize: data.maxSize,\n          }\n        : {\n              updateAuthority: new PublicKey(data.updateAuthority),\n              mint: new PublicKey(data.mint),\n              size: data.size,\n              maxSize: data.maxSize,\n          };\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,iBAAiB;AAE3C,SAASC,YAAY,EAAEC,aAAa,EAAEC,cAAc,EAAEC,WAAW,QAAQ,gBAAgB;AAEzF,MAAMC,eAAe,GAAGF,cAAc,CAAC,CACnC,CAAC,iBAAiB,EAAEF,YAAY,CAACC,aAAa,EAAE,EAAE,EAAE,CAAC,CAAC,EACtD,CAAC,MAAM,EAAED,YAAY,CAACC,aAAa,EAAE,EAAE,EAAE,CAAC,CAAC,EAC3C,CAAC,MAAM,EAAEE,WAAW,EAAE,CAAC,EACvB,CAAC,SAAS,EAAEA,WAAW,EAAE,CAAC,CAC7B,CAAC;AAEF,OAAO,MAAME,gBAAgB,GAAGD,eAAe,CAACE,SAAS;AAazD;AACA,SAASC,YAAYA,CAACC,MAA0B;EAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IACpC,IAAID,MAAM,CAACC,CAAC,CAAC,KAAK,CAAC,EAAE;MACjB,OAAO,KAAK;IAChB;EACJ;EACA,OAAO,IAAI;AACf;AAEA;AACA,OAAM,SAAUE,cAAcA,CAACC,KAAiB;EAC5C;EACA,MAAMC,eAAe,GAAGD,KAAK,CAACC,eAAe,IAAId,SAAS,CAACe,OAAO;EAClE,OAAOV,eAAe,CAACW,MAAM,CAAC;IAC1BF,eAAe,EAAEA,eAAe,CAACG,QAAQ,EAAE;IAC3CC,IAAI,EAAEL,KAAK,CAACK,IAAI,CAACD,QAAQ,EAAE;IAC3BE,IAAI,EAAEN,KAAK,CAACM,IAAI;IAChBC,OAAO,EAAEP,KAAK,CAACO;GAClB,CAAC;AACN;AAEA;AACA,OAAM,SAAUC,gBAAgBA,CAACZ,MAAgD;EAC7E,MAAMa,IAAI,GAAGjB,eAAe,CAACkB,MAAM,CAACd,MAAM,CAAC;EAE3C,OAAOD,YAAY,CAACc,IAAI,CAACR,eAAe,CAAC,GACnC;IACII,IAAI,EAAE,IAAIlB,SAAS,CAACsB,IAAI,CAACJ,IAAI,CAAC;IAC9BC,IAAI,EAAEG,IAAI,CAACH,IAAI;IACfC,OAAO,EAAEE,IAAI,CAACF;GACjB,GACD;IACIN,eAAe,EAAE,IAAId,SAAS,CAACsB,IAAI,CAACR,eAAe,CAAC;IACpDI,IAAI,EAAE,IAAIlB,SAAS,CAACsB,IAAI,CAACJ,IAAI,CAAC;IAC9BC,IAAI,EAAEG,IAAI,CAACH,IAAI;IACfC,OAAO,EAAEE,IAAI,CAACF;GACjB;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}