{"ast":null,"code":"import { PublicKey } from '@solana/web3.js';\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\nconst tokenGroupCodec = getStructCodec([['updateAuthority', fixCodecSize(getBytesCodec(), 32)], ['mint', fixCodecSize(getBytesCodec(), 32)], ['size', getU64Codec()], ['maxSize', getU64Codec()]]);\nexport const TOKEN_GROUP_SIZE = tokenGroupCodec.fixedSize;\n// Checks if all elements in the array are 0\nfunction isNonePubkey(buffer) {\n  for (let i = 0; i < buffer.length; i++) {\n    if (buffer[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n// Pack TokenGroup into byte slab\nexport function packTokenGroup(group) {\n  // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\n  const updateAuthority = group.updateAuthority ?? PublicKey.default;\n  return tokenGroupCodec.encode({\n    updateAuthority: updateAuthority.toBuffer(),\n    mint: group.mint.toBuffer(),\n    size: group.size,\n    maxSize: group.maxSize\n  });\n}\n// unpack byte slab into TokenGroup\nexport function unpackTokenGroup(buffer) {\n  const data = tokenGroupCodec.decode(buffer);\n  return isNonePubkey(data.updateAuthority) ? {\n    mint: new PublicKey(data.mint),\n    size: data.size,\n    maxSize: data.maxSize\n  } : {\n    updateAuthority: new PublicKey(data.updateAuthority),\n    mint: new PublicKey(data.mint),\n    size: data.size,\n    maxSize: data.maxSize\n  };\n}","map":{"version":3,"names":["PublicKey","fixCodecSize","getBytesCodec","getStructCodec","getU64Codec","tokenGroupCodec","TOKEN_GROUP_SIZE","fixedSize","isNonePubkey","buffer","i","length","packTokenGroup","group","updateAuthority","default","encode","toBuffer","mint","size","maxSize","unpackTokenGroup","data","decode"],"sources":["C:\\monitor_sol_web\\solactrackmap\\node_modules\\@solana\\spl-token-group\\src\\state\\tokenGroup.ts"],"sourcesContent":["import { PublicKey } from '@solana/web3.js';\r\nimport type { ReadonlyUint8Array } from '@solana/codecs';\r\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\r\n\r\nconst tokenGroupCodec = getStructCodec([\r\n    ['updateAuthority', fixCodecSize(getBytesCodec(), 32)],\r\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\r\n    ['size', getU64Codec()],\r\n    ['maxSize', getU64Codec()],\r\n]);\r\n\r\nexport const TOKEN_GROUP_SIZE = tokenGroupCodec.fixedSize;\r\n\r\nexport interface TokenGroup {\r\n    /** The authority that can sign to update the group */\r\n    updateAuthority?: PublicKey;\r\n    /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint */\r\n    mint: PublicKey;\r\n    /** The current number of group members */\r\n    size: bigint;\r\n    /** The maximum number of group members */\r\n    maxSize: bigint;\r\n}\r\n\r\n// Checks if all elements in the array are 0\r\nfunction isNonePubkey(buffer: ReadonlyUint8Array): boolean {\r\n    for (let i = 0; i < buffer.length; i++) {\r\n        if (buffer[i] !== 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// Pack TokenGroup into byte slab\r\nexport function packTokenGroup(group: TokenGroup): ReadonlyUint8Array {\r\n    // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\r\n    const updateAuthority = group.updateAuthority ?? PublicKey.default;\r\n    return tokenGroupCodec.encode({\r\n        updateAuthority: updateAuthority.toBuffer(),\r\n        mint: group.mint.toBuffer(),\r\n        size: group.size,\r\n        maxSize: group.maxSize,\r\n    });\r\n}\r\n\r\n// unpack byte slab into TokenGroup\r\nexport function unpackTokenGroup(buffer: Buffer | Uint8Array | ReadonlyUint8Array): TokenGroup {\r\n    const data = tokenGroupCodec.decode(buffer);\r\n\r\n    return isNonePubkey(data.updateAuthority)\r\n        ? {\r\n              mint: new PublicKey(data.mint),\r\n              size: data.size,\r\n              maxSize: data.maxSize,\r\n          }\r\n        : {\r\n              updateAuthority: new PublicKey(data.updateAuthority),\r\n              mint: new PublicKey(data.mint),\r\n              size: data.size,\r\n              maxSize: data.maxSize,\r\n          };\r\n}\r\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,iBAAiB;AAE3C,SAASC,YAAY,EAAEC,aAAa,EAAEC,cAAc,EAAEC,WAAW,QAAQ,gBAAgB;AAEzF,MAAMC,eAAe,GAAGF,cAAc,CAAC,CACnC,CAAC,iBAAiB,EAAEF,YAAY,CAACC,aAAa,EAAE,EAAE,EAAE,CAAC,CAAC,EACtD,CAAC,MAAM,EAAED,YAAY,CAACC,aAAa,EAAE,EAAE,EAAE,CAAC,CAAC,EAC3C,CAAC,MAAM,EAAEE,WAAW,EAAE,CAAC,EACvB,CAAC,SAAS,EAAEA,WAAW,EAAE,CAAC,CAC7B,CAAC;AAEF,OAAO,MAAME,gBAAgB,GAAGD,eAAe,CAACE,SAAS;AAazD;AACA,SAASC,YAAYA,CAACC,MAA0B;EAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IACpC,IAAID,MAAM,CAACC,CAAC,CAAC,KAAK,CAAC,EAAE;MACjB,OAAO,KAAK;IAChB;EACJ;EACA,OAAO,IAAI;AACf;AAEA;AACA,OAAM,SAAUE,cAAcA,CAACC,KAAiB;EAC5C;EACA,MAAMC,eAAe,GAAGD,KAAK,CAACC,eAAe,IAAId,SAAS,CAACe,OAAO;EAClE,OAAOV,eAAe,CAACW,MAAM,CAAC;IAC1BF,eAAe,EAAEA,eAAe,CAACG,QAAQ,EAAE;IAC3CC,IAAI,EAAEL,KAAK,CAACK,IAAI,CAACD,QAAQ,EAAE;IAC3BE,IAAI,EAAEN,KAAK,CAACM,IAAI;IAChBC,OAAO,EAAEP,KAAK,CAACO;GAClB,CAAC;AACN;AAEA;AACA,OAAM,SAAUC,gBAAgBA,CAACZ,MAAgD;EAC7E,MAAMa,IAAI,GAAGjB,eAAe,CAACkB,MAAM,CAACd,MAAM,CAAC;EAE3C,OAAOD,YAAY,CAACc,IAAI,CAACR,eAAe,CAAC,GACnC;IACII,IAAI,EAAE,IAAIlB,SAAS,CAACsB,IAAI,CAACJ,IAAI,CAAC;IAC9BC,IAAI,EAAEG,IAAI,CAACH,IAAI;IACfC,OAAO,EAAEE,IAAI,CAACF;GACjB,GACD;IACIN,eAAe,EAAE,IAAId,SAAS,CAACsB,IAAI,CAACR,eAAe,CAAC;IACpDI,IAAI,EAAE,IAAIlB,SAAS,CAACsB,IAAI,CAACJ,IAAI,CAAC;IAC9BC,IAAI,EAAEG,IAAI,CAACH,IAAI;IACfC,OAAO,EAAEE,IAAI,CAACF;GACjB;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}