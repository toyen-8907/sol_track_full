{"ast":null,"code":"import { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { createInitializeInstruction, createRemoveKeyInstruction, createUpdateAuthorityInstruction, createUpdateFieldInstruction, pack, unpack } from '@solana/spl-token-metadata';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { ExtensionType, getExtensionData, getNewAccountLenForExtensionLen } from '../extensionType.js';\nimport { updateTokenMetadata } from './state.js';\nimport { TokenAccountNotFoundError } from '../../errors.js';\nimport { unpackMint } from '../../state/index.js';\nasync function getAdditionalRentForNewMetadata(connection, address, tokenMetadata, programId = TOKEN_2022_PROGRAM_ID) {\n  const info = await connection.getAccountInfo(address);\n  if (!info) {\n    throw new TokenAccountNotFoundError();\n  }\n  const extensionLen = pack(tokenMetadata).length;\n  const newAccountLen = getNewAccountLenForExtensionLen(info, address, ExtensionType.TokenMetadata, extensionLen, programId);\n  if (newAccountLen <= info.data.length) {\n    return 0;\n  }\n  const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n  return newRentExemptMinimum - info.lamports;\n}\nasync function getAdditionalRentForUpdatedMetadata(connection, address, field, value, programId = TOKEN_2022_PROGRAM_ID) {\n  const info = await connection.getAccountInfo(address);\n  if (!info) {\n    throw new TokenAccountNotFoundError();\n  }\n  const mint = unpackMint(address, info, programId);\n  const extensionData = getExtensionData(ExtensionType.TokenMetadata, mint.tlvData);\n  if (extensionData === null) {\n    throw new Error('TokenMetadata extension not initialized');\n  }\n  const updatedTokenMetadata = updateTokenMetadata(unpack(extensionData), field, value);\n  const extensionLen = pack(updatedTokenMetadata).length;\n  const newAccountLen = getNewAccountLenForExtensionLen(info, address, ExtensionType.TokenMetadata, extensionLen, programId);\n  if (newAccountLen <= info.data.length) {\n    return 0;\n  }\n  const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n  return newRentExemptMinimum - info.lamports;\n}\n/**\n * Initializes a TLV entry with the basic token-metadata fields.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitialize(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n  const transaction = new Transaction().add(createInitializeInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority,\n    mint,\n    mintAuthority: mintAuthorityPublicKey,\n    name,\n    symbol,\n    uri\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Initializes a TLV entry with the basic token-metadata fields,\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitializeWithRentTransfer(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n  const transaction = new Transaction();\n  const lamports = await getAdditionalRentForNewMetadata(connection, mint, {\n    updateAuthority,\n    mint,\n    name,\n    symbol,\n    uri,\n    additionalMetadata: []\n  }, programId);\n  if (lamports > 0) {\n    transaction.add(SystemProgram.transfer({\n      fromPubkey: payer.publicKey,\n      toPubkey: mint,\n      lamports: lamports\n    }));\n  }\n  transaction.add(createInitializeInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority,\n    mint,\n    mintAuthority: mintAuthorityPublicKey,\n    name,\n    symbol,\n    uri\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateField(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction().add(createUpdateFieldInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority: updateAuthorityPublicKey,\n    field,\n    value\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateFieldWithRentTransfer(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction();\n  const lamports = await getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);\n  if (lamports > 0) {\n    transaction.add(SystemProgram.transfer({\n      fromPubkey: payer.publicKey,\n      toPubkey: mint,\n      lamports: lamports\n    }));\n  }\n  transaction.add(createUpdateFieldInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority: updateAuthorityPublicKey,\n    field,\n    value\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n * Remove a field in a token-metadata account.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param key              Key to remove in the additional metadata portion\n * @param idempotent       When true, instruction will not error if the key does not exist\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataRemoveKey(connection, payer, mint, updateAuthority, key, idempotent, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction().add(createRemoveKeyInstruction({\n    programId,\n    metadata: mint,\n    updateAuthority: updateAuthorityPublicKey,\n    key,\n    idempotent\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n/**\n *  Update authority\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param newAuthority     New authority for the token metadata, or unset\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateAuthority(connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {\n  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n  const transaction = new Transaction().add(createUpdateAuthorityInstruction({\n    programId,\n    metadata: mint,\n    oldAuthority: updateAuthorityPublicKey,\n    newAuthority\n  }));\n  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}","map":{"version":3,"names":["sendAndConfirmTransaction","SystemProgram","Transaction","createInitializeInstruction","createRemoveKeyInstruction","createUpdateAuthorityInstruction","createUpdateFieldInstruction","pack","unpack","TOKEN_2022_PROGRAM_ID","getSigners","ExtensionType","getExtensionData","getNewAccountLenForExtensionLen","updateTokenMetadata","TokenAccountNotFoundError","unpackMint","getAdditionalRentForNewMetadata","connection","address","tokenMetadata","programId","info","getAccountInfo","extensionLen","length","newAccountLen","TokenMetadata","data","newRentExemptMinimum","getMinimumBalanceForRentExemption","lamports","getAdditionalRentForUpdatedMetadata","field","value","mint","extensionData","tlvData","Error","updatedTokenMetadata","tokenMetadataInitialize","payer","updateAuthority","mintAuthority","name","symbol","uri","multiSigners","confirmOptions","mintAuthorityPublicKey","signers","transaction","add","metadata","tokenMetadataInitializeWithRentTransfer","additionalMetadata","transfer","fromPubkey","publicKey","toPubkey","tokenMetadataUpdateField","updateAuthorityPublicKey","tokenMetadataUpdateFieldWithRentTransfer","tokenMetadataRemoveKey","key","idempotent","tokenMetadataUpdateAuthority","newAuthority","oldAuthority"],"sources":["/Users/damentp01/project/sol_track_ac/node_modules/@solana/spl-token/src/extensions/tokenMetadata/actions.ts"],"sourcesContent":["import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport type { Field, TokenMetadata } from '@solana/spl-token-metadata';\nimport {\n    createInitializeInstruction,\n    createRemoveKeyInstruction,\n    createUpdateAuthorityInstruction,\n    createUpdateFieldInstruction,\n    pack,\n    unpack,\n} from '@solana/spl-token-metadata';\n\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { ExtensionType, getExtensionData, getNewAccountLenForExtensionLen } from '../extensionType.js';\nimport { updateTokenMetadata } from './state.js';\nimport { TokenAccountNotFoundError } from '../../errors.js';\nimport { unpackMint } from '../../state/index.js';\n\nasync function getAdditionalRentForNewMetadata(\n    connection: Connection,\n    address: PublicKey,\n    tokenMetadata: TokenMetadata,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<number> {\n    const info = await connection.getAccountInfo(address);\n    if (!info) {\n        throw new TokenAccountNotFoundError();\n    }\n\n    const extensionLen = pack(tokenMetadata).length;\n    const newAccountLen = getNewAccountLenForExtensionLen(\n        info,\n        address,\n        ExtensionType.TokenMetadata,\n        extensionLen,\n        programId,\n    );\n\n    if (newAccountLen <= info.data.length) {\n        return 0;\n    }\n\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n\n    return newRentExemptMinimum - info.lamports;\n}\n\nasync function getAdditionalRentForUpdatedMetadata(\n    connection: Connection,\n    address: PublicKey,\n    field: string | Field,\n    value: string,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<number> {\n    const info = await connection.getAccountInfo(address);\n    if (!info) {\n        throw new TokenAccountNotFoundError();\n    }\n\n    const mint = unpackMint(address, info, programId);\n    const extensionData = getExtensionData(ExtensionType.TokenMetadata, mint.tlvData);\n    if (extensionData === null) {\n        throw new Error('TokenMetadata extension not initialized');\n    }\n\n    const updatedTokenMetadata = updateTokenMetadata(unpack(extensionData), field, value);\n    const extensionLen = pack(updatedTokenMetadata).length;\n\n    const newAccountLen = getNewAccountLenForExtensionLen(\n        info,\n        address,\n        ExtensionType.TokenMetadata,\n        extensionLen,\n        programId,\n    );\n\n    if (newAccountLen <= info.data.length) {\n        return 0;\n    }\n\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n\n    return newRentExemptMinimum - info.lamports;\n}\n\n/**\n * Initializes a TLV entry with the basic token-metadata fields.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitialize(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    name: string,\n    symbol: string,\n    uri: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createInitializeInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            name,\n            symbol,\n            uri,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Initializes a TLV entry with the basic token-metadata fields,\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitializeWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    name: string,\n    symbol: string,\n    uri: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction();\n\n    const lamports = await getAdditionalRentForNewMetadata(\n        connection,\n        mint,\n        {\n            updateAuthority,\n            mint,\n            name,\n            symbol,\n            uri,\n            additionalMetadata: [],\n        },\n        programId,\n    );\n\n    if (lamports > 0) {\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\n    }\n\n    transaction.add(\n        createInitializeInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            name,\n            symbol,\n            uri,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateField(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    field: string | Field,\n    value: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateFieldInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            field,\n            value,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateFieldWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    field: string | Field,\n    value: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction();\n\n    const lamports = await getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);\n\n    if (lamports > 0) {\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\n    }\n\n    transaction.add(\n        createUpdateFieldInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            field,\n            value,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Remove a field in a token-metadata account.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param key              Key to remove in the additional metadata portion\n * @param idempotent       When true, instruction will not error if the key does not exist\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataRemoveKey(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    key: string,\n    idempotent: boolean,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createRemoveKeyInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            key,\n            idempotent,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n *  Update authority\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param newAuthority     New authority for the token metadata, or unset\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateAuthority(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    newAuthority: PublicKey | null,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateAuthorityInstruction({\n            programId,\n            metadata: mint,\n            oldAuthority: updateAuthorityPublicKey,\n            newAuthority,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}